- #xctf/work
	- #xctf/bug when using sqlitefs, the long scan of the database causes it to lock
		- ```
		  query := `SELECT SUBSTR(fragment, ?, ?) FROM file_fragments WHERE file_id = (SELECT id FROM file_metadata WHERE path = ?) AND fragment_index = ?`
		  row := f.db.QueryRow(query, internalOffset+1, readLength, f.path, fragmentIndex)
		  - var fragment []byte
		  err := row.Scan(&fragment)
		  if err != nil {
		    if err == sql.ErrNoRows {
		       if bytesReadTotal > 0 {
		          return bytesReadTotal, nil
		       }
		       return 0, io.EOF
		    }
		    return bytesReadTotal, err
		  }
		  ```
	- #xctf/code sqlitefs read, write, list
		- ```go
		  func (s *Service) Readdir(path string) ([]os.FileInfo, error) {
		      f, err := sqlitefs.NewSQLiteFile(s.db, path)
		      if err != nil {
		         return nil, errors.Wrapf(err, "failed to open sqlitefs")
		      }
		  
		      // *TODO breadchris implement pagination
		  *    if path == "/" {
		         return f.GetAllFiles()
		      } else {
		         return f.Readdir(1024)
		      }
		  }
		  
		  func (s *Service) RemoveFile(path string) error {
		      f, err := sqlitefs.NewSQLiteFile(s.db, path)
		      if err != nil {
		         return err
		      }
		      return f.Remove()
		  }
		  
		  func (s *Service) WriteFile(path string, r io.Reader) (int64, error) {
		      w := sqlitefs.NewSQLiteWriter(s.db, path)
		      defer w.Close()
		      return io.Copy(w, r)
		  }
		  
		  func (s *Service) ReadFile(path string, w io.Writer) (int64, error) {
		      f, err := sqlitefs.NewSQLiteFile(s.db, path)
		      if err != nil {
		         return 0, err
		      }
		      defer f.Close()
		      return io.Copy(w, f)
		  }
		  ```
- #go/book go by example https://gobyexample.com/