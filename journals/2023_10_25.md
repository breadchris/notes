- #protoflow/talk #conference/seagl
	- I want people to refine their sense on what a LEGO for code feels like
	- We should strive to build code that feels like this so that we can try to make coding more accessible to ourselves and others
	- #protoflow/talk/stories #seagl/talk
		- You want to code with LEGOs, not Mega Blocks
		- LEGOs hold up to scrutiny, and also don't over promise on what they are.
		- We tend to have pretty good judgement, even as kids, what toys are better than others
		- This is my attempt at taking what I have learned about both LEGOs and code, and trying to make writing code feel more like playing with LEGOs, because I really just miss doing that lol
		- Legos
		  collapsed:: true
			- The first LEGO set I ever had came from Mcdonalds, probably one of the last toys you could get in a happy meal that had any redeeming quality
			- After I built it for the first time, I allegedly would walk around with it all the time
			- I would fall asleep with it
			- I noticed that these pieces didn't have to be arranged in the way I was told to do so by the instructions. I could build whatever I wanted.
			- I remember how deeply satisfying it was to arrange and rearrange this limited set of pieces   into whatever I could think of. With a little imagination a crude representation could become what I wanted it to be.
			- Buying and building LEGOs became a fixation for me. Turning a whole section of the basement into my lair filled with new sets, partially disassembled sets, and random pieces from eroded sets from years past.
			- I think my mom got me a Mega Blocks set once and somehow the pieces ended up in one of these bins. Whenever I was looting around for pieces and I came across these pieces, they would immediately throw them away. But even if a single LEGO piece was found laying around the house, I would pick it up and return it to the bin.
			- It is an honest mistake Mom, Mega Blocks look so similar to LEGOs why would I care so much?
			- There are many design principles that keep LEGO being LEGO. And the brand has only ever faltered when they deviated from this set of design principles.
		- Building something simple
		  collapsed:: true
			- Is there a quintessential LEGO build, maybe a car/house?
			- For code, you might think of a TODO app
			- What could be simpler, and fundamentally helpful than displaying a list of things on a screen for someone to use a computer to help them keep track?
			- If you search "TODO MVC" you will find an endless number of projects, that all look quite different, trying to show you how to code this.
			- If you try to take the code for any one of these projects and put it in your own app, you will probably fail.
				- Dependencies will be out of date
				- They are incompatible
				- The code uses forgotten functions
			- If something as simple as a TODO app brings about this much complexity, does that feel like a LEGO brick you could use in your code?
			- With the explosion of open source software and packages that flying off the package registry's shelf, how can you tell which ones are more like LEGOs vs Mega Blocks?
			- Questions
				- When is the last time you worked on a side project?
				- Did it pan out like you wanted it to?
				- Was there something frustrating you were trying to figure out with the code?
		- Cooking
		  collapsed:: true
			- I don't play with LEGOs anymore, but I like to cook
			- I like to think of recipes as really just the composition of different recipes together to make something even more complicated
			- Peanut butter and jelly
				- Peanuts + blender = peanut butter
				- Stawberries + pectin = jelly
				- flour + water + yeast + salt = bread
				- bread + peanut butter + jelly = pb&j
			- We don't really write recipes like this though
			- Expect for literally [Cooking for Engineers](https://www.cookingforengineers.com)
			- If I want to make cool things in the kitchen, I have to follow normie language for expressing recipes
			- But I can't unsee the building blocks, I _have_ to have something that speaks to this
			- What does it look like?
			- A language? I am not an expert, also I want to be able to send this to my mom
			- I want to make a recipe site that feels effortless to follow, regardless of experience in the kitchen
			- There are hard problems in software development, and building good websites is certainly one of them
			- Trying to rapidly prototype features in the site as I came across them in the real world was really fun, but also insanely frustrating
			- As a side project, there was no months of planning by an engineering team to discuss and agree upon the best way to build this. Changes came sporadically and were layered on top of my desperate attempts to try to get React to do the thing that I wanted it to.
			- After 7 attempts at trying to build it with countless different technologies, I arrived at an app that I still not happy with.
			- As a solo dev who isn't constrained by a deadline, this process was incredibly enlightening.
			- I had learned that "modern" recommendations on how to build a web application are insanely confusing and I frankly have no idea how any developer working on a site does their job. Seriously, mad respect
			- Any one of the 7 attempts I could have doubled down on to ship so that people could use it. But none of them felt right!
		- I needed to stop following what people were recommending what I should or should not do with code and focus on the things I have learned as a programmer.
		- Thinking functionally
			- Working at Uber was a serious XP boost to my programmer skill tree
			- Uber came known for a number of interesting software design decisions, such as their use of microservices and many of them being written in Go
			- Go, in my opinion, embraces the ethos of what a LEGO is pretty well
			- Go was developed by some smart people at Bell Labs, and later was refined at Google to solve its problems:
				- Problems
			- When there are like 3 services for every engineer, people need to know how the "shit moves through the pipes"
			- The language prioritized simplicity above all else which has led to a lot of interesting effects
			  collapsed:: true
				- All packages are git repos, meaning you are just downloading source code, this means you can not just see what code you are including, but also how other developers write Go "CGO is not Go"
				- How many languages let you do that?
				- The package manager is built into the CLI, along with the commands for "run", "build", "test", "benchmark", "format", etc.
				- These are usually 3rd party libraries you need to "be in the know" about for your language
				- A simple, statically typed system means contextual information about the language is always there for me to go deeper on understanding the code
			- I saw Cadence (now Temporal), the workflow manager, scale to the size of the world
			- All that Cadence really did was harden Go's concurrency primitives to be able to scale effortlessly and reliably
			- Turns out that is a really good idea, they are worth a lot of money
			- I also got to see the internal rollout of GRPC and how much easier it was to interact with the thousands of internal microservices
			- Turns out that is also a really good idea, Buf is worth millions
			- Both of these technologies focus on programming primitives; functions and their types
			- Rallying behind a solidly built language, a reliable way to scale it, and a self documenting type system
			- LEGOs have rigid plastic connectors, unless you melt them, you can't mold them into a sculpture, you have to play by LEGO's unfailable rules in order to compose them together to build a sculpture
		- Why workflows
		  collapsed:: true
			- TODO
			- Workflows are the back bone behind any company.
			- Workflows are typically only reserved for large enterprises to schlep around invoices or work status on plane engine parts.
			- In reality, almost all of us are constantly building workflow management systems
			- This is something that I realized working on Refinery
		- The power of types
			- Types are a way to communicate intent
			- A programmer defines their intent to the computer, the compiler/runtime holds them to that
			- Types instruct others who want to play with the code, how to go about it
			- Protobuf is type system that has been refined over the past couple of decades at large tech companies.
			- GRPC, an extension of Protobuf, defines methods and their IO
			- If we are trying to write some code together, we can start by agreeing on what our type contract looks like and that provides a very clear foundation for all other work to stem from. You can build the frontend while I build the backend. I don't even need my code to be fully written. I could just serve back some mock data from the endpoint!
		- Protoflow
		  collapsed:: true
			- All of these design decisions were made by some of the best engineers in the world at a company who was pouring gasoline on their software development engine
			- The benefits of this research and engineering will not be realized by smaller development teams until more open source tools and educational resources (such as this talk) are accessible
			- I have started snapping together the bricks which I hope will be a foundational component for a lot of people to build upon
			- What I think is especially cool is that you don't even need to know Go to get value from this project
			- Protobuf is just a type system and you can compile the service stubs for any language you want to use
		- Parting words of wisdom
		  collapsed:: true
			- Possibly the best skill that you can learn as a developer is separating yourself from your code. Pursue higher levels of understanding about the code that you are writing. Ask "why are we building this?" "Why are we building it like this?" If you can't find answers to these questions, you probably got a problem.
			- Project ideas
		- Some real world examples
			- Minecraft
			- Roblox
			- Heroku had with the [twelve-factor app](https://12factor.net/) they were on to something
	- I have become obsessed with the idea of Go
	  collapsed:: true
		- The syntax is painfully simple, which often causes much frustration
		- People don't like the error handling
		- The pointers are pretty annoying
		- And I agree, Go is not a perfect language, if I wanted to code in a "perfect" language I would have chosen Haskell, or have just made my own with Lisp
		- Go doesn't try to do everything, it didn't have generics for many years
		- I am not trying to evangelize Go, I am just pointing out what features I believe should be in a system, language, framework, etc. you are giving out for other people to use
		- LEGOs have rigid plastic connectors, unless you melt them, you can't mold them into a sculpture, you have to play by LEGO's unfailable rules in order to compose them together to build a sculpture
		-
			-
	- #seagl/ideas
		- when you want to prove out your idea, you want it to be frictionless. Or at least, as frictionless as possible. The reason a good coder costs so much is that they have seen so much shit that doesn’t go together and have persevered to make it go together. The best coders have made things fit together so many times that they make a framework to not have to keep making things go together themselves, the code makes it happen. There is an article about why plumbers make so much, and it’s essentially the same reason https://naich.net/wordpress/index.php/ever-wondered-why-plumbers-are-paid-so-much/ pipe fittings.
		- When you don’t think about what pipe fittings to use, you get to focus on the fun stuff. I am not a plumber so I don’t know what the fun stuff of plumbing is, but i’m sure there is something. For coding, the fun stuff is being able to represent data in a new way that you haven’t seen before. See relationships between data for the first time, mp3 files that are now text that you can search. In the age of information, the frictionless development to production experience is nirvana.