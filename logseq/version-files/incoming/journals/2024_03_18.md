- #blog There is an interesting relationship between statically and dynamically typed languages. Attempting to define types for a problem you are looking at can feel like a fun, or frustrating, puzzle. When you figure out how to represent the domain of the problem, you now have code that not only holds you accountable in the rest of your code to abide by what the type dictates, but also communicates with all others who might wish to understand what the program is doing. What designing these types can obscure is the important question of do you actually know how to represent the domain. The alpha engineer will assuredly tell you yes, this is often not the reality. You only know what a domain looks like after you have collected and observed enough patterns. Even if you have studied the patterns, do your types reflect reality? Are they readable by someone else? Driving down the time it takes to collect the data necessary to understand these patterns is critical in the world of business, the most common application of writing code. Loosening the restrictions around what an application needs to know about the types of data it is dealing with means less code and understanding is needed to ship an app. When an app is able to be used by a user, they will begin to try things out. When their expectations are not met, their requests are fielded by the developers and new features are released. Here is where we close the gap on the relationship. As more features are written, the code grows, and there becomes a growing need to define what the data looks like. Errors creep into releases, fields want to be searched, new developers are scratching their head attempting to write anything. Statically defining types propagate this context throughout the code and make it easier to understand what information is or is not accessible in different parts of the code. There is no perfect hybrid solutions for solving this problem, but there are certainly attempts. Python has introduced type annotations in later versions which does help in communications, but in practice do not catch errors as they are often treated as an after thought. Typescript enforces more stricter types to javascript, and in my opinion does a better job compared to python. Although, the type system is turing complete and leads to exceptionally confusing type definitions as developers struggle in attempting to define their data domain. These confusing types put incredible burden on developer tools. since the types are programs, the tooling is executing the types to report on type hints and the resulting hint is often not something useable. Writing tests are often used in lieu of a static type systems. Often called "specs" or "specifications", tests can enforce code operating in a specific way. Prematurely writing many tests before understanding is fully formed can be a pain to manage as functions are constantly changing, breaking tests. There is an interesting idea that even in the most robust and beautiful type system, when faced with this challenge of a rapidly changing domain of understanding, you end up recreating the type system of a dynamically typed language.
	- As different parts of code start to come set, it is a good idea to try to define the contract of how to interface with them.
	- I believe there are approaches that are better than others. I think a very telling observation to make around whether or not a type system is working or not is how developers feel when using libraries. Since the author of the library is rarely sitting with the developer who included their code, the developer has to rely on the code to successfully communicate how it is to be used. Documentation for the library is typically the first resource checked. In dynamic languages this is depended on more than in static where tooling can make use of the defined types and present them to the developer as they are writing code. I personally prefer the tight loop of writing and reading what is available to me in the IDE as opposed to having to frequently move outside of my coding environment to refer to usage documentation (which I am hoping exists).
-