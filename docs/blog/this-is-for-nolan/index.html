<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>This is for Nolan | breadchris</title>
<meta name="keywords" content="blog/post">
<meta name="description" content="## SOLID principles
The set of five design principles for object-oriented programming that were first introduced by Robert C. Martin. These principles are intended to make software designs more understandable, flexible, and maintainable.
In Go, the SOLID principles can be applied as follows:
### Single Responsibility Principle (SRP)
Example:
```go
type UserService struct {
userRepository UserRepository
}
func (us *UserService) CreateUser(user *User) error {
return us.userRepository.Create(user)
}
func (us *UserService) GetUserByID(id int) (*User, error) {">
<meta name="author" content="breadchris">
<link rel="canonical" href="https://breadchris.com/blog/this-is-for-nolan/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7d0dbc7bebc97247baddbf44f81f3261912c9f64c3f03500922375b9988f4ea9.css" integrity="sha256-fQ28e&#43;vJcke63b9E&#43;B8yYZEsn2TD8DUAkiN1uZiPTqk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://breadchris.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://breadchris.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://breadchris.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://breadchris.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://breadchris.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script defer data-domain="breadchris.com" src="https://plausible.io/js/script.js"></script><meta property="og:title" content="This is for Nolan" />
<meta property="og:description" content="## SOLID principles
The set of five design principles for object-oriented programming that were first introduced by Robert C. Martin. These principles are intended to make software designs more understandable, flexible, and maintainable.
In Go, the SOLID principles can be applied as follows:
### Single Responsibility Principle (SRP)
Example:
```go
type UserService struct {
userRepository UserRepository
}
func (us *UserService) CreateUser(user *User) error {
return us.userRepository.Create(user)
}
func (us *UserService) GetUserByID(id int) (*User, error) {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://breadchris.com/blog/this-is-for-nolan/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2024-01-26T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-01-26T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="This is for Nolan"/>
<meta name="twitter:description" content="## SOLID principles
The set of five design principles for object-oriented programming that were first introduced by Robert C. Martin. These principles are intended to make software designs more understandable, flexible, and maintainable.
In Go, the SOLID principles can be applied as follows:
### Single Responsibility Principle (SRP)
Example:
```go
type UserService struct {
userRepository UserRepository
}
func (us *UserService) CreateUser(user *User) error {
return us.userRepository.Create(user)
}
func (us *UserService) GetUserByID(id int) (*User, error) {"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Blogs",
      "item": "https://breadchris.com/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "This is for Nolan",
      "item": "https://breadchris.com/blog/this-is-for-nolan/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "This is for Nolan",
  "name": "This is for Nolan",
  "description": "## SOLID principles\nThe set of five design principles for object-oriented programming that were first introduced by Robert C. Martin. These principles are intended to make software designs more understandable, flexible, and maintainable.\nIn Go, the SOLID principles can be applied as follows:\n### Single Responsibility Principle (SRP)\nExample:\n```go\ntype UserService struct {\nuserRepository UserRepository\n}\nfunc (us *UserService) CreateUser(user *User) error {\nreturn us.userRepository.Create(user)\n}\nfunc (us *UserService) GetUserByID(id int) (*User, error) {",
  "keywords": [
    "blog/post"
  ],
  "articleBody": "## SOLID principles\nThe set of five design principles for object-oriented programming that were first introduced by Robert C. Martin. These principles are intended to make software designs more understandable, flexible, and maintainable.\nIn Go, the SOLID principles can be applied as follows:\n### Single Responsibility Principle (SRP)\nExample:\n```go\ntype UserService struct {\nuserRepository UserRepository\n}\nfunc (us *UserService) CreateUser(user *User) error {\nreturn us.userRepository.Create(user)\n}\nfunc (us *UserService) GetUserByID(id int) (*User, error) {\nreturn us.userRepository.GetById(id)\n}\n```\nIn this example, the `UserService` has a single responsibility - to manage user-related operations. It does not have any knowledge of the underlying storage mechanism for the user data - this is delegated to the `UserRepository` interface.\n- ### Open/Closed Principle\n- Example:\n```go\ntype Shape interface {\nArea() float64\n}\n- type Rectangle struct {\nWidth float64\nHeight float64\n}\n- func (r *Rectangle) Area() float64 {\nreturn r.Width * r.Height\n}\n- type Circle struct {\nRadius float64\n}\n- func (c *Circle) Area() float64 {\nreturn math.Pi * c.Radius * c.Radius\n}\n```\n- In this example, we define a `Shape` interface that defines an `Area()` method. The `Rectangle` and `Circle` structs both implement this interface, and provide their own implementation of the `Area()` method. Now, if we want to add a new shape, we can simply create a new struct that implements the `Shape` interface without having to modify the existing code.\n- ### Liskov Substitution Principle\n- Example:\n```go\ntype Animal struct{}\n- func (a *Animal) Speak() string {\nreturn “Animal sound”\n}\n- type Dog struct {\nAnimal\n}\n- func (d *Dog) Speak() string {\nreturn “Woof!”\n}\n- type Cat struct {\nAnimal\n}\n- func (c *Cat) Speak() string {\nreturn “Meow!”\n}\n```\n- In this example, the `Dog` and `Cat` structs inherit from the `Animal` struct. However, they each provide their own implementation of the `Speak()` method. By adhering to the LSP, we should be able to use an instance of `Dog` or `Cat` wherever we would have used an instance of `Animal` without modifying the behavior of the program.\n- ### Interface Segregation Principle\n- Example:\n```\ntype Animal struct{}\n- func (a *Animal) Speak() string {\nreturn “Animal sound”\n}\n- type Dog struct {\nAnimal\n}\n- func (d *Dog) Speak() string {\nreturn “Woof!”\n}\n- type Cat struct {\nAnimal\n}\n- func (c *Cat) Speak() string {\nreturn “Meow!”\n}\n```\n- In this example, the `Dog` and `Cat` structs inherit from the `Animal` struct. However, they each provide their own implementation of the `Speak()` method. By adhering to the LSP, we should be able to use an instance of `Dog` or `Cat` wherever we would have used an instance of `Animal` without modifying the behavior of the program.\n- Interface Segregation Principle (ISP):\n- Example:\n```go\ntype UserRepository interface {\nCreate(user *User) error\nGetById(id int) (*User, error)\n}\n- type PasswordRepository interface {\nCreateHash(password string) (string, error)\nValidatePassword(hash, password string) error\n}\n```\nIn this example, we have two distinct interfaces - `UserRepository` and `PasswordRepository`. Each interface is specific to a particular responsibility - one for managing user-related operations, and one for managing password-related operations. This is preferable to having a single, monolithic interface that attempts to cover both responsibilities.\n- ### Dependency Inversion Principle\n- Example:\n```\ntype Animal struct{}\n- func (a *Animal) Speak() string {\nreturn “Animal sound”\n}\n- type Dog struct {\nAnimal\n}\n- func (d *Dog) Speak() string {\nreturn “Woof!”\n}\n- type Cat struct {\nAnimal\n}\n- func (c *Cat) Speak() string {\nreturn “Meow!”\n}\n```\n- In this example, the `Dog` and `Cat` structs inherit from the `Animal` struct. However, they each provide their own implementation of the `Speak()` method. By adhering to the LSP, we should be able to use an instance of `Dog` or `Cat` wherever we would have used an instance of `Animal` without modifying the behavior of the program.\n- ### Interface Segregation Principle (ISP):\n- Example:\n```go\ntype UserRepository interface {\nCreate(user *User) error\nGetById(id int) (*User, error)\n}\n- type PasswordRepository interface {\nCreateHash(password string) (string, error)\nValidatePassword(hash, password string) error\n}\n```\nIn this example, we have two distinct interfaces - `UserRepository` and `PasswordRepository`. Each interface is specific to a particular responsibility - one for managing user-related operations, and one for managing password-related operations. This is preferable to having a single, monolithic interface that attempts to cover both responsibilities.\n- ### Full Example\n- Here is an example of a Go program that applies the SOLID principles:\n```go\npackage main\nimport “fmt”\n// Single Responsibility Principle:\n// Each struct has only a single responsibility.\n// User struct represents a user in the system.\ntype User struct {\nID int\nFirstName string\nLastName string\n}\n- // UserService struct defines a service for managing users.\ntype UserService struct {\nusers []User\n}\n// AddUser adds a new user to the service.\nfunc (s *UserService) AddUser(u User) {\ns.users = append(s.users, u)\n}\n// GetUserByID returns the user with the given ID.\nfunc (s *UserService) GetUserByID(id int) User {\nfor _, u := range s.users {\nif u.ID == id {\nreturn u\n}\n}\nreturn User{}\n}\n// Open/Closed Principle:\n// The UserService is open for extension, but closed for modification.\n// We can add new functionality by implementing new interfaces,\n// rather than modifying the existing UserService.\n// UserRepository defines the interface for a user repository.\ntype UserRepository interface {\nSaveUser(u User) error\nFindUserByID(id int) (User, error)\n}\n- // UserRepositoryImpl is a concrete implementation of the UserRepository interface.\n// It uses the UserService to store and retrieve users.\ntype UserRepositoryImpl struct {\nuserService *UserService\n}\n// SaveUser saves a user to the repository.\nfunc (r *UserRepositoryImpl) SaveUser(u User) error {\nr.userService.AddUser(u)\nreturn nil\n}\n// FindUserByID finds a user with the given ID in the repository.\nfunc (r *UserRepositoryImpl) FindUserByID(id int) (User, error) {\nreturn r.userService.GetUserByID(id), nil\n}\n// Liskov Substitution Principle:\n// The UserRepositoryImpl should be substitutable for the UserRepository interface.\n// This means that we should be able to use either the interface or the concrete implementation\n// without knowing which one we are using.\n// UserController is a controller for managing users.\n// It uses a UserRepository to store and retrieve users.\ntype UserController struct {\nrepository UserRepository\n}\n- // NewUserController creates a new UserController.\nfunc NewUserController(r UserRepository) *UserController {\nreturn \u0026UserController{repository: r}\n}\n// CreateUser creates a new user.\nfunc (c *UserController) CreateUser(u User) error {\nreturn c.repository.SaveUser(u)\n}\n// GetUserByID gets the user with the given ID.\nfunc (c *UserController) GetUserByID(id int) (User, error) {\nreturn c.repository.FindUserByID(id)\n}\nfunc main() {\n// Dependency Inversion Principle:\n// The UserController depends on the UserRepository interface,\n// rather than on the concrete UserRepositoryImpl.\n// This allows us to use any implementation of the UserRepository interface with the UserController.\nuserService := \u0026UserService{}\nrepository := \u0026UserRepositoryImpl{userService: userService}\ncontroller := NewUserController(repository)\nuser := User{ID: 1, FirstName: “John”, LastName: “Doe”}\ncontroller.CreateUser(user)\nretrievedUser, _ := controller.GetUserByID(1)\nfmt.Println(retrievedUser)\n}\n```\n- In this example, the `User` struct represents a user in the system and has only the data and methods that are related to a user. The `UserService` struct defines a service for managing users, and follows the Single Responsibility Principle by having only a single responsibility (managing users).\n- The `UserRepository` interface and the `UserRepositoryImpl` struct demonstrate the Open/Closed Principle by defining an interface that can be implemented by different types, rather than modifying the existing `UserService`. The `UserRepositoryImpl` also satisfies the Liskov Substitution Principle by being substitutable for the `UserRepository` interface.\n- Finally, the `UserController` struct applies the Dependency Inversion Principle by depending on the `UserRepository` interface, rather than on a specific implementation of the interface. This allows us to use any implementation of the `UserRepository` interface with the `UserController`. For example, a memory implementation of `UserRepository` could be used in unit tests and a real database implementation of `UserRepository` could be used in integration tests using test containers.\n- To summarize, the SOLID principles are a set of design principles for object-oriented programming that can help to make software designs more understandable, flexible, and maintainable. In Go, these principles can be applied by using structs, interfaces, and other language features to create modular, decoupled code that is easy to understand and extend.\n- Personally, following these principles have helped me to maintain a well tested, 50k+ line solo project.\n- Hope this was a useful read!\n- ## Questions\n\u003e Does this still fulfill SOLID, if `UserService` is removed (by moving the `UserService` logic to `UserRepository`)?\n- In this specific example it wouldn’t explicitly violate any principles, but if you were using a real database you’d want to abstract the database queries away so that data access implementation details don’t leak into your business logic.\n- To illustrate using the example above, let’s remove the `UserService` logic and move it to `UserRepositoryImpl`:\n```go\nvar ErrUserNotFound = errors.New(“user was not found”)\n- // Open/Closed Principle:\n// The UserService is open for extension, but closed for modification.\n// We can add new functionality by implementing new interfaces,\n// rather than modifying the existing UserService.\n// UserRepository defines the interface for a user repository.\ntype UserRepository interface {\nSaveUser(u User) error\nFindUserByID(id int) (User, error)\n}\n- // UserRepositoryImpl is a concrete implementation of the UserRepository interface.\n// It uses an explicit users slice\ntype UserRepositoryImpl struct {\nusers []User\n}\n// SaveUser saves a user to the repository.\nfunc (r *UserRepositoryImpl) SaveUser(u User) error {\ns.users = append(s.users, u)\nreturn nil\n}\n// FindUserByID finds a user with the given ID in the repository.\nfunc (r *UserRepositoryImpl) FindUserByID(id int) (User, error) {\nfor _, u := range s.users {\nif u.ID == id {\nreturn u, nil\n}\n}\n- return User{}, ErrUserNotFound\n}\n```\n- This looks fine, functionality stays the same and we removed 17 lines of code, but let’s add a few things.\n- What if we want to check if a user exists before saving it? We can do so with the following:\n```go\n// SaveUser saves a user to the repository.\nfunc (r *UserRepositoryImpl) SaveUser(u User) error {\nfor _, user := range s.users {\nif u.ID == user.ID {\nreturn ErrUserWithIDExists\n}\n}\n- s.users = append(s.users, u)\nreturn nil\n}\n```\n- As our user base grows, maybe we want to add a unique `username` field to the `User`. We can add the field to the `User` struct and on save check if the username is unique and doesn’t contain any bad words.\n```go\nvar ErrUsernameExists = errors.New(“user with username already exists”)\n- type User struct {\nID int\nFirstName string\nLastName string\nUsername string\n}\n- // SaveUser saves a user to the repository.\nfunc (r *UserRepositoryImpl) SaveUser(u User) error {\nif badWords.Contains(u.Username) {\nreturn ErrUsernameInvalid\n}\n- for _, user := range s.users {\nif u.ID == user.ID {\nreturn ErrUserWithIDExists\n}\n- if u.Username == user.Username {\nreturn ErrUsernameExists\n}\n}\n- s.users = append(s.users, u)\n- return nil\n}\n```\n- Now if we wanted to rewrite SaveUser using an actual database:\n```go\n// SaveUser saves a user to the repository.\nfunc (r *UserRepositoryImpl) SaveUser(u User) error {\nif badWords.Contains(u.Username) {\nreturn ErrUsernameInvalid\n}\n- users := r.db.Query(“select * from users”).ScanStructs(User{})\nfor _, user := range users {\nif u.ID == user.ID {\nreturn ErrUserWithIDExists\n}\n- if u.Username == user.Username {\nreturn ErrUsernameExists\n}\n}\n- return r.db.Exec(“insert into users(id, first_name, last_name, username) values (?, ?, ?, ?)”, u.ID, u.FirstName, u.LastName, u.Username)\n}\n```\n- Still maintainable but it could look something like this which I personally find more readable:\n```go\nfunc (r *UserRepositoryImpl) SaveUser(u User) error {\nif badWords.Contains(u.Username) {\nreturn ErrUsernameInvalid\n}\n- users := r.repository.QueryAllUsers()\nfor _, user := range users {\nif u.ID == user.ID {\nreturn ErrUserWithIDExists\n}\n- if u.Username == user.Username {\nreturn ErrUsernameExists\n}\n}\n- return r.repository.SaveUser(u)\n}\n```\n- You could refactor even further:\n```go\nfunc (r *UserRepositoryImpl) SaveUser(u User) error {\nerr := r.repository.ValidateUser(u);\nif err != nil {\nreturn err\n}\n- return r.repository.SaveUser(u)\n}\n```\n- Now it’s even more clear what the code does: validate the input then save. By abstracting the implementation away from the intention, you can read more immediately know what SaveUser is supposed to do. And when you want to know how user validation or saving the user actually works, you can navigate to the definition at that point.\n",
  "wordCount" : "2084",
  "inLanguage": "en",
  "datePublished": "2024-01-26T00:00:00Z",
  "dateModified": "2024-01-26T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "breadchris"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://breadchris.com/blog/this-is-for-nolan/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "breadchris",
    "logo": {
      "@type": "ImageObject",
      "url": "https://breadchris.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://breadchris.com" accesskey="h" title="breadchris (Alt + H)">breadchris</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://breadchris.com/blog" title="blog">
                    <span>blog</span>
                </a>
            </li>
            <li>
                <a href="https://breadchris.com/books" title="books">
                    <span>books</span>
                </a>
            </li>
            <li>
                <a href="https://breadchris.com/resume" title="resume">
                    <span>resume</span>
                </a>
            </li>
            <li>
                <a href="https://breadchris.com/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://breadchris.com/talks" title="talks">
                    <span>talks</span>
                </a>
            </li>
            <li>
                <a href="https://breadchris.com/thinkies" title="thinkies">
                    <span>thinkies</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      This is for Nolan
    </h1>
    <div class="post-meta"><span title='2024-01-26 00:00:00 +0000 UTC'>January 26, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;breadchris

</div>
  </header> 
  <div class="post-content"><p>## SOLID principles</p>
<p>The set of five design principles for object-oriented programming that were first introduced by Robert C. Martin. These principles are intended to make software designs more understandable, flexible, and maintainable.</p>
<p>In Go, the SOLID principles can be applied as follows:</p>
<p>### Single Responsibility Principle (SRP)</p>
<p>Example:</p>
<p>```go</p>
<p>type UserService struct {</p>
<p>userRepository UserRepository</p>
<p>}</p>
<p>func (us *UserService) CreateUser(user *User) error {</p>
<p>return us.userRepository.Create(user)</p>
<p>}</p>
<p>func (us *UserService) GetUserByID(id int) (*User, error) {</p>
<p>return us.userRepository.GetById(id)</p>
<p>}</p>
<p>```</p>
<p>In this example, the `UserService` has a single responsibility - to manage user-related operations. It does not have any knowledge of the underlying storage mechanism for the user data - this is delegated to the `UserRepository` interface.</p>
<p>- ### Open/Closed Principle</p>
<p>- Example:</p>
<ul>
<li></li>
</ul>
<p>```go</p>
<p>type Shape interface {</p>
<p>Area() float64</p>
<p>}</p>
<p>- type Rectangle struct {</p>
<p>Width float64</p>
<p>Height float64</p>
<p>}</p>
<p>- func (r *Rectangle) Area() float64 {</p>
<p>return r.Width * r.Height</p>
<p>}</p>
<p>- type Circle struct {</p>
<p>Radius float64</p>
<p>}</p>
<p>- func (c *Circle) Area() float64 {</p>
<p>return math.Pi * c.Radius * c.Radius</p>
<p>}</p>
<p>```</p>
<p>- In this example, we define a `Shape` interface that defines an `Area()` method. The `Rectangle` and `Circle` structs both implement this interface, and provide their own implementation of the `Area()` method. Now, if we want to add a new shape, we can simply create a new struct that implements the `Shape` interface without having to modify the existing code.</p>
<p>- ### Liskov Substitution Principle</p>
<p>- Example:</p>
<ul>
<li></li>
</ul>
<p>```go</p>
<p>type Animal struct{}</p>
<p>- func (a *Animal) Speak() string {</p>
<p>return &ldquo;Animal sound&rdquo;</p>
<p>}</p>
<p>- type Dog struct {</p>
<p>Animal</p>
<p>}</p>
<p>- func (d *Dog) Speak() string {</p>
<p>return &ldquo;Woof!&rdquo;</p>
<p>}</p>
<p>- type Cat struct {</p>
<p>Animal</p>
<p>}</p>
<p>- func (c *Cat) Speak() string {</p>
<p>return &ldquo;Meow!&rdquo;</p>
<p>}</p>
<p>```</p>
<p>- In this example, the `Dog` and `Cat` structs inherit from the `Animal` struct. However, they each provide their own implementation of the `Speak()` method. By adhering to the LSP, we should be able to use an instance of `Dog` or `Cat` wherever we would have used an instance of `Animal` without modifying the behavior of the program.</p>
<p>- ### Interface Segregation Principle</p>
<p>- Example:</p>
<ul>
<li></li>
</ul>
<p>```</p>
<p>type Animal struct{}</p>
<p>- func (a *Animal) Speak() string {</p>
<p>return &ldquo;Animal sound&rdquo;</p>
<p>}</p>
<p>- type Dog struct {</p>
<p>Animal</p>
<p>}</p>
<p>- func (d *Dog) Speak() string {</p>
<p>return &ldquo;Woof!&rdquo;</p>
<p>}</p>
<p>- type Cat struct {</p>
<p>Animal</p>
<p>}</p>
<p>- func (c *Cat) Speak() string {</p>
<p>return &ldquo;Meow!&rdquo;</p>
<p>}</p>
<p>```</p>
<p>- In this example, the `Dog` and `Cat` structs inherit from the `Animal` struct. However, they each provide their own implementation of the `Speak()` method. By adhering to the LSP, we should be able to use an instance of `Dog` or `Cat` wherever we would have used an instance of `Animal` without modifying the behavior of the program.</p>
<p>- Interface Segregation Principle (ISP):</p>
<p>- Example:</p>
<ul>
<li></li>
</ul>
<p>```go</p>
<p>type UserRepository interface {</p>
<p>Create(user *User) error</p>
<p>GetById(id int) (*User, error)</p>
<p>}</p>
<p>- type PasswordRepository interface {</p>
<p>CreateHash(password string) (string, error)</p>
<p>ValidatePassword(hash, password string) error</p>
<p>}</p>
<p>```</p>
<p>In this example, we have two distinct interfaces - `UserRepository` and `PasswordRepository`. Each interface is specific to a particular responsibility - one for managing user-related operations, and one for managing password-related operations. This is preferable to having a single, monolithic interface that attempts to cover both responsibilities.</p>
<p>- ### Dependency Inversion Principle</p>
<p>- Example:</p>
<ul>
<li></li>
</ul>
<p>```</p>
<p>type Animal struct{}</p>
<p>- func (a *Animal) Speak() string {</p>
<p>return &ldquo;Animal sound&rdquo;</p>
<p>}</p>
<p>- type Dog struct {</p>
<p>Animal</p>
<p>}</p>
<p>- func (d *Dog) Speak() string {</p>
<p>return &ldquo;Woof!&rdquo;</p>
<p>}</p>
<p>- type Cat struct {</p>
<p>Animal</p>
<p>}</p>
<p>- func (c *Cat) Speak() string {</p>
<p>return &ldquo;Meow!&rdquo;</p>
<p>}</p>
<p>```</p>
<p>- In this example, the `Dog` and `Cat` structs inherit from the `Animal` struct. However, they each provide their own implementation of the `Speak()` method. By adhering to the LSP, we should be able to use an instance of `Dog` or `Cat` wherever we would have used an instance of `Animal` without modifying the behavior of the program.</p>
<p>- ### Interface Segregation Principle (ISP):</p>
<p>- Example:</p>
<ul>
<li></li>
</ul>
<p>```go</p>
<p>type UserRepository interface {</p>
<p>Create(user *User) error</p>
<p>GetById(id int) (*User, error)</p>
<p>}</p>
<p>- type PasswordRepository interface {</p>
<p>CreateHash(password string) (string, error)</p>
<p>ValidatePassword(hash, password string) error</p>
<p>}</p>
<p>```</p>
<p>In this example, we have two distinct interfaces - `UserRepository` and `PasswordRepository`. Each interface is specific to a particular responsibility - one for managing user-related operations, and one for managing password-related operations. This is preferable to having a single, monolithic interface that attempts to cover both responsibilities.</p>
<p>- ### Full Example</p>
<p>- Here is an example of a Go program that applies the SOLID principles:</p>
<ul>
<li></li>
</ul>
<p>```go</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>// Single Responsibility Principle:</p>
<p>// Each struct has only a single responsibility.</p>
<p>// User struct represents a user in the system.</p>
<p>type User struct {</p>
<p>ID int</p>
<p>FirstName string</p>
<p>LastName string</p>
<p>}</p>
<p>- // UserService struct defines a service for managing users.</p>
<p>type UserService struct {</p>
<p>users []User</p>
<p>}</p>
<p>// AddUser adds a new user to the service.</p>
<p>func (s *UserService) AddUser(u User) {</p>
<p>s.users = append(s.users, u)</p>
<p>}</p>
<p>// GetUserByID returns the user with the given ID.</p>
<p>func (s *UserService) GetUserByID(id int) User {</p>
<p>for _, u := range s.users {</p>
<p>if u.ID == id {</p>
<p>return u</p>
<p>}</p>
<p>}</p>
<p>return User{}</p>
<p>}</p>
<p>// Open/Closed Principle:</p>
<p>// The UserService is open for extension, but closed for modification.</p>
<p>// We can add new functionality by implementing new interfaces,</p>
<p>// rather than modifying the existing UserService.</p>
<p>// UserRepository defines the interface for a user repository.</p>
<p>type UserRepository interface {</p>
<p>SaveUser(u User) error</p>
<p>FindUserByID(id int) (User, error)</p>
<p>}</p>
<p>- // UserRepositoryImpl is a concrete implementation of the UserRepository interface.</p>
<p>// It uses the UserService to store and retrieve users.</p>
<p>type UserRepositoryImpl struct {</p>
<p>userService *UserService</p>
<p>}</p>
<p>// SaveUser saves a user to the repository.</p>
<p>func (r *UserRepositoryImpl) SaveUser(u User) error {</p>
<p>r.userService.AddUser(u)</p>
<p>return nil</p>
<p>}</p>
<p>// FindUserByID finds a user with the given ID in the repository.</p>
<p>func (r *UserRepositoryImpl) FindUserByID(id int) (User, error) {</p>
<p>return r.userService.GetUserByID(id), nil</p>
<p>}</p>
<p>// Liskov Substitution Principle:</p>
<p>// The UserRepositoryImpl should be substitutable for the UserRepository interface.</p>
<p>// This means that we should be able to use either the interface or the concrete implementation</p>
<p>// without knowing which one we are using.</p>
<p>// UserController is a controller for managing users.</p>
<p>// It uses a UserRepository to store and retrieve users.</p>
<p>type UserController struct {</p>
<p>repository UserRepository</p>
<p>}</p>
<p>- // NewUserController creates a new UserController.</p>
<p>func NewUserController(r UserRepository) *UserController {</p>
<p>return &amp;UserController{repository: r}</p>
<p>}</p>
<p>// CreateUser creates a new user.</p>
<p>func (c *UserController) CreateUser(u User) error {</p>
<p>return c.repository.SaveUser(u)</p>
<p>}</p>
<p>// GetUserByID gets the user with the given ID.</p>
<p>func (c *UserController) GetUserByID(id int) (User, error) {</p>
<p>return c.repository.FindUserByID(id)</p>
<p>}</p>
<p>func main() {</p>
<p>// Dependency Inversion Principle:</p>
<p>// The UserController depends on the UserRepository interface,</p>
<p>// rather than on the concrete UserRepositoryImpl.</p>
<p>// This allows us to use any implementation of the UserRepository interface with the UserController.</p>
<p>userService := &amp;UserService{}</p>
<p>repository := &amp;UserRepositoryImpl{userService: userService}</p>
<p>controller := NewUserController(repository)</p>
<p>user := User{ID: 1, FirstName: &ldquo;John&rdquo;, LastName: &ldquo;Doe&rdquo;}</p>
<p>controller.CreateUser(user)</p>
<p>retrievedUser, _ := controller.GetUserByID(1)</p>
<p>fmt.Println(retrievedUser)</p>
<p>}</p>
<p>```</p>
<p>- In this example, the `User` struct represents a user in the system and has only the data and methods that are related to a user. The `UserService` struct defines a service for managing users, and follows the Single Responsibility Principle by having only a single responsibility (managing users).</p>
<p>- The `UserRepository` interface and the `UserRepositoryImpl` struct demonstrate the Open/Closed Principle by defining an interface that can be implemented by different types, rather than modifying the existing `UserService`. The `UserRepositoryImpl` also satisfies the Liskov Substitution Principle by being substitutable for the `UserRepository` interface.</p>
<p>- Finally, the `UserController` struct applies the Dependency Inversion Principle by depending on the `UserRepository` interface, rather than on a specific implementation of the interface. This allows us to use any implementation of the `UserRepository` interface with the `UserController`. For example, a memory implementation of `UserRepository` could be used in unit tests and a real database implementation of `UserRepository` could be used in integration tests using test containers.</p>
<p>- To summarize, the SOLID principles are a set of design principles for object-oriented programming that can help to make software designs more understandable, flexible, and maintainable. In Go, these principles can be applied by using structs, interfaces, and other language features to create modular, decoupled code that is easy to understand and extend.</p>
<p>- Personally, following these principles have helped me to maintain a well tested, 50k+ line solo project.</p>
<p>- Hope this was a useful read!</p>
<p>- ## Questions</p>
<ul>
<li></li>
</ul>
<p>&gt; Does this still fulfill SOLID, if `UserService` is removed (by moving the `UserService` logic to `UserRepository`)?</p>
<p>- In this specific example it wouldn&rsquo;t explicitly violate any principles, but if you were using a real database you&rsquo;d want to abstract the database queries away so that data access implementation details don&rsquo;t leak into your business logic.</p>
<p>- To illustrate using the example above, let&rsquo;s remove the `UserService` logic and move it to `UserRepositoryImpl`:</p>
<ul>
<li></li>
</ul>
<p>```go</p>
<p>var ErrUserNotFound = errors.New(&ldquo;user was not found&rdquo;)</p>
<p>- // Open/Closed Principle:</p>
<p>// The UserService is open for extension, but closed for modification.</p>
<p>// We can add new functionality by implementing new interfaces,</p>
<p>// rather than modifying the existing UserService.</p>
<p>// UserRepository defines the interface for a user repository.</p>
<p>type UserRepository interface {</p>
<p>SaveUser(u User) error</p>
<p>FindUserByID(id int) (User, error)</p>
<p>}</p>
<p>- // UserRepositoryImpl is a concrete implementation of the UserRepository interface.</p>
<p>// It uses an explicit users slice</p>
<p>type UserRepositoryImpl struct {</p>
<p>users []User</p>
<p>}</p>
<p>// SaveUser saves a user to the repository.</p>
<p>func (r *UserRepositoryImpl) SaveUser(u User) error {</p>
<p>s.users = append(s.users, u)</p>
<p>return nil</p>
<p>}</p>
<p>// FindUserByID finds a user with the given ID in the repository.</p>
<p>func (r *UserRepositoryImpl) FindUserByID(id int) (User, error) {</p>
<p>for _, u := range s.users {</p>
<p>if u.ID == id {</p>
<p>return u, nil</p>
<p>}</p>
<p>}</p>
<p>- return User{}, ErrUserNotFound</p>
<p>}</p>
<p>```</p>
<p>- This looks fine, functionality stays the same and we removed 17 lines of code, but let&rsquo;s add a few things.</p>
<p>- What if we want to check if a user exists before saving it? We can do so with the following:</p>
<ul>
<li></li>
</ul>
<p>```go</p>
<p>// SaveUser saves a user to the repository.</p>
<p>func (r *UserRepositoryImpl) SaveUser(u User) error {</p>
<p>for _, user := range s.users {</p>
<p>if u.ID == user.ID {</p>
<p>return ErrUserWithIDExists</p>
<p>}</p>
<p>}</p>
<p>- s.users = append(s.users, u)</p>
<p>return nil</p>
<p>}</p>
<p>```</p>
<p>- As our user base grows, maybe we want to add a unique `username` field to the `User`. We can add the field to the `User` struct and on save check if the username is unique and doesn&rsquo;t contain any bad words.</p>
<ul>
<li></li>
</ul>
<p>```go</p>
<p>var ErrUsernameExists = errors.New(&ldquo;user with username already exists&rdquo;)</p>
<p>- type User struct {</p>
<p>ID int</p>
<p>FirstName string</p>
<p>LastName string</p>
<p>Username string</p>
<p>}</p>
<p>- // SaveUser saves a user to the repository.</p>
<p>func (r *UserRepositoryImpl) SaveUser(u User) error {</p>
<p>if badWords.Contains(u.Username) {</p>
<p>return ErrUsernameInvalid</p>
<p>}</p>
<p>- for _, user := range s.users {</p>
<p>if u.ID == user.ID {</p>
<p>return ErrUserWithIDExists</p>
<p>}</p>
<p>- if u.Username == user.Username {</p>
<p>return ErrUsernameExists</p>
<p>}</p>
<p>}</p>
<p>- s.users = append(s.users, u)</p>
<p>- return nil</p>
<p>}</p>
<p>```</p>
<p>- Now if we wanted to rewrite SaveUser using an actual database:</p>
<ul>
<li></li>
</ul>
<p>```go</p>
<p>// SaveUser saves a user to the repository.</p>
<p>func (r *UserRepositoryImpl) SaveUser(u User) error {</p>
<p>if badWords.Contains(u.Username) {</p>
<p>return ErrUsernameInvalid</p>
<p>}</p>
<p>- users := r.db.Query(&ldquo;select * from users&rdquo;).ScanStructs(User{})</p>
<p>for _, user := range users {</p>
<p>if u.ID == user.ID {</p>
<p>return ErrUserWithIDExists</p>
<p>}</p>
<p>- if u.Username == user.Username {</p>
<p>return ErrUsernameExists</p>
<p>}</p>
<p>}</p>
<p>- return r.db.Exec(&ldquo;insert into users(id, first_name, last_name, username) values (?, ?, ?, ?)&rdquo;, u.ID, u.FirstName, u.LastName, u.Username)</p>
<p>}</p>
<p>```</p>
<p>- Still maintainable but it could look something like this which I personally find more readable:</p>
<ul>
<li></li>
</ul>
<p>```go</p>
<p>func (r *UserRepositoryImpl) SaveUser(u User) error {</p>
<p>if badWords.Contains(u.Username) {</p>
<p>return ErrUsernameInvalid</p>
<p>}</p>
<p>- users := r.repository.QueryAllUsers()</p>
<p>for _, user := range users {</p>
<p>if u.ID == user.ID {</p>
<p>return ErrUserWithIDExists</p>
<p>}</p>
<p>- if u.Username == user.Username {</p>
<p>return ErrUsernameExists</p>
<p>}</p>
<p>}</p>
<p>- return r.repository.SaveUser(u)</p>
<p>}</p>
<p>```</p>
<p>- You could refactor even further:</p>
<ul>
<li></li>
</ul>
<p>```go</p>
<p>func (r *UserRepositoryImpl) SaveUser(u User) error {</p>
<p>err := r.repository.ValidateUser(u);</p>
<p>if err != nil {</p>
<p>return err</p>
<p>}</p>
<p>- return r.repository.SaveUser(u)</p>
<p>}</p>
<p>```</p>
<p>- Now it&rsquo;s even more clear what the code does: validate the input then save. By abstracting the implementation away from the intention, you can read more immediately know what SaveUser is supposed to do. And when you want to know how user validation or saving the user actually works, you can navigate to the definition at that point.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://breadchris.com/tags/blog/post/">blog/post</a></li>
    </ul>
    <form
            action="https://buttondown.email/api/emails/embed-subscribe/breadchris"
            method="post"
            target="popupwindow"
            onsubmit="window.open('https://buttondown.email/breadchris', 'popupwindow')"
            class="embeddable-buttondown-form"
    >
      <input class="input" type="email" name="email" id="bd-input" placeholder="join the email list" />
      <input class="btn" type="submit" id="bd-submit" value="Subscribe" />
    </form>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://breadchris.com">breadchris</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
