- #go/book Why do we write code
	- I wanted to write games professionally at one point. I think most passionate developers dream of this at one point until they get their dreams crushed by how hard it is to 1) make a game 2) sell the game. I wanted to build games so that I could build a world me and my friends could hang out in virtually. There are other ways we would do this; chats, emails, but none of them as appealing as a virtual world where you could seemingly make anything possible. So then as I grew up, I wanted to build things that made money. Store a user's data and show it to them in a meaningful way. I wanted to help make it easier for someone to go about their life. My app/site would be the world that me, my friends, randos could go to. I think we code to connect things together. Maybe all you need to do is stream bytes from one place to another, but often it is more complex than this. Transforming data so it can be shown to a user, sent to a database, emailed to someone. Systems are connected by protocols and data is molded into different shapes for different purposes. It is the programmer's job to see where data is and where it needs to go and conceptualize what needs to be built to make that happen. Oh, and our poor programmer, the state of their world is messy, decaying compromises are littered on the road to the "beautiful" solution. It can be difficult to write what needs to be written, a task too large to easily fit in our brain. We use types to hold past, present, and future selves accountable for what data it is exactly that we are dealing with. Our types are the contract we sign, one that can be amended at the risk of cascading changes. Our tasks with moving data from one place to another are quite repetitive as well, or at least appear to be. It is only human nature to see these patterns and avoid repeating themselves. What is to be done? Abstractions. We model entire domains of thought in our code as to avoid writing more code than we need to. But wait, dont these abstractions take time to think about and code to write themselves? I thought we just wanted to move data from place to another. Yes, well when you have a lot of people working on moving the data, you need them to have an "easy to use" API for it. Unless you absolutely know what data you need to move or are good at predicting the future, you don't know know how to model the abstraction for handling this data. This is no reason to give up modeling data, you still have what you have seen, be aware that you don't actually know a lot of things. What if the data never really needed to be moved in the first place?
	- What I have learned about programming is that you want to keep as much data around as you possibly can. Ideally the data is easy for you to reach for and grab when you need it. You can stream it from where it is to where you need it to go and modify it along the way.
	- Ok fuck this theoretical bullshit, I am going to rant. People have their own ideas on how code can be reusable, but unfortunately a lot of them are bullshit. Design patterns in OOP are bloated, and no one seemingly cares about their ecosystems for the most part. Have you looked at maven? It is decrepit. Distributing code as compiled assets is old news, yet the worlds most "modern" and widely used language is dynamically typed and distributes code as "compiled" assets? What is that? Unacceptable. I want my code and the code I depend on to be code. I share my code with others and they see exactly what I wrote. There is so much data to move in so many interesting ways, if we cant collaborate on moving it in meaningful ways because of the shortcomings of the language we use to model the problem, what chance in hell do we have? Writing code that other people can use is not just the code you, the programmer write. It is the build toolchain, package ecosystem, ethos of the community. The shelf life of the code you write is limited if its foundation is a pile of sticks that no one cares about. Go has taught me how less is more with code. If you stop thinking about syntax or other nerd traps in a "language" and focus on the bigger picture of we all just want to move data, you start to notice gaping holes in the way that we approach writing code. Why do you have so many different services in so many different languages? Well all of them are C-family languages, how about you spend a couple of weeks learning everything there is to know about Go, which is totally something you can do, 24 key words, 2 a day, come on just do it.
- #go/book learn go in 2 weeks
	- You have heard about Go, but you havent written anything in it. Learning Go means that you will change the way you think about software. You will master the syntax quickly and you might find it boring until you realize how powerful boring syntax can be. When every other Go developer, many of which from FAANG companies, writes Go in the same boring way, something obvious happens, everyone can read and use each other's code. It doesnt matter what operating system you are on, Go code just works. You aren't getting nerd sniped by the promise of the world and delivery of mysterious build errors with python, or remembering if you should be using sbt, maven, gradle today. It is just go, and thats all you need.