- #lunabrain/work
	- add haystack nodes to protoflow https://docs.haystack.deepset.ai/docs/query_classifier
		- haystack nodes, when wired, will modify a haystack workflow, and the final node will execute the haystack workflow
		- haystack nodes, when wired, will modify a haystack workflow, and the final node will execute the haystack workflow
	- ocr from screenshots https://github.com/deluan/lookup #golang/libraries
	- #lunabrain/search code searching https://github.com/hound-search/hound #golang/libraries
- #protoflow/ideas
	- running a workflow should send output from nodes to a chat
		- nodes should also have an indication that they have had data produced from them
	- workflow viewer
		- based on the node that is selected, return a sub graph that is just focused on that workflow and all the relevant nodes that are related to it
		- view all running workflows
			- be able to stop the workflow from running
	- #protoflow/quotes "protoflow tries to get you to code in a more "stateless" or "functional" way, but you need state to get things done in this century, so we give you tools to make managing state less painful. Protoflow is the staff engineer for your team"
- #protoflow/work
	- adding tabs to view workflows
- #js/libraries react jotai https://egghead.io/courses/manage-application-state-with-jotai-atoms-2c3a29f0 course #js/state
- #internet/tools hidden unicode character viewer https://www.soscisurvey.de/tools/view-chars.php
- #life/observations/programming
	- -
	- it is a bad language because there are too many things you can do in it, in different ways, and there is a massive amount of cooperate interest in its continued use
	- -
	- [3:43 PM]
	- you can't rely on js to continue to run in the way you expect, with zero code changes over time
	- -
	- [3:43 PM]
	- js is constantly rotting as it sits there
	- -
	- [3:44 PM]
	- there is a problem with rust that I foresee that also contributes to this problem, similar to js and python's problem; modules as they are imported in code, do not have a 1 to 1 mapping to the package manager they come from
	- -
	- [3:44 PM]
	- a package can be imported as "markdown", but the name in the package manager is "rust-markdown"
	- -
	- [3:44 PM]
	- compare this to Go and now Deno, they use absolute paths to where the content is located
	- -
	- [3:45 PM]
	- this is imperative in the ever growing library of modules and being able to unambiguously go to where the code you are importing exists is essential
	- -
	- [3:45 PM]
	- without this, your code will continually rot as it sits
	- -
	- [3:47 PM]
	- software engineering is the study of how to program given time as a constraint. there are reasonable tradeoffs that you have to make, using js to build a frontend, but if you want to maximize the bang for your buck in regards to the time that you spend writing code, always strive for using technology that will pass the "I haven't looked at this in a year" test
	- -
	- [3:47 PM]
	- 1) does it actually run
	- -
	- [3:47 PM]
	- 2) can you understand what you wrote (consistent language semantics)
	- -
	- [3:48 PM]
	- 3) can you reuse this code (are modules well defined)
	- -
	- [3:48 PM]
	- there is no language that comes close, in my experience, to embracing this concept than go
	- -
	- [3:49 PM]
	- i haven't spent much time in Rust, but from what I have see, it does not seem to have strong responses to the questions in this test. it is an impressive language and there is a big community, but im still skeptical