<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>A cool button goes viral | breadchris</title>
<meta name="keywords" content="thinkies, db">
<meta name="description" content="Imagine a developer named Alex, who creates a simple yet intriguing app with a button that shows the user a picture of a cat when they click on it.
Alex chooses PostgreSQL for the backend, confident in its robustness and familiarity. At first, the app functions flawlessly, gaining a steady user base. Each button press generates a record in the database: timestamp, user ID, execution time, and the URL of the cat picture.">
<meta name="author" content="breadchris">
<link rel="canonical" href="https://breadchris.com/thinkies/a-cool-button-goes-viral/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7d0dbc7bebc97247baddbf44f81f3261912c9f64c3f03500922375b9988f4ea9.css" integrity="sha256-fQ28e&#43;vJcke63b9E&#43;B8yYZEsn2TD8DUAkiN1uZiPTqk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://breadchris.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://breadchris.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://breadchris.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://breadchris.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://breadchris.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script defer data-domain="breadchris.com" src="https://plausible.io/js/script.js"></script><meta property="og:title" content="A cool button goes viral" />
<meta property="og:description" content="Imagine a developer named Alex, who creates a simple yet intriguing app with a button that shows the user a picture of a cat when they click on it.
Alex chooses PostgreSQL for the backend, confident in its robustness and familiarity. At first, the app functions flawlessly, gaining a steady user base. Each button press generates a record in the database: timestamp, user ID, execution time, and the URL of the cat picture." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://breadchris.com/thinkies/a-cool-button-goes-viral/" /><meta property="article:section" content="thinkies" />
<meta property="article:published_time" content="2024-04-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-04-16T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="A cool button goes viral"/>
<meta name="twitter:description" content="Imagine a developer named Alex, who creates a simple yet intriguing app with a button that shows the user a picture of a cat when they click on it.
Alex chooses PostgreSQL for the backend, confident in its robustness and familiarity. At first, the app functions flawlessly, gaining a steady user base. Each button press generates a record in the database: timestamp, user ID, execution time, and the URL of the cat picture."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Thinkies",
      "item": "https://breadchris.com/thinkies/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "A cool button goes viral",
      "item": "https://breadchris.com/thinkies/a-cool-button-goes-viral/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "A cool button goes viral",
  "name": "A cool button goes viral",
  "description": "Imagine a developer named Alex, who creates a simple yet intriguing app with a button that shows the user a picture of a cat when they click on it.\nAlex chooses PostgreSQL for the backend, confident in its robustness and familiarity. At first, the app functions flawlessly, gaining a steady user base. Each button press generates a record in the database: timestamp, user ID, execution time, and the URL of the cat picture.",
  "keywords": [
    "thinkies", "db"
  ],
  "articleBody": "Imagine a developer named Alex, who creates a simple yet intriguing app with a button that shows the user a picture of a cat when they click on it.\nAlex chooses PostgreSQL for the backend, confident in its robustness and familiarity. At first, the app functions flawlessly, gaining a steady user base. Each button press generates a record in the database: timestamp, user ID, execution time, and the URL of the cat picture. This is a classic case of an Online Transaction Processing system (OLTP), where the focus is on efficient transaction handling, row-based data storage, and quick, isolated data retrieval. Here is the SQL schema:\nCREATE TABLE button_press (\nid SERIAL PRIMARY KEY,\nuser_id INTEGER,\ntimestamp TIMESTAMP,\nexecution_time INTEGER,\ncat_url TEXT\n);\nUsers love Alex’s site. As the app grows in popularity, Alex starts noticing performance issues with the database. He starts experiencing slower query response times when he goes to query the button_press table and the database begins to struggle with the heavy load of constantly writing new records.\nTo address these issues, Alex decides to optimize the database for better performance by adding indexes to the table:\nCREATE INDEX user_id_index ON button_press(user_id);\nCREATE INDEX timestamp_index ON button_press(timestamp);\nCREATE INDEX cat_url_index ON button_press(cat_url);\nWith these indexes in place, the database can now quickly retrieve specific records based on user ID, timestamp, or outcome, improving query performance significantly. This optimization allows the app to handle a larger number of users and button presses without sacrificing speed or reliability. But the app continues to grow in popularity, and so does the database.\nFast forward a few months, Alex’s app goes viral. Suddenly, tens of thousands of users are feverishly clicking the button daily, each click dutifully logged as a new row in the database. The queries meant to aggregate metrics—like average execution time or daily click count—begin to crawl.\nIt becomes clear to Alex that the indexes aren’t going to work long term. Each query has to sift through every single row to calculate the needed statistics, loading vast amounts of data into memory.\nThis bottleneck is typical in OLTP systems like Postgres when faced with extensive read-heavy analytic queries. These systems are optimized for row-based operations which are ideal for transactional data integrity and speed but not for large-scale data analysis.\nRealizing the need for a more efficient way to handle analytics, Alex discovers the realm of Online Analytical Processing (OLAP). Unlike OLTP, OLAP systems are designed for rapid query performance on large datasets, making them ideal for analytics. Alex decides to implement ClickHouse, an OLAP database that stores data in columns rather than rows.\n8 A Comparison with Row-Oriented and Column-Oriented Methods | Download Scientific Diagram\nThis structural difference is crucial. In a columnar database, each column is stored independently, allowing for faster access during analytical queries that typically only involve a few attributes of the data. For instance, calculating the average execution time of the button press now requires accessing just the execution time column, significantly reducing the data loaded into memory.\nBy transitioning to ClickHouse for the app’s analytical needs, Alex immediately notices improvements. Queries that once took minutes now execute in seconds. Moreover, columnar storage proves to be more space-efficient for Alex’s requirements. Unlike row-based systems that store entire rows together, which often includes redundant or irrelevant data for certain queries, columnar storage focuses only on the relevant data, reducing storage costs.\nOperating in the data-driven landscape of digital cat photos, Alex’s agility and efficiency are key from him staying relevant and competitive. It can be tricky to onboard data into an OLAP database as they require bulk inserts to be performant. If Alex’s story resonnates with a problem you have with your data, Scratchdata will help you save time and money. You can schedule some time with Jay, the founder, who will personally help you, or you can start using the managed version of the app here.\n",
  "wordCount" : "653",
  "inLanguage": "en",
  "datePublished": "2024-04-16T00:00:00Z",
  "dateModified": "2024-04-16T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "breadchris"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://breadchris.com/thinkies/a-cool-button-goes-viral/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "breadchris",
    "logo": {
      "@type": "ImageObject",
      "url": "https://breadchris.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://breadchris.com" accesskey="h" title="breadchris (Alt + H)">breadchris</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://breadchris.com/blog" title="blog">
                    <span>blog</span>
                </a>
            </li>
            <li>
                <a href="https://breadchris.com/resume" title="resume">
                    <span>resume</span>
                </a>
            </li>
            <li>
                <a href="https://breadchris.com/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://breadchris.com/talks" title="talks">
                    <span>talks</span>
                </a>
            </li>
            <li>
                <a href="https://breadchris.com/thinkies" title="thinkies">
                    <span>thinkies</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      A cool button goes viral
    </h1>
    <div class="post-meta"><span title='2024-04-16 00:00:00 +0000 UTC'>April 16, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;breadchris

</div>
  </header> 
  <div class="post-content"><p>Imagine a developer named Alex, who creates a simple yet intriguing app with a button that shows the user a picture of a cat when they click on it.</p>
<p><img loading="lazy" src="https://files.oaiusercontent.com/file-JC1hazyu3MTVcxNhyvy9qTFF?se=2024-04-17T00%3A08%3A56Z&amp;sp=r&amp;sv=2021-08-06&amp;sr=b&amp;rscc=max-age%3D31536000%2C%20immutable&amp;rscd=attachment%3B%20filename%3D63536d33-77ab-4887-a086-c4031480a987.webp&amp;sig=c%2BDOfmPmSORSDAfJ5cT9KXVbT8B2MC6C7udbHHutVsc%3D" alt=""  />
</p>
<p>Alex chooses PostgreSQL for the backend, confident in its robustness and familiarity. At first, the app functions flawlessly, gaining a steady user base. Each button press generates a record in the database: timestamp, user ID, execution time, and the URL of the cat picture. This is a classic case of an Online Transaction Processing system (OLTP), where the focus is on efficient transaction handling, row-based data storage, and quick, isolated data retrieval. Here is the SQL schema:</p>
<p>CREATE TABLE button_press (</p>
<p>id SERIAL PRIMARY KEY,</p>
<p>user_id INTEGER,</p>
<p>timestamp TIMESTAMP,</p>
<p>execution_time INTEGER,</p>
<p>cat_url TEXT</p>
<p>);</p>
<p>Users love Alex&rsquo;s site. As the app grows in popularity, Alex starts noticing performance issues with the database. He starts experiencing slower query response times when he goes to query the <code>button_press</code> table and the database begins to struggle with the heavy load of constantly writing new records.</p>
<p>To address these issues, Alex decides to optimize the database for better performance by adding indexes to the table:</p>
<p>CREATE INDEX user_id_index ON button_press(user_id);</p>
<p>CREATE INDEX timestamp_index ON button_press(timestamp);</p>
<p>CREATE INDEX cat_url_index ON button_press(cat_url);</p>
<p>With these indexes in place, the database can now quickly retrieve specific records based on user ID, timestamp, or outcome, improving query performance significantly. This optimization allows the app to handle a larger number of users and button presses without sacrificing speed or reliability. But the app continues to grow in popularity, and so does the database.</p>
<p>Fast forward a few months, Alex&rsquo;s app goes viral. Suddenly, tens of thousands of users are feverishly clicking the button daily, each click dutifully logged as a new row in the database. The queries meant to aggregate metrics—like average execution time or daily click count—begin to crawl.</p>
<p>It becomes clear to Alex that the indexes aren&rsquo;t going to work long term. Each query has to sift through every single row to calculate the needed statistics, loading vast amounts of data into memory.</p>
<p><img loading="lazy" src="https://files.oaiusercontent.com/file-sClP61JyQBrgR4gKCvEIeAY0?se=2024-04-17T00%3A15%3A00Z&amp;sp=r&amp;sv=2021-08-06&amp;sr=b&amp;rscc=max-age%3D31536000%2C%20immutable&amp;rscd=attachment%3B%20filename%3Dec3f7b8d-612a-4cbd-a92b-1b5af7c06b60.webp&amp;sig=vbiEXOfPp8BuU5SBf/WmYYHNoVGgFu9ogOmSWziFQh4%3D" alt=""  />
</p>
<p>This bottleneck is typical in OLTP systems like Postgres when faced with extensive read-heavy analytic queries. These systems are optimized for row-based operations which are ideal for transactional data integrity and speed but not for large-scale data analysis.</p>
<p>Realizing the need for a more efficient way to handle analytics, Alex discovers the realm of Online Analytical Processing (OLAP). Unlike OLTP, OLAP systems are designed for rapid query performance on large datasets, making them ideal for analytics. Alex decides to implement ClickHouse, an OLAP database that stores data in columns rather than rows.</p>
<p><img loading="lazy" src="https://www.researchgate.net/publication/283644051/figure/fig6/AS:613545410588673@1523292033555/A-Comparison-with-Row-Oriented-and-Column-Oriented-Methods.png" alt=""  />
8 A Comparison with Row-Oriented and Column-Oriented Methods | Download Scientific Diagram</p>
<p>This structural difference is crucial. In a columnar database, each column is stored independently, allowing for faster access during analytical queries that typically only involve a few attributes of the data. For instance, calculating the average execution time of the button press now requires accessing just the execution time column, significantly reducing the data loaded into memory.</p>
<p>By transitioning to ClickHouse for the app&rsquo;s analytical needs, Alex immediately notices improvements. Queries that once took minutes now execute in seconds. Moreover, columnar storage proves to be more space-efficient for Alex’s requirements. Unlike row-based systems that store entire rows together, which often includes redundant or irrelevant data for certain queries, columnar storage focuses only on the relevant data, reducing storage costs.</p>
<p>Operating in the data-driven landscape of digital cat photos, Alex&rsquo;s agility and efficiency are key from him staying relevant and competitive. It can be tricky to onboard data into an OLAP database as they require <a href="https://clickhouse.com/docs/en/cloud/bestpractices/bulk-inserts">bulk inserts</a> to be performant. If Alex&rsquo;s story resonnates with a problem you have with your data, Scratchdata will help you save time and money. You can schedule some time with Jay, the founder, who will personally help you, or you can start using the managed version of the app <a href="https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?client_id=453278616391-s7lhg47d7v7ctrujui58fkfhj78qiktq.apps.googleusercontent.com&amp;redirect_uri=https%3A%2F%2Fapp.scratchdata.com%2Foauth%2Fgoogle%2Fcallback&amp;response_type=code&amp;scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email&amp;state=6ad704ef-6c47-4911-a31e-99f118be0805&amp;service=lso&amp;o2v=1&amp;theme=mn&amp;ddm=0&amp;flowName=GeneralOAuthFlow">here</a>.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://breadchris.com/tags/thinkies/">thinkies</a></li>
      <li><a href="https://breadchris.com/tags/db/">db</a></li>
    </ul>
    <form
            action="https://buttondown.email/api/emails/embed-subscribe/breadchris"
            method="post"
            target="popupwindow"
            onsubmit="window.open('https://buttondown.email/breadchris', 'popupwindow')"
            class="embeddable-buttondown-form"
    >
      <input class="input" type="email" name="email" id="bd-input" placeholder="join the email list" />
      <input class="btn" type="submit" id="bd-submit" value="Subscribe" />
    </form>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://breadchris.com">breadchris</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
