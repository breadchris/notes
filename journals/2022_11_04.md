- https://github.com/TalEliyahu/Threat_Model_Examples #appsec
- ****07:42** [[quick capture]]:  https://commoncog.com/no-learning-dont-close-loops
- 06:33** [[quick capture]]:  https://itnext.io/we-need-to-talk-about-the-bad-sides-of-go-568a1e5adbc6
- yeah i’m always interested in seeing what is confusing to people. i’ve had to deal with each one of these myself until i settled on a way of writing go that i guess avoids these problems mostly? i try to almost never use pointers, and when i do i double check that i can’t just pass a struct. i really wish that wasn’t in the language, but it’s the performance trade off in the language. i have found that following ubers style guide has really helped my code be a lot more consistent https://github.com/uber-go/guide/blob/master/style.md The language kind of beats you into thinking in a certain way which can be annoying for a lot of developers who just want to code, but i have seen enough of it to be able to write fairly consistent design patterns that, to me, don’t necessarily make different coding tasks immediately easier, but trading off upfront velocity with longer term use ability (ie. i can write a python script in seconds, but 99% of those i will never use again, it might take a minute for me to do the equivalent in go, but that script with “go build” becomes a standalone binary, “go test” verifies it works, you can generate docs for it. the reason i like go is the same you like bun, it just has answers to all the questions you would commonly ask of code. but untyped javascript rots this experience because you can no longer go to the actual line of code being used. before generics, go also had the problem with “interface{}” you would get stuck reading code and it would suck. having a fully connected, intuitive experience, in my opinion, is what makes developers better at coding and designing systems. you can look up and you can look down and see how people have written something and when you want to make your own you can communicate your code without any overhead.
- visualizing software architecture https://c4model.com
- clean architecture https://www.freecodecamp.org/news/a-quick-introduction-to-clean-architecture-990c014448d2/
- visual programming with go https://divan.dev/posts/visual_programming_go/
- #business-ideas connected coding
	- when you program, your ideas should be effortless. code should flow out of your fingertips and into production without a second thought. or should it? we want to think the solution to development is the most effortless process that you can have. But the truth is, we want coding to be intuitive. The difference being that instead of not needing to think, and constantly being in flow while programming, we really want to always know where to find a solution when we experience a problem. If i don’t know how to check if a number is even or odd in javascript, I know that someone has probably made an npm module to solve this problem. Using npm is intuitive. If i want to test my go application, I know i have to write a test function with a certain name so that “go test” will recognize it. Wait, how is that intuitive? I have to name a function something specific? What if i have a typo in the name or don’t have the name capitalized. My tests wouldn’t run and the solution wouldn’t be intuitive.
	- Intuition comes from somewhere. We get shown how something works and then we continue to use those patterns. Intuition is just pattern matching. I have been shown how to program in Go because i worked at Uber. My intuition for the language was learned and I try my best to replicate the patterns i’ve been exposed to. I don’t know how to do every possible thing imaginable, but I know, through intuition, where to find the things I don’t know. If I use go test to enforce code coverage, and my code coverage fails, i know some tests aren’t running. If tests aren’t running, I will go to where the tests are and go through my intuition checklist: “tests are only visible to go if they look like ‘Test*’, do my tests look like that”?
	- Maybe this is a deal breaker for you. I am not going to use go because of these silly function naming conventions. My language handles this much better, all I have to do is X. Well i’m curious, if for some reason your tests don’t run, what does your intuitive check list look like? Does a certain script need to exist somewhere with a specific name, otherwise the tests will fail silently?
	- The reason I like using go is because the intuitive checklist that I need to have is the same checklist I can use for every go project that exists, assuming they are using the builtin go tools. But why wouldn’t they? They are pretty simple to use and do the things they need to do reliably. It is not a perfect language by any means, but the short list of things I need to keep in my intuitive checklist make it pretty desirable for me when I think about building a complicated system.
	- How do you design a system? If i run “python serve.py” on a server, is that a system? Yeah, why not. It runs, it listens for requests, it responds with data. But what happens when the server crashes? The requests wont be responded to, the system is broken. So I fix this problem  by using an infinite loop that always keeps the program running, even if it crashes. But what about a lot of people accessing it? Wsgi. How about a lot of data? database. How do I interface with a lot of different types of data. ORM. Migrations? ORM and cross your fingers? A system gets more complicated as time goes on, and that is why developers get paid the big bucks! It’s a lot of work to manage a system, keep it running, and make it better.
	- This complexity of building and maintaining a system is only ever really experienced by the engineers working on it. The managers, product owners, CTO, CEO, they are only exposed to glimpses of this process, as they should, it’s not their job. Business requirements get sent down, from on high, through the ranks and get translated into context specific ideas and actions. “Our customer has pictures of puppies.” becomes “We need to store pictures of puppies.” and then “Make an API endpoint that stores a picture in an S3 bucket.”
	- Today, when we are keep track of these translated ideas, they are passed verbally in meetings, formalized in documents, posted on Jira, and hopefully, by the time the lines of code are written, the game of telephone worked and what was intended actually happened.
	- Bear with me on this one. What does a stereotypical meeting room look like? Table, chairs, TV, phone, and a whiteboard. The whiteboard is probably already littered with cryptic symbols, more lines than a mafia ring diagram, and more names of technology and services than you have friends. What is your gut instinct when you go to write your own ideas on that whiteboard? Do you clear away those ideas without a second thought? For me personally, I try to cram my diagram in as little space as I need possible, maybe I look for the oldest looking notes. Those are all fabulous ideas! Context captured in time like our ancestors did on the walls of their caves. There is no other language that quite helps us bridge our gap of communication like a diagram. So why don’t our development practices embrace this more?
	- The answer is that there are no tools that are intuitive and complete enough to do this. We might use lucidchart or draw.io to design our system’s architecture, but what happens when it changes? Do you go back through your old digrams to make sure they reflect the real world? And what about the systems those diagrams connect to? Do you connect your diagram to the larger context of your company? Can you go from your diagram on your proposal to the other system’s proposal? My diagrams sure don’t.
	- At Uber, when I wanted to learn how something worked, I would open up the service’s API contract the Thrift IDL or GRPC protobuf. The contents of that file reflected exactly how the service’s API contract existed in production and the reference I needed to develop locally. The types for calling the service could also be generated automatically. The experience was nothing short of intuitive, but I was still solving a problem.
	- At every level of communication, the context from all other levels should be visible. Why do we lose it? It’s hard to organize. People want to communicate in their own ways. Maybe they have made a living off of managing Jira.
- #business-ideas how to have connected context development
	- intuitive design
	- focus on types
		- blocks connect to each other through typed API contracts
		- block egress can be superset of types accepted by connected block
	- bring your own development environment
		- dev
	- debugging
- chef wangang
- https://m.youtube.com/playlist?list=PLnbzopdwFrnZc-UgGYETAQair7VzS7_Z8
- get in contact with
	- omar betterment
	- tyler
	- brad
	- eric https://includesecurity.com
- #lunasec people feel like they have already bought a tool like this recently, why would they use another one?
- I don't think it's a good idea to not 100% know what your company specializes in and it's not a good idea to rely on having talent in your company. What makes a good business is being able to 100% know and specialize your product, which needs to be something that customers want and KNOW they want and don't need instructions on how to use. In addition, you will want to standardize "your secret Krabby Patty formula" so much, that  any idiot like Spongebob can produce your product.
- #lunasec dependa-bot doesn’t work if you don’t have a package lock
	- generate a package lock and PR it to the repo
- what dependencies do electron or react native apps use?