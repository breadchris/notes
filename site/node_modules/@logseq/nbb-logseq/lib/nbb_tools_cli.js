import { $APP, shadow$provide, $jscomp } from "./nbb_core.js";
import "./nbb_goog_string.js";
const shadow_esm_import = function(x) { return import(x) };
var ITa=function(a,b,c){c=$APP.zh.g($APP.kp,c);c=$APP.bh(c);c=$APP.D.g(c,I8);var d=$APP.Xh,e=$APP.Xh,f=$APP.u(b);$APP.v(f);$APP.y(f);for(f=b;;){b=d;d=e;f=$APP.u(f);e=$APP.v(f);f=$APP.y(f);var g=e,m=f;if($APP.l(g)){var r=$APP.Wj,n=g;if($APP.l(function(){var x=/^--$/,z=n;return r.g?r.g(x,z):r.call(null,x,z)}()))e=b,f=$APP.Ji.g(d,m),b=$APP.Xh,d=e,e=f,f=b;else if($APP.l(function(){var x=/^--\S+=/,z=n;return r.g?r.g(x,z):r.call(null,x,z)}()))e=$APP.vg.g(b,$APP.Ji.g(new $APP.J(null,1,5,$APP.K,[J8],null),
$APP.cm.j(g,/=/,2))),f=d,b=m,d=e,e=f,f=b;else if($APP.l(function(){var x=/^--/,z=n;return r.g?r.g(x,z):r.call(null,x,z)}())){e=$APP.cf(a,g)?new $APP.J(null,2,5,$APP.K,[$APP.v(m),$APP.Rd(m)],null):new $APP.J(null,2,5,$APP.K,[null,m],null);f=$APP.B.j(e,0,null);e=$APP.B.j(e,1,null);b=$APP.vg.g(b,$APP.Ji.g(new $APP.J(null,2,5,$APP.K,[J8,g],null),$APP.l(f)?new $APP.J(null,1,5,$APP.K,[f],null):$APP.Xh));f=d;var w=e;d=b;e=f;f=w}else $APP.l(function(){var x=/^-./,z=n;return r.g?r.g(x,z):r.call(null,x,z)}())?
(e=function(){var x=$APP.Xh,z=$APP.Rd(g),F=$APP.u(z);$APP.v(F);$APP.y(F);for(F=z;;){z=x;x=$APP.u(F);F=$APP.v(x);x=$APP.y(x);F=["-",$APP.p.h(F)].join("");if($APP.cf(a,F))return $APP.u(x)?new $APP.J(null,2,5,$APP.K,[$APP.vg.g(z,new $APP.J(null,3,5,$APP.K,[K8,F,$APP.Ep.h(x)],null)),m],null):new $APP.J(null,2,5,$APP.K,[$APP.vg.g(z,new $APP.J(null,3,5,$APP.K,[K8,F,$APP.v(m)],null)),$APP.Rd(m)],null);if($APP.u(x))z=$APP.vg.g(z,new $APP.J(null,2,5,$APP.K,[K8,F],null)),F=x,x=z;else return new $APP.J(null,
2,5,$APP.K,[$APP.vg.g(z,new $APP.J(null,2,5,$APP.K,[K8,F],null)),m],null)}}(),f=$APP.B.j(e,0,null),e=$APP.B.j(e,1,null),b=$APP.Ji.g(b,f),f=d,w=e,d=b,e=f,f=w):$APP.l(c)?(e=b,f=$APP.Ji.g(d,$APP.Bg(g,m)),b=$APP.Xh,d=e,e=f,f=b):(e=b,f=$APP.vg.g(d,g),b=m,d=e,e=f,f=b)}else return new $APP.J(null,2,5,$APP.K,[b,d],null)}},JTa=function(a){return $APP.Ep.h($APP.ek.g(function(b){return["  %",0===b?null:["-",$APP.p.h(b)].join(""),"s"].join("")},a))},LTa=function(a){if($APP.l(!0)){var b=$APP.uj($APP.zh.j($APP.Im,
a,KTa));if($APP.u(b)){b=["Warning: The following options to parse-opts are unrecognized: ",$APP.Ep.g(", ",b)].join("");var c=$APP.mb;$APP.mb=$APP.nb;try{$APP.Gw.l($APP.C([b]))}finally{$APP.mb=c}}}return $APP.zj(a,KTa)},MTa=function(a){var b=$APP.Pj.g(function(r){return"string"===typeof r||null==r},a);a=$APP.zh.g($APP.kp,$APP.Nh.g($APP.me(b),a));var c=$APP.B.j(b,0,null),d=$APP.B.j(b,1,null);b=$APP.B.j(b,2,null);d=$APP.l(d)?d:J8.h(a);var e=$APP.l(d)?$APP.Rd($APP.Uj(/^(--[^ =]+)(?:[ =](.*))?/,d)):null;
d=$APP.B.j(e,0,null);e=$APP.B.j(e,1,null);var f=$APP.l(d)?$APP.fk.h($APP.B.g($APP.Uj(/^--(\[no-\])?(.*)/,d),2)):null,g=$APP.Xn.h(a),m=$APP.u(g)?$APP.zh.j($APP.ek,$APP.iw,$APP.zq.G(2,2,$APP.yq.h(null),g)):null;g=$APP.B.j(m,0,null);m=$APP.B.j(m,1,null);return $APP.Hm.l($APP.C([new $APP.k(null,7,[$APP.Nq,f,K8,c,J8,d,$APP.JG,e,$APP.rI,b,L8,g,M8,m],null),LTa($APP.Im.g(a,$APP.Xn))]))},NTa=function(a,b){return $APP.cf(a,b)?$APP.Fm.j(a,new $APP.J(null,1,5,$APP.K,[b],null),function(c){return null==c?null:
$APP.He(c)?c:new $APP.J(null,1,5,$APP.K,[c],null)}):a},OTa=function(a){return $APP.ek.g(function(b){return NTa(NTa($APP.Me(b)?LTa(b):MTa(b),L8),M8)},a)},N8=function(a,b){return $APP.nf.j(function(c,d){return $APP.cf(d,b)?$APP.yj.j(c,$APP.Nq.h(d),b.h?b.h(d):b.call(null,d)):c},$APP.ah,a)},PTa=function(a){return $APP.nf.j(function(b,c){return $APP.l(O8.h(c))?$APP.yj.j(b,$APP.Nq.h(c),O8.h(c)):b},$APP.ah,a)},P8=function(a,b,c){return $APP.v($APP.Vh.g(function(d){d=$APP.D.g(d,b);if($APP.l(d)){var e=$APP.re($APP.Uj(/^--\[no-\](.*)/,
d));d=$APP.l(e)?$APP.Dj([["--",$APP.p.h(e)].join(""),["--no-",$APP.p.h(e)].join("")]):$APP.Dj([d]);return $APP.cf(d,c)}return null},a))},Q8=function(a){return $APP.yk.l($APP.C([$APP.Ep.g(" ",a)]))},QTa=function(a,b){return["Missing required argument for ",Q8($APP.C([a,b]))].join("")},RTa=function(a,b,c,d){var e=$APP.bh(b);b=$APP.D.g(e,L8);e=$APP.D.g(e,M8);a:{var f=$APP.u(b);$APP.v(f);$APP.y(f);f=$APP.u(e);$APP.v(f);$APP.y(f);for(f=e;;){e=$APP.u(b);b=$APP.v(e);e=$APP.y(e);var g=$APP.u(f);f=$APP.v(g);
g=$APP.y(g);if($APP.l(b)){try{var m=b.h?b.h(a):b.call(null,a)}catch(r){m=null}if($APP.l(m))f=g,b=e;else{m=$APP.K;b=a;e=f;c=["Failed to validate ",Q8($APP.C([c,d])),$APP.l(e)?[": ",$APP.p.h("string"===typeof e?e:e.h?e.h(b):e.call(null,b))].join(""):""].join("");c=new $APP.J(null,2,5,m,[R8,c],null);break a}}else{c=null;break a}}}return $APP.l(c)?c:new $APP.J(null,2,5,$APP.K,[a,null],null)},STa=function(a,b,c){var d=$APP.bh(a);d=$APP.D.g(d,$APP.JG);if($APP.l($APP.l(d)?null==c:d))return new $APP.J(null,
2,5,$APP.K,[R8,QTa(b,d)],null);$APP.l(d)?d=c:(d=J8.h(a),d=$APP.l(d)?$APP.Uj(/^--\[no-\]/,J8.h(a)):d,d=$APP.l(d)?$APP.Uj(/^--no-/,b):d,d=$APP.vb(d));var e=$APP.bh(a);e=$APP.D.g(e,$APP.Ru);if($APP.l(e))try{var f=new $APP.J(null,2,5,$APP.K,[e.h?e.h(d):e.call(null,d),null],null)}catch(g){f=$APP.K,d=$APP.p.h(g),d=["Error while parsing option ",Q8($APP.C([b,c])),": ",$APP.p.h(d)].join(""),f=new $APP.J(null,2,5,f,[null,d],null)}else f=new $APP.J(null,2,5,$APP.K,[d,null],null);d=f;f=$APP.B.j(d,0,null);d=
$APP.B.j(d,1,null);return $APP.l(d)?new $APP.J(null,2,5,$APP.K,[R8,d],null):$APP.l(S8.h(a))?new $APP.J(null,2,5,$APP.K,[f,null],null):RTa(f,a,b,c)},WTa=function(a,b,c){c=$APP.zh.g($APP.kp,c);c=$APP.bh(c);var d=$APP.D.g(c,T8),e=$APP.D.g(c,U8);c=N8(a,$APP.Gn);var f=N8(a,V8),g=PTa(a);return function(m){var r=$APP.B.j(m,0,null),n=$APP.B.j(m,1,null);m=$APP.B.j(m,2,null);return $APP.l(d)?new $APP.J(null,2,5,$APP.K,[$APP.zj(r,n),m],null):new $APP.J(null,2,5,$APP.K,[r,m],null)}(function(m){return $APP.nf.j(function(r,
n){var w=$APP.B.j(r,0,null),x=$APP.B.j(r,1,null);r=$APP.B.j(r,2,null);var z=$APP.B.j(n,0,null),F=$APP.B.j(n,1,null);if($APP.cf($APP.Fj(x),z))w=new $APP.J(null,3,5,$APP.K,[w,x,r],null);else{n=$APP.K;var M=$APP.yj.j,T=$APP.v(m);F=F.h?F.h(T):F.call(null,T);w=new $APP.J(null,3,5,n,[M.call($APP.yj,w,z,F),x,r],null)}return w},m,f)}(function(m){return $APP.nf.j(function(r,n){var w=$APP.B.j(r,0,null),x=$APP.B.j(r,1,null);r=$APP.B.j(r,2,null);var z=$APP.B.j(n,0,null);n=$APP.B.j(n,1,null);return $APP.cf(w,
z)?new $APP.J(null,3,5,$APP.K,[w,x,r],null):new $APP.J(null,3,5,$APP.K,[w,x,$APP.vg.g(r,n)],null)},m,g)}($APP.nf.j(function(m,r){var n=$APP.B.j(m,0,null),w=$APP.B.j(m,1,null);m=$APP.B.j(m,2,null);var x=$APP.B.j(r,0,null),z=$APP.B.j(r,1,null),F=$APP.B.j(r,2,null),M=P8(a,x,z);if($APP.l(M)){r=STa(M,z,F);var T=$APP.B.j(r,0,null);r=$APP.B.j(r,1,null);var X=$APP.Nq.h(M);if($APP.A.g(T,R8))return new $APP.J(null,3,5,$APP.K,[n,w,$APP.vg.g(m,r)],null);if($APP.l(function(){if($APP.l(e)){var aa=P8(a,K8,F);return $APP.l(aa)?
aa:P8(a,J8,F)}return e}()))return new $APP.J(null,3,5,$APP.K,[n,w,$APP.vg.g(m,QTa(z,$APP.JG.h(M)))],null);r=function(){var aa=TTa.h(M);if($APP.l(aa))return $APP.l(UTa.h(M))?$APP.Tn.G(n,X,aa,T):$APP.Tn.j(n,X,aa);aa=VTa.g(M,$APP.yj);return aa.j?aa.j(n,X,T):aa.call(null,n,X,T)}();return $APP.l(S8.h(M))?(x=RTa($APP.D.g(r,X),M,z,F),z=$APP.B.j(x,0,null),x=$APP.B.j(x,1,null),$APP.A.g(z,R8)?new $APP.J(null,3,5,$APP.K,[n,w,$APP.vg.g(m,x)],null):new $APP.J(null,3,5,$APP.K,[r,$APP.vg.g(w,X),m],null)):new $APP.J(null,
3,5,$APP.K,[r,$APP.vg.g(w,X),m],null)}return new $APP.J(null,3,5,$APP.K,[n,w,$APP.vg.g(m,["Unknown option: ",$APP.yk.l($APP.C([z]))].join(""))],null)},new $APP.J(null,3,5,$APP.K,[c,$APP.Xh,$APP.Xh],null),b))))},W8=function(a,b){var c=$APP.bh(b),d=$APP.D.g(c,K8),e=$APP.D.g(c,J8),f=$APP.D.g(c,$APP.JG),g=$APP.D.g(c,$APP.rI),m=$APP.D.g(c,$APP.Gn),r=$APP.D.g(c,$APP.$I),n=$APP.D.g(c,V8);c=$APP.l($APP.l(d)?e:d)?[$APP.p.h(d),", ",$APP.p.h(e)].join(""):$APP.l(e)?["    ",$APP.p.h(e)].join(""):$APP.l(d)?d:null;
c=new $APP.J(null,2,5,$APP.K,[$APP.l(f)?[$APP.p.h(c)," ",$APP.p.h(f)].join(""):c,function(){if($APP.l(r))return r;var w=$APP.cf(b,$APP.Gn)?null!=m?$APP.p.h(m):"nil":null;if($APP.l(w))return w;w=$APP.l(n)?"\x3ccomputed\x3e":null;return $APP.l(w)?w:""}()],null);f=$APP.B.j(c,0,null);c=$APP.B.j(c,1,null);return $APP.l(a)?new $APP.J(null,3,5,$APP.K,[f,c,$APP.l(g)?g:""],null):new $APP.J(null,2,5,$APP.K,[f,$APP.l(g)?g:""],null)},Y8=function(a,b){var c=JTa(a);return $APP.ek.g(function(d){return $APP.zh.j(X8,
c,d).replace(/[\s\xa0]+$/,"")},b)},XTa=function(a){return $APP.nf.j(function(b,c){var d=$APP.bh(c);c=$APP.D.g(d,$APP.JG);var e=$APP.D.g(d,K8);d=$APP.D.g(d,J8);return $APP.l(c)?$APP.Ji.g(b,$APP.ps.g($APP.qb,new $APP.J(null,2,5,$APP.K,[e,d],null))):b},$APP.Cj,a)},Z8=function(a){if($APP.u(a)){var b=$APP.wh(function(c){return $APP.cf(c,$APP.Gn)||$APP.cf(c,V8)},a);a=$APP.ek.g($APP.Jm.g(W8,b),a);b=$APP.zh.j($APP.ek,function(){function c(e){var f=null;if(0<arguments.length){f=0;for(var g=Array(arguments.length-
0);f<g.length;)g[f]=arguments[f+0],++f;f=new $APP.Nd(g,0,null)}return d.call(this,f)}function d(e){return $APP.zh.g($APP.ko,$APP.ek.g($APP.me,e))}c.B=0;c.F=function(e){e=$APP.u(e);return d(e)};c.l=d;return c}(),a);a=Y8(b,a);return $APP.Ep.g("\n",a)}return""},$8=function(a){a=OTa(a);var b=N8(a,$APP.Gn);return $APP.nf.j(function(c,d){var e=$APP.B.j(d,0,null);d=$APP.B.j(d,1,null);return $APP.cf(c,e)?c:$APP.Fm.j(c,new $APP.J(null,1,5,$APP.K,[e],null),d.h?d.h(b):d.call(null,b))},b,N8(a,V8))},I8=new $APP.G(null,
"in-order","in-order",-1605651796),YTa=new $APP.t(null,"get-default-options","get-default-options",-1272395736,null),ZTa=new $APP.t("clojure.tools.cli","format-lines","clojure.tools.cli/format-lines",1692977358,null),a9=new $APP.t(null,"option-specs","option-specs",258957352,null),M8=new $APP.G(null,"validate-msg","validate-msg",-1415932287),UTa=new $APP.G(null,"multi","multi",-190293005),$Ta=new $APP.t("clojure.tools.cli","summarize","clojure.tools.cli/summarize",1236928737,null),aUa=new $APP.G(null,
"options","options",99638489),R8=new $APP.G("clojure.tools.cli","error","clojure.tools.cli/error",1727067675),K8=new $APP.G(null,"short-opt","short-opt",-384995699),J8=new $APP.G(null,"long-opt","long-opt",-386094553),O8=new $APP.G(null,"missing","missing",362507769),bUa=new $APP.t(null,"summarize","summarize",-1678257946,null),cUa=new $APP.G(null,"summary-fn","summary-fn",-2130107959),dUa=new $APP.t(null,"make-summary-part","make-summary-part",201489880,null),eUa=new $APP.t("clojure.tools.cli","make-summary-part",
"clojure.tools.cli/make-summary-part",2063480285,null),TTa=new $APP.G(null,"update-fn","update-fn",711087313),V8=new $APP.G(null,"default-fn","default-fn",-473729550),fUa=new $APP.t("clojure.tools.cli","parse-opts","clojure.tools.cli/parse-opts",-152892056,null),L8=new $APP.G(null,"validate-fn","validate-fn",1430169944),gUa=new $APP.G(null,"arguments","arguments",-1182834456),hUa=new $APP.t(null,"format-lines","format-lines",-1289973557,null),iUa=new $APP.t(null,"lens","lens",-984575916,null),jUa=
new $APP.t(null,"show-defaults?","show-defaults?",-1370106808,null),U8=new $APP.G(null,"strict","strict",-665564191),T8=new $APP.G(null,"no-defaults","no-defaults",-1025033878),kUa=new $APP.t("clojure.tools.cli","get-default-options","clojure.tools.cli/get-default-options",-489377747,null),VTa=new $APP.G(null,"assoc-fn","assoc-fn",418597603),S8=new $APP.G(null,"post-validation","post-validation",-1787936392),lUa=new $APP.t(null,"parts","parts",-1805428078,null);var X8=function X8(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return X8.l(arguments[0],1<c.length?new $APP.Nd(c.slice(1),0,null):null)};X8.l=function(a,b){return $APP.zh.j($APP.$U,a,b)};X8.B=1;X8.F=function(a){var b=$APP.v(a);a=$APP.y(a);return this.l(b,a)};
var KTa=new $APP.J(null,16,5,$APP.K,[$APP.Nq,K8,J8,$APP.JG,$APP.rI,$APP.Gn,$APP.$I,V8,$APP.Ru,VTa,TTa,UTa,S8,L8,M8,O8],null),b9=function b9(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return b9.l(arguments[0],arguments[1],2<c.length?new $APP.Nd(c.slice(2),0,null):null)};
b9.l=function(a,b,c){c=$APP.zh.g($APP.kp,c);c=$APP.bh(c);var d=$APP.D.g(c,I8),e=$APP.D.g(c,T8),f=$APP.D.g(c,U8);c=$APP.D.g(c,cUa);b=OTa(b);var g=XTa(b);a=ITa(g,a,$APP.C([I8,d]));d=$APP.B.j(a,0,null);a=$APP.B.j(a,1,null);f=WTa(b,d,$APP.C([T8,e,U8,f]));e=$APP.B.j(f,0,null);f=$APP.B.j(f,1,null);c=$APP.l(c)?c:Z8;c=c.h?c.h(b):c.call(null,b);return new $APP.k(null,4,[aUa,e,gUa,a,$APP.MG,c,$APP.aV,$APP.u(f)?f:null],null)};b9.B=2;
b9.F=function(a){var b=$APP.v(a),c=$APP.y(a);a=$APP.v(c);c=$APP.y(c);return this.l(b,a,c)};var c9=$APP.mu($APP.xI),mUa=new $APP.k(null,5,[hUa,function(){var a=new $APP.Ld(function(){return Y8},ZTa,$APP.kj([$APP.KA,$APP.U,$APP.R,$APP.Pm,$APP.Jx,$APP.In,$APP.Qm,$APP.qM,$APP.Y,$APP.Z,$APP.AD],["0.3.0",$APP.xI,hUa,"clojure/tools/cli.cljc",37,1,519,519,$APP.N(new $APP.J(null,2,5,$APP.K,[iUa,lUa],null)),"Format a sequence of summary parts into columns. lens is a sequence of\n  lengths to use for parts. There are two sequences of lengths if we are\n  not displaying defaults. There are three sequences of lengths if we\n  are showing defaults.",
$APP.l(Y8)?Y8.J:null])),b=$APP.q(a);a=$APP.De(a);var c=$APP.l(null)?null:$APP.R.h(a),d=new $APP.k(null,4,[$APP.U,c9,$APP.R,c,$APP.Y,$APP.Y.h(a),$APP.Z,$APP.Z.h(a)],null);return $APP.l($APP.ar.h(a))?$APP.iu(c,b,d):$APP.l($APP.rq.h(a))?$APP.ju(c,b,d):$APP.hu(c,b,d)}(),bUa,function(){var a=new $APP.Ld(function(){return Z8},$Ta,$APP.kj([$APP.KA,$APP.U,$APP.R,$APP.Pm,$APP.Jx,$APP.In,$APP.Qm,$APP.qM,$APP.Y,$APP.Z,$APP.AD],["0.3.0",$APP.xI,bUa,"clojure/tools/cli.cljc",34,1,536,536,$APP.N(new $APP.J(null,
1,5,$APP.K,[$APP.xka],null)),"Reduce options specs into a options summary for printing at a terminal.\n  Note that the specs argument should be the compiled version. That effectively\n  means that you shouldn't call summarize directly. When you call parse-opts\n  you get back a :summary key which is the result of calling summarize (or\n  your user-supplied :summary-fn option) on the compiled option specs.",$APP.l(Z8)?Z8.J:null])),b=$APP.q(a);a=$APP.De(a);var c=$APP.l(null)?null:$APP.R.h(a),d=new $APP.k(null,
4,[$APP.U,c9,$APP.R,c,$APP.Y,$APP.Y.h(a),$APP.Z,$APP.Z.h(a)],null);return $APP.l($APP.ar.h(a))?$APP.iu(c,b,d):$APP.l($APP.rq.h(a))?$APP.ju(c,b,d):$APP.hu(c,b,d)}(),YTa,function(){var a=new $APP.Ld(function(){return $8},kUa,$APP.kj([$APP.KA,$APP.U,$APP.R,$APP.Pm,$APP.Jx,$APP.In,$APP.Qm,$APP.qM,$APP.Y,$APP.Z,$APP.AD],["0.3.2",$APP.xI,YTa,"clojure/tools/cli.cljc",44,1,552,552,$APP.N(new $APP.J(null,1,5,$APP.K,[a9],null)),"Extract the map of default options from a sequence of option vectors.\n\n  As of 0.4.1, this also applies any :default-fn present.",
$APP.l($8)?$8.J:null])),b=$APP.q(a);a=$APP.De(a);var c=$APP.l(null)?null:$APP.R.h(a),d=new $APP.k(null,4,[$APP.U,c9,$APP.R,c,$APP.Y,$APP.Y.h(a),$APP.Z,$APP.Z.h(a)],null);return $APP.l($APP.ar.h(a))?$APP.iu(c,b,d):$APP.l($APP.rq.h(a))?$APP.ju(c,b,d):$APP.hu(c,b,d)}(),$APP.SJ,function(){var a=new $APP.Ld(function(){return b9},fUa,$APP.kj([$APP.KA,$APP.U,$APP.R,$APP.Pm,$APP.Jx,$APP.NI,$APP.In,$APP.Qm,$APP.qM,$APP.Y,$APP.Z,$APP.AD],["0.3.0",$APP.xI,$APP.SJ,"clojure/tools/cli.cljc",35,new $APP.k(null,
6,[$APP.ky,!0,$APP.Xs,2,$APP.$K,2,$APP.qK,new $APP.J(null,1,5,$APP.K,[$APP.N($APP.jB,a9,$APP.wz)],null),$APP.Y,$APP.N(new $APP.J(null,4,5,$APP.K,[$APP.jB,a9,$APP.il,$APP.wz],null)),$APP.tD,$APP.N(null)],null),1,567,567,$APP.N(new $APP.J(null,4,5,$APP.K,[$APP.jB,a9,$APP.il,$APP.wz],null)),'Parse arguments sequence according to given option specifications and the\n  GNU Program Argument Syntax Conventions:\n\n    https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html\n\n  Option specifications are a sequence of vectors with the following format:\n\n    [short-opt long-opt-with-required-description description\n     :property value]\n\n  The first three string parameters in an option spec are positional and\n  optional, and may be nil in order to specify a later parameter.\n\n  By default, options are toggles that default to nil, but the second string\n  parameter may be used to specify that an option requires an argument.\n\n    e.g. ["-p" "--port PORT"] specifies that --port requires an argument,\n         of which PORT is a short description.\n\n  The :property value pairs are optional and take precedence over the\n  positional string arguments. The valid properties are:\n\n    :id           The key for this option in the resulting option map. This\n                  is normally set to the keywordized name of the long option\n                  without the leading dashes.\n\n                  Multiple option entries can share the same :id in order to\n                  transform a value in different ways, but only one of these\n                  option entries may contain a :default(-fn) entry.\n\n                  This option is mandatory.\n\n    :short-opt    The short format for this option, normally set by the first\n                  positional string parameter: e.g. "-p". Must be unique.\n\n    :long-opt     The long format for this option, normally set by the second\n                  positional string parameter; e.g. "--port". Must be unique.\n\n    :required     A description of the required argument for this option if\n                  one is required; normally set in the second positional\n                  string parameter after the long option: "--port PORT".\n\n                  The absence of this entry indicates that the option is a\n                  boolean toggle that is set to true when specified on the\n                  command line.\n\n    :missing      Indicates that this option is required (not just an argument),\n                  and provides the string to use as an error message if omitted.\n\n    :desc         A optional short description of this option.\n\n    :default      The default value of this option. If none is specified, the\n                  resulting option map will not contain an entry for this\n                  option unless set on the command line. Also see :default-fn\n                  (below).\n\n                  This default is applied before any arguments are parsed so\n                  this is a good way to seed values for :assoc-fn or :update-fn\n                  as well as the simplest way to provide defaults.\n\n                  If you need to compute a default based on other command line\n                  arguments, or you need to provide a default separate from the\n                  seed for :assoc-fn or :update-fn, see :default-fn below.\n\n    :default-desc An optional description of the default value. This should be\n                  used when the string representation of the default value is\n                  too ugly to be printed on the command line, or :default-fn\n                  is used to compute the default.\n\n    :default-fn   A function to compute the default value of this option, given\n                  the whole, parsed option map as its one argument. If no\n                  function is specified, the resulting option map will not\n                  contain an entry for this option unless set on the command\n                  line. Also see :default (above).\n\n                  If both :default and :default-fn are provided, if the\n                  argument is not provided on the command-line, :default-fn will\n                  still be called (and can override :default).\n\n    :parse-fn     A function that receives the required option argument and\n                  returns the option value.\n\n                  If this is a boolean option, parse-fn will receive the value\n                  true. This may be used to invert the logic of this option:\n\n                  ["-q" "--quiet"\n                   :id :verbose\n                   :default true\n                   :parse-fn not]\n\n    :assoc-fn     A function that receives the current option map, the current\n                  option :id, and the current parsed option value, and returns\n                  a new option map. The default is \'assoc\'.\n\n                  For non-idempotent options, where you need to compute a option\n                  value based on the current value and a new value from the\n                  command line. If you only need the the current value, consider\n                  :update-fn (below).\n\n                  You cannot specify both :assoc-fn and :update-fn for an\n                  option.\n\n    :update-fn    Without :multi true:\n\n                  A function that receives just the existing parsed option value,\n                  and returns a new option value, for each option :id present.\n                  The default is \'identity\'.\n\n                  This may be used to create non-idempotent options where you\n                  only need the current value, like setting a verbosity level by\n                  specifying an option multiple times. ("-vvv" -\x3e 3)\n\n                  ["-v" "--verbose"\n                   :default 0\n                   :update-fn inc]\n\n                  :default is applied first. If you wish to omit the :default\n                  option value, use fnil in your :update-fn as follows:\n\n                  ["-v" "--verbose"\n                   :update-fn (fnil inc 0)]\n\n                  With :multi true:\n\n                  A function that receives both the existing parsed option value,\n                  and the parsed option value from each instance of the option,\n                  and returns a new option value, for each option :id present.\n                  The :multi option is ignored if you do not specify :update-fn.\n\n                  For non-idempotent options, where you need to compute a option\n                  value based on the current value and a new value from the\n                  command line. This can sometimes be easier than use :assoc-fn.\n\n                  ["-f" "--file NAME"\n                   :default []\n                   :update-fn conj\n                   :multi true]\n\n                  :default is applied first. If you wish to omit the :default\n                  option value, use fnil in your :update-fn as follows:\n\n                  ["-f" "--file NAME"\n                   :update-fn (fnil conj [])\n                   :multi true]\n\n                  Regardless of :multi, you cannot specify both :assoc-fn\n                  and :update-fn for an option.\n\n    :multi        true/false, applies only to options that use :update-fn.\n\n    :validate     A vector of [validate-fn validate-msg ...]. Multiple pairs\n                  of validation functions and error messages may be provided.\n\n    :validate-fn  A vector of functions that receives the parsed option value\n                  and returns a falsy value or throws an exception when the\n                  value is invalid. The validations are tried in the given\n                  order.\n\n    :validate-msg A vector of error messages corresponding to :validate-fn\n                  that will be added to the :errors vector on validation\n                  failure. Can be plain strings, or functions to be applied\n                  to the (invalid) option argument to produce a string.\n\n    :post-validation true/false. By default, validation is performed after\n                  parsing an option, prior to assoc/default/update processing.\n                  Specifying true here will cause the validation to be\n                  performed after assoc/default/update processing, instead.\n\n  parse-opts returns a map with four entries:\n\n    {:options     The options map, keyed by :id, mapped to the parsed value\n     :arguments   A vector of unprocessed arguments\n     :summary     A string containing a minimal options summary\n     :errors      A possible vector of error message strings generated during\n                  parsing; nil when no errors exist}\n\n  A few function options may be specified to influence the behavior of\n  parse-opts:\n\n    :in-order     Stop option processing at the first unknown argument. Useful\n                  for building programs with subcommands that have their own\n                  option specs.\n\n    :no-defaults  Only include option values specified in arguments and do not\n                  include any default values in the resulting options map.\n                  Useful for parsing options from multiple sources; i.e. from a\n                  config file and from the command line.\n\n    :strict       Parse required arguments strictly: if a required argument value\n                  matches any other option, it is considered to be missing (and\n                  you have a parse error).\n\n    :summary-fn   A function that receives the sequence of compiled option specs\n                  (documented at #\'clojure.tools.cli/compile-option-specs), and\n                  returns a custom option summary string.\n  ',
$APP.l(b9)?b9.J:null])),b=$APP.q(a);a=$APP.De(a);var c=$APP.l(null)?null:$APP.R.h(a),d=new $APP.k(null,4,[$APP.U,c9,$APP.R,c,$APP.Y,$APP.Y.h(a),$APP.Z,$APP.Z.h(a)],null);return $APP.l($APP.ar.h(a))?$APP.iu(c,b,d):$APP.l($APP.rq.h(a))?$APP.ju(c,b,d):$APP.hu(c,b,d)}(),dUa,function(){var a=new $APP.Ld(function(){return W8},eUa,$APP.kj([$APP.KA,$APP.U,$APP.R,$APP.Pm,$APP.Jx,$APP.In,$APP.Qm,$APP.qM,$APP.Y,$APP.Z,$APP.AD],["0.3.0",$APP.xI,dUa,"clojure/tools/cli.cljc",42,1,495,495,$APP.N(new $APP.J(null,
2,5,$APP.K,[jUa,$APP.Zw],null)),"Given a single compiled option spec, turn it into a formatted string,\n  optionally with its default values if requested.",$APP.l(W8)?W8.J:null])),b=$APP.q(a);a=$APP.De(a);var c=$APP.l(null)?null:$APP.R.h(a),d=new $APP.k(null,4,[$APP.U,c9,$APP.R,c,$APP.Y,$APP.Y.h(a),$APP.Z,$APP.Z.h(a)],null);return $APP.l($APP.ar.h(a))?$APP.iu(c,b,d):$APP.l($APP.rq.h(a))?$APP.ju(c,b,d):$APP.hu(c,b,d)}()],null);$APP.Wu(new $APP.k(null,1,[$APP.Rq,new $APP.k(null,1,[$APP.xI,mUa],null)],null));