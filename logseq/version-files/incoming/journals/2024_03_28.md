- #go/book #go/workers
	- Even though the "go" keyword is the same name as the language, you would think that this is more commonly used. From my experience, go developers, including myself, will stay away from using go routines and channels as much as possible. The reason being that it adds complexity, that you often don't need. Concurrent code unlocks a lot of performance as tasks that would otherwise "stop the world" only stop the go routine that they are on. Being comfortable with using channels is very important if you want to use go to its maximum capability of a language, but their usage should be thought through first. Can I just implement this as a for loop right now? A common pattern when you start using channels is to have a group of workers process items from your channel. A worker pool can come in different forms, and be configured with different parameters. For example, lets say you want to implement a queue that is backed by the database. To make sure that every item added to the channel is processed, you can add a "ready" channel to make sure there is at least one worker that can immediately handle the data you are sending its way. Otherwise, the channel can get backed up while waiting for workers
	- https://chat.openai.com/share/a575f592-6a2a-43b5-ab07-98df3ff746da
- #go/book config
	- There are many ways to do config. It could be as easy as storing it as a file. Oh wait, no my deployment needs an env var. Oh my coworker has his local config for testing an issue that conflicts with mine, we need multiple. How does staging get configured. Ah! There is a lot of complexity that goes into config managment
- #go/book
	- The flow of development that I generally practice for things like this is breaking code shared code into functions. Dependencies declared in the parameters, and no side effects, ie. functional code.
	- This makes the function very portable and can be easily refactored to anywhere else in the code. As multiple of these functions seem to want to be grouped together (similar dependencies), they get their own service (type Service struct {}).
	- idk if this makes sense, but the goal is to optimize for velocity while also balancing abstraction needs.