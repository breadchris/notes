import { $APP, shadow$provide, $jscomp } from "./nbb_core.js";
const shadow_esm_import = function(x) { return import(x) };
var iBa=new $APP.t("clojure.data","diff","clojure.data/diff",-683865998,null),jBa=new $APP.t(null,"diff","diff",-518492986,null);var kBa=$APP.mu($APP.DJ),lBa=new $APP.k(null,1,[jBa,function(){var a=new $APP.Ld(function(){return $APP.gv},iBa,$APP.kj([$APP.U,$APP.R,$APP.Pm,$APP.Jx,$APP.In,$APP.Qm,$APP.qM,$APP.Y,$APP.Z,$APP.AD],[$APP.DJ,jBa,"clojure/data.cljs",11,1,144,144,$APP.N(new $APP.J(null,2,5,$APP.K,[$APP.LH,$APP.KH],null)),"Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality.",
$APP.l($APP.gv)?$APP.gv.J:null])),b=$APP.q(a);a=$APP.De(a);var c=$APP.l(null)?null:$APP.R.h(a),d=new $APP.k(null,4,[$APP.U,kBa,$APP.R,c,$APP.Y,$APP.Y.h(a),$APP.Z,$APP.Z.h(a)],null);return $APP.l($APP.ar.h(a))?$APP.iu(c,b,d):$APP.l($APP.rq.h(a))?$APP.ju(c,b,d):$APP.hu(c,b,d)}()],null);$APP.Wu(new $APP.k(null,1,[$APP.Rq,new $APP.k(null,1,[$APP.DJ,lBa],null)],null));