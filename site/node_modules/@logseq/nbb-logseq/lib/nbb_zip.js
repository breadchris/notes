import { $APP, shadow$provide, $jscomp } from "./nbb_core.js";
const shadow_esm_import = function(x) { return import(x) };
var qY=function(a,b,c,d){return $APP.Ce(new $APP.J(null,2,5,$APP.K,[d,null],null),new $APP.k(null,3,[fKa,a,gKa,b,hKa,c],null))},rY=function(a){return a.h?a.h(0):a.call(null,0)},sY=function(a){var b=rY(a);a=fKa.h($APP.De(a));return a.h?a.h(b):a.call(null,b)},tY=function(a){if($APP.l(sY(a))){var b=rY(a);a=gKa.h($APP.De(a));return a.h?a.h(b):a.call(null,b)}throw"called children on a leaf node";},uY=function(a,b,c){a=hKa.h($APP.De(a));return a.g?a.g(b,c):a.call(null,b,c)},zY=function(a){if($APP.l(sY(a))){var b=
$APP.B.j(a,0,null),c=$APP.B.j(a,1,null),d=tY(a),e=$APP.u(d),f=$APP.v(e);e=$APP.y(e);return $APP.l(d)?$APP.Ce(new $APP.J(null,2,5,$APP.K,[f,new $APP.k(null,4,[vY,$APP.Xh,wY,$APP.l(c)?$APP.vg.g(wY.h(c),b):new $APP.J(null,1,5,$APP.K,[b],null),xY,c,yY,e],null)],null),$APP.De(a)):null}return null},BY=function(a){var b=$APP.B.j(a,0,null),c=$APP.B.j(a,1,null),d=$APP.bh(c);c=$APP.D.g(d,vY);var e=$APP.D.g(d,xY),f=$APP.D.g(d,wY),g=$APP.D.g(d,yY);d=$APP.D.g(d,AY);return $APP.l(f)?(f=$APP.Ee(f),$APP.Ce($APP.l(d)?
new $APP.J(null,2,5,$APP.K,[uY(a,f,$APP.P.g(c,$APP.Bg(b,g))),$APP.l(e)?$APP.yj.j(e,AY,!0):e],null):new $APP.J(null,2,5,$APP.K,[f,e],null),$APP.De(a))):null},CY=function(a){var b=$APP.B.j(a,0,null),c=$APP.B.j(a,1,null);c=$APP.bh(c);var d=$APP.D.g(c,vY),e=$APP.D.g(c,yY),f=$APP.u(e),g=$APP.v(f);f=$APP.y(f);return $APP.l($APP.l(c)?e:c)?$APP.Ce(new $APP.J(null,2,5,$APP.K,[g,$APP.yj.l(c,vY,$APP.vg.g(d,b),$APP.C([yY,f]))],null),$APP.De(a)):null},DY=function(a){var b=$APP.B.j(a,0,null),c=$APP.B.j(a,1,null);
c=$APP.bh(c);var d=$APP.D.g(c,vY),e=$APP.D.g(c,yY);return $APP.l($APP.l(c)?e:c)?$APP.Ce(new $APP.J(null,2,5,$APP.K,[$APP.xe(e),$APP.yj.l(c,vY,$APP.zh.G($APP.vg,d,b,$APP.Gj(e)),$APP.C([yY,null]))],null),$APP.De(a)):a},iKa=function(a){var b=$APP.B.j(a,0,null),c=$APP.B.j(a,1,null);c=$APP.bh(c);var d=$APP.D.g(c,vY),e=$APP.D.g(c,yY);return $APP.l($APP.l(c)?$APP.u(d):c)?$APP.Ce(new $APP.J(null,2,5,$APP.K,[$APP.Ee(d),$APP.yj.l(c,vY,$APP.Fe(d),$APP.C([yY,$APP.Bg(b,e)]))],null),$APP.De(a)):null},EY=function(a,
b){$APP.B.j(a,0,null);var c=$APP.B.j(a,1,null);return $APP.Ce(new $APP.J(null,2,5,$APP.K,[b,$APP.yj.j(c,AY,!0)],null),$APP.De(a))},FY=new $APP.t(null,"make-node","make-node",-1550461835,null),jKa=new $APP.t("clojure.zip","append-child","clojure.zip/append-child",-1333956306,null),kKa=new $APP.t(null,"insert-right","insert-right",1842751767,null),lKa=new $APP.t("clojure.zip","insert-child","clojure.zip/insert-child",-210602132,null),mKa=new $APP.t("clojure.zip","end?","clojure.zip/end?",381053413,
null),nKa=new $APP.t(null,"insert-left","insert-left",1917369949,null),oKa=new $APP.t(null,"lefts","lefts",1054400638,null),pKa=new $APP.t("clojure.zip","node","clojure.zip/node",-1345203614,null),qKa=new $APP.t("clojure.zip","edit","clojure.zip/edit",-442418038,null),rKa=new $APP.t("clojure.zip","zipper","clojure.zip/zipper",-571036006,null),GY=new $APP.t(null,"item","item",1889905329,null),sKa=new $APP.t("clojure.zip","next","clojure.zip/next",-1526224397,null),gKa=new $APP.G("zip","children","zip/children",
-940194589),tKa=new $APP.t(null,"up","up",1370819414,null),uKa=new $APP.t("clojure.zip","branch?","clojure.zip/branch?",-1006947869,null),vKa=new $APP.t("clojure.zip","up","clojure.zip/up",1006365229,null),wKa=new $APP.t("clojure.zip","children","clojure.zip/children",65376544,null),xKa=new $APP.t("clojure.zip","leftmost","clojure.zip/leftmost",-1791272498,null),yKa=new $APP.t(null,"leftmost","leftmost",-1158121305,null),wY=new $APP.G(null,"pnodes","pnodes",1739080565),zKa=new $APP.t(null,"xml-zip",
"xml-zip",-1566989793,null),AKa=new $APP.t("clojure.zip","replace","clojure.zip/replace",413367034,null),BKa=new $APP.t(null,"end?","end?",217139918,null),CKa=new $APP.t("clojure.zip","path","clojure.zip/path",1758958974,null),DKa=new $APP.t("clojure.zip","rightmost","clojure.zip/rightmost",1799140158,null),EKa=new $APP.t("clojure.zip","xml-zip","clojure.zip/xml-zip",-925187274,null),FKa=new $APP.t("clojure.zip","down","clojure.zip/down",1356031458,null),GKa=new $APP.G(null,"content","content",15833224),
hKa=new $APP.G("zip","make-node","zip/make-node",1103800591),HKa=new $APP.t("clojure.zip","seq-zip","clojure.zip/seq-zip",-395973642,null),IKa=new $APP.t("clojure.zip","prev","clojure.zip/prev",-389017676,null),JKa=new $APP.t("clojure.zip","insert-right","clojure.zip/insert-right",194316302,null),KKa=new $APP.t("clojure.zip","vector-zip","clojure.zip/vector-zip",986730862,null),AY=new $APP.G(null,"changed?","changed?",-437828330),LKa=new $APP.t(null,"zipper","zipper",-1153741331,null),MKa=new $APP.t("clojure.zip",
"left","clojure.zip/left",1740332703,null),NKa=new $APP.t(null,"append-child","append-child",-1707191801,null),OKa=new $APP.t("clojure.zip","root","clojure.zip/root",-1119588559,null),PKa=new $APP.t(null,"vector-zip","vector-zip",1075131029,null),QKa=new $APP.t(null,"insert-child","insert-child",347166277,null),RKa=new $APP.t("clojure.zip","remove","clojure.zip/remove",859584278,null),SKa=new $APP.t("clojure.zip","insert-left","clojure.zip/insert-left",1476893044,null),TKa=new $APP.t(null,"rightmost",
"rightmost",-1854156251,null),UKa=new $APP.t("clojure.zip","rights","clojure.zip/rights",1361118051,null),VKa=new $APP.t("clojure.zip","make-node","clojure.zip/make-node",-640223892,null),WKa=new $APP.t(null,"seq-zip","seq-zip",-2034709283,null),XKa=new $APP.t(null,"down","down",-1089190199,null),YKa=new $APP.t(null,"rights","rights",2003591322,null),yY=new $APP.G(null,"r","r",-471384190),vY=new $APP.G(null,"l","l",1395893423),ZKa=new $APP.t("clojure.zip","right","clojure.zip/right",-1593586409,null),
xY=new $APP.G(null,"ppath","ppath",-1758182784),HY=new $APP.t(null,"loc","loc",1056246626,null),fKa=new $APP.G("zip","branch?","zip/branch?",-998880862),$Ka=new $APP.t("clojure.zip","lefts","clojure.zip/lefts",538689815,null);var IY=function IY(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return IY.l(arguments[0],arguments[1],2<c.length?new $APP.Nd(c.slice(2),0,null):null)};IY.l=function(a,b,c){return EY(a,$APP.zh.j(b,rY(a),c))};IY.B=2;IY.F=function(a){var b=$APP.v(a),c=$APP.y(a);a=$APP.v(c);c=$APP.y(c);return this.l(b,a,c)};var aLa=$APP.mu($APP.FK),bLa=$APP.tu($APP.kj([$APP.Ce(LKa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,4,5,$APP.K,[$APP.wG,$APP.XE,FY,$APP.vJ],null))),$APP.Z,"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],
null)),$APP.Ce(tKa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],null)),$APP.Ce($APP.dsa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],null)),$APP.Ce(kKa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,2,5,
$APP.K,[HY,GY],null))),$APP.Z,"Inserts the item as the right sibling of the node at this loc,\n  without moving"],null)),$APP.Ce(nKa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,2,5,$APP.K,[HY,GY],null))),$APP.Z,"Inserts the item as the left sibling of the node at this loc,\n without moving"],null)),$APP.Ce(BKa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"Returns true if loc represents the end of a depth-first walk"],null)),$APP.Ce($APP.cC,
new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"Returns the node at loc"],null)),$APP.Ce($APP.KL,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,2,5,$APP.K,[HY,$APP.cC],null))),$APP.Z,"Replaces the node at this loc, without moving"],null)),$APP.Ce($APP.sma,new $APP.k(null,3,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,4,5,$APP.K,[HY,$APP.PH,$APP.il,$APP.jB],null))),$APP.Z,"Replaces the node at this loc with the value of (f node args)",
$APP.NI,new $APP.k(null,6,[$APP.ky,!0,$APP.Xs,2,$APP.$K,2,$APP.qK,new $APP.J(null,1,5,$APP.K,[$APP.N(HY,$APP.PH,$APP.jB)],null),$APP.Y,$APP.N(new $APP.J(null,4,5,$APP.K,[HY,$APP.PH,$APP.il,$APP.jB],null)),$APP.tD,$APP.N(null)],null)],null)),$APP.Ce(WKa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[$APP.vJ],null))),$APP.Z,"Returns a zipper for nested sequences, given a root sequence"],null)),$APP.Ce($APP.WI,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,
1,5,$APP.K,[HY],null))),$APP.Z,"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],null)),$APP.Ce(zKa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[$APP.vJ],null))),$APP.Z,"Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],null)),$APP.Ce(PKa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[$APP.vJ],
null))),$APP.Z,"Returns a zipper for nested vectors, given a root vector"],null)),$APP.Ce(FY,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,3,5,$APP.K,[HY,$APP.cC,$APP.XE],null))),$APP.Z,"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],null)),$APP.Ce($APP.wG,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"Returns true if the node at loc is a branch"],null)),$APP.Ce($APP.Yka,
new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"Returns the loc of the right sibling of the node at this loc, or nil"],null)),$APP.Ce($APP.ura,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"Returns a seq of nodes leading to this loc"],null)),$APP.Ce($APP.vJ,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"zips all the way up and returns the root node, reflecting any\n changes."],
null)),$APP.Ce(YKa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"Returns a seq of the right siblings of this loc"],null)),$APP.Ce($APP.XE,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"Returns a seq of the children of node at loc, which must be a branch"],null)),$APP.Ce(yKa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"Returns the loc of the leftmost sibling of the node at this loc, or self"],
null)),$APP.Ce(XKa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],null)),$APP.Ce($APP.mqa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"Returns the loc of the left sibling of the node at this loc, or nil"],null)),$APP.Ce(oKa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),
$APP.Z,"Returns a seq of the left siblings of this loc"],null)),$APP.Ce(QKa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,2,5,$APP.K,[HY,GY],null))),$APP.Z,"Inserts the item as the leftmost child of the node at this loc,\n  without moving"],null)),$APP.Ce(NKa,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,2,5,$APP.K,[HY,GY],null))),$APP.Z,"Inserts the item as the rightmost child of the node at this loc,\n  without moving"],null)),$APP.Ce(TKa,new $APP.k(null,2,[$APP.Y,
$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"Returns the loc of the rightmost sibling of the node at this loc, or self"],null)),$APP.Ce($APP.jy,new $APP.k(null,2,[$APP.Y,$APP.N($APP.xl,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null))),$APP.Z,"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],null))],[new $APP.k(null,3,[$APP.R,rKa,$APP.su,qY,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,4,5,$APP.K,[$APP.wG,$APP.XE,FY,
$APP.vJ],null)),$APP.Z,"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],null)],null),new $APP.k(null,3,[$APP.R,vKa,$APP.su,BY,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,
1,5,$APP.K,[HY],null)),$APP.Z,"Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],null)],null),new $APP.k(null,3,[$APP.R,IKa,$APP.su,function(a){var b=iKa(a);if($APP.l(b))for(a=b;;)if(b=sY(a),b=$APP.l(b)?zY(a):b,$APP.l(b))a=DY(b);else return a;else return BY(a)},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null)),$APP.Z,"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],null)],null),new $APP.k(null,
3,[$APP.R,JKa,$APP.su,function(a,b){var c=$APP.B.j(a,0,null),d=$APP.B.j(a,1,null);d=$APP.bh(d);var e=$APP.D.g(d,yY);if(null==d)throw"Insert at top";return $APP.Ce(new $APP.J(null,2,5,$APP.K,[c,$APP.yj.l(d,yY,$APP.Bg(b,e),$APP.C([AY,!0]))],null),$APP.De(a))},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,2,5,$APP.K,[HY,GY],null)),$APP.Z,"Inserts the item as the right sibling of the node at this loc,\n  without moving"],null)],null),new $APP.k(null,3,[$APP.R,SKa,$APP.su,function(a,b){var c=
$APP.B.j(a,0,null),d=$APP.B.j(a,1,null);d=$APP.bh(d);var e=$APP.D.g(d,vY);if(null==d)throw"Insert at top";return $APP.Ce(new $APP.J(null,2,5,$APP.K,[c,$APP.yj.l(d,vY,$APP.vg.g(e,b),$APP.C([AY,!0]))],null),$APP.De(a))},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,2,5,$APP.K,[HY,GY],null)),$APP.Z,"Inserts the item as the left sibling of the node at this loc,\n without moving"],null)],null),new $APP.k(null,3,[$APP.R,mKa,$APP.su,function(a){return $APP.A.g($APP.oF,a.h?a.h(1):a.call(null,1))},
$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null)),$APP.Z,"Returns true if loc represents the end of a depth-first walk"],null)],null),new $APP.k(null,3,[$APP.R,pKa,$APP.su,rY,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null)),$APP.Z,"Returns the node at loc"],null)],null),new $APP.k(null,3,[$APP.R,AKa,$APP.su,EY,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,2,5,$APP.K,[HY,$APP.cC],null)),$APP.Z,"Replaces the node at this loc, without moving"],
null)],null),new $APP.k(null,3,[$APP.R,qKa,$APP.su,IY,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,4,5,$APP.K,[HY,$APP.PH,$APP.il,$APP.jB],null)),$APP.Z,"Replaces the node at this loc with the value of (f node args)"],null)],null),new $APP.k(null,3,[$APP.R,HKa,$APP.su,function(a){return qY($APP.Ve,$APP.uf,function(b,c){return $APP.Ce(c,$APP.De(b))},a)},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[$APP.vJ],null)),$APP.Z,"Returns a zipper for nested sequences, given a root sequence"],
null)],null),new $APP.k(null,3,[$APP.R,sKa,$APP.su,function(a){if($APP.A.g($APP.oF,a.h?a.h(1):a.call(null,1)))return a;var b=sY(a);b=$APP.l(b)?zY(a):b;if($APP.l(b))return b;b=CY(a);if($APP.l(b))return b;for(;;)if($APP.l(BY(a))){b=CY(BY(a));if($APP.l(b))return b;a=BY(a)}else return new $APP.J(null,2,5,$APP.K,[rY(a),$APP.oF],null)},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null)),$APP.Z,"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],
null)],null),new $APP.k(null,3,[$APP.R,EKa,$APP.su,function(a){return qY($APP.Ah($APP.yb),$APP.xq.g($APP.u,GKa),function(b,c){return $APP.yj.j(b,GKa,$APP.l(c)?$APP.zh.g($APP.iw,c):c)},a)},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[$APP.vJ],null)),$APP.Z,"Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],null)],null),new $APP.k(null,3,[$APP.R,KKa,$APP.su,function(a){return qY($APP.Oe,$APP.u,function(b,c){return $APP.Ce($APP.pf(c),$APP.De(b))},
a)},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[$APP.vJ],null)),$APP.Z,"Returns a zipper for nested vectors, given a root vector"],null)],null),new $APP.k(null,3,[$APP.R,VKa,$APP.su,uY,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,3,5,$APP.K,[HY,$APP.cC,$APP.XE],null)),$APP.Z,"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],null)],null),new $APP.k(null,3,[$APP.R,uKa,$APP.su,sY,$APP.eb,new $APP.k(null,
2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null)),$APP.Z,"Returns true if the node at loc is a branch"],null)],null),new $APP.k(null,3,[$APP.R,ZKa,$APP.su,CY,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null)),$APP.Z,"Returns the loc of the right sibling of the node at this loc, or nil"],null)],null),new $APP.k(null,3,[$APP.R,CKa,$APP.su,function(a){return wY.h(a.h?a.h(1):a.call(null,1))},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null)),
$APP.Z,"Returns a seq of nodes leading to this loc"],null)],null),new $APP.k(null,3,[$APP.R,OKa,$APP.su,function(a){for(;;){if($APP.A.g($APP.oF,a.h?a.h(1):a.call(null,1)))return rY(a);var b=BY(a);if($APP.l(b))a=b;else return rY(a)}},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null)),$APP.Z,"zips all the way up and returns the root node, reflecting any\n changes."],null)],null),new $APP.k(null,3,[$APP.R,UKa,$APP.su,function(a){return yY.h(a.h?a.h(1):a.call(null,1))},$APP.eb,
new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null)),$APP.Z,"Returns a seq of the right siblings of this loc"],null)],null),new $APP.k(null,3,[$APP.R,wKa,$APP.su,tY,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null)),$APP.Z,"Returns a seq of the children of node at loc, which must be a branch"],null)],null),new $APP.k(null,3,[$APP.R,xKa,$APP.su,function(a){var b=$APP.B.j(a,0,null),c=$APP.B.j(a,1,null);c=$APP.bh(c);var d=$APP.D.g(c,vY),e=$APP.D.g(c,yY);
return $APP.l($APP.l(c)?$APP.u(d):c)?$APP.Ce(new $APP.J(null,2,5,$APP.K,[$APP.v(d),$APP.yj.l(c,vY,$APP.Xh,$APP.C([yY,$APP.P.l($APP.Rd(d),new $APP.J(null,1,5,$APP.K,[b],null),$APP.C([e]))]))],null),$APP.De(a)):a},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null)),$APP.Z,"Returns the loc of the leftmost sibling of the node at this loc, or self"],null)],null),new $APP.k(null,3,[$APP.R,FKa,$APP.su,zY,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],
null)),$APP.Z,"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],null)],null),new $APP.k(null,3,[$APP.R,MKa,$APP.su,iKa,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null)),$APP.Z,"Returns the loc of the left sibling of the node at this loc, or nil"],null)],null),new $APP.k(null,3,[$APP.R,$Ka,$APP.su,function(a){return $APP.u(vY.h(a.h?a.h(1):a.call(null,1)))},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],
null)),$APP.Z,"Returns a seq of the left siblings of this loc"],null)],null),new $APP.k(null,3,[$APP.R,lKa,$APP.su,function(a,b){return EY(a,uY(a,rY(a),$APP.Bg(b,tY(a))))},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,2,5,$APP.K,[HY,GY],null)),$APP.Z,"Inserts the item as the leftmost child of the node at this loc,\n  without moving"],null)],null),new $APP.k(null,3,[$APP.R,jKa,$APP.su,function(a,b){return EY(a,uY(a,rY(a),$APP.P.g(tY(a),new $APP.J(null,1,5,$APP.K,[b],null))))},$APP.eb,new $APP.k(null,
2,[$APP.Y,$APP.N(new $APP.J(null,2,5,$APP.K,[HY,GY],null)),$APP.Z,"Inserts the item as the rightmost child of the node at this loc,\n  without moving"],null)],null),new $APP.k(null,3,[$APP.R,DKa,$APP.su,DY,$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null)),$APP.Z,"Returns the loc of the rightmost sibling of the node at this loc, or self"],null)],null),new $APP.k(null,3,[$APP.R,RKa,$APP.su,function(a){$APP.B.j(a,0,null);var b=$APP.B.j(a,1,null);b=$APP.bh(b);var c=$APP.D.g(b,
vY),d=$APP.D.g(b,xY),e=$APP.D.g(b,wY),f=$APP.D.g(b,yY);if(null==b)throw"Remove at top";if(0<$APP.me(c))for(a=$APP.Ce(new $APP.J(null,2,5,$APP.K,[$APP.Ee(c),$APP.yj.l(b,vY,$APP.Fe(c),$APP.C([AY,!0]))],null),$APP.De(a));;)if(b=sY(a),b=$APP.l(b)?zY(a):b,$APP.l(b))a=DY(b);else return a;else return $APP.Ce(new $APP.J(null,2,5,$APP.K,[uY(a,$APP.Ee(e),f),$APP.l(d)?$APP.yj.j(d,AY,!0):d],null),$APP.De(a))},$APP.eb,new $APP.k(null,2,[$APP.Y,$APP.N(new $APP.J(null,1,5,$APP.K,[HY],null)),$APP.Z,"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],
null)],null)]),aLa);$APP.Wu(new $APP.k(null,1,[$APP.Rq,new $APP.k(null,1,[$APP.FK,bLa],null)],null));